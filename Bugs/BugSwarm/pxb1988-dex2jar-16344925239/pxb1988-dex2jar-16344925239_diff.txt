diff --git a/d2j-jasmin/src/main/antlr3/com/googlecode/d2j/jasmin/Jasmin.g b/d2j-jasmin/src/main/antlr3/com/googlecode/d2j/jasmin/Jasmin.g
index 95a05f1..98725ea 100644
--- a/d2j-jasmin/src/main/antlr3/com/googlecode/d2j/jasmin/Jasmin.g
+++ b/d2j-jasmin/src/main/antlr3/com/googlecode/d2j/jasmin/Jasmin.g
@@ -1163,10 +1163,10 @@ code
 	            }
 	|	a=JOP z=sLabel  { line($a.line); visitJOP(getOp($a.text),getLabel($z.text)); }
 	|	a=XINVOKE e1=sMethodObject   {line($a.line);
-	                    mn.visitMethodInsn(getOp($a.text),$e1.ownerInternalName,$e1.memberName,$e1.desc);
+	                    mn.visitMethodInsn(getOp($a.text),$e1.ownerInternalName,$e1.memberName,$e1.desc, false);
 	                  }
 	|	a=INVOKEINTERFACE e2=sMethodObject INT?  {line($a.line);
-	                    mn.visitMethodInsn(getOp($a.text),$e2.ownerInternalName,$e2.memberName,$e2.desc);
+	                    mn.visitMethodInsn(getOp($a.text),$e2.ownerInternalName,$e2.memberName,$e2.desc, true);
 	                  }
 	|	a=INVOKEDYNAMIC e3=sMethodObject sId sMethodDesc '(' sInvokeDynamicE (',' sInvokeDynamicE)* ')'  {line($a.line); if(1==1) throw new RuntimeException("not support Yet!");}
 	|	a=MULTIANEWARRAY ff=sClassDesc c=INT   {line($a.line); mn.visitMultiANewArrayInsn(unEscape($ff.text),parseInt($c.text)); }
diff --git a/d2j-jasmin/src/main/java/com/googlecode/d2j/jasmin/JasminDumper.java b/d2j-jasmin/src/main/java/com/googlecode/d2j/jasmin/JasminDumper.java
index 90c641c..ebf5f0c 100644
--- a/d2j-jasmin/src/main/java/com/googlecode/d2j/jasmin/JasminDumper.java
+++ b/d2j-jasmin/src/main/java/com/googlecode/d2j/jasmin/JasminDumper.java
@@ -381,7 +381,7 @@ public class JasminDumper implements Opcodes {
                         }
 
                         @Override
-                        public void visitMethodInsn(int opcode, String owner, String name, String desc) {
+                        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean isInterface) {
                             print(opcode);
                             pw.print(' ');
                             pw.print(owner);
diff --git a/dex-tools/src/main/java/com/googlecode/d2j/tools/jar/InvocationWeaver.java b/dex-tools/src/main/java/com/googlecode/d2j/tools/jar/InvocationWeaver.java
index 7cc116c..5f8a9f7 100644
--- a/dex-tools/src/main/java/com/googlecode/d2j/tools/jar/InvocationWeaver.java
+++ b/dex-tools/src/main/java/com/googlecode/d2j/tools/jar/InvocationWeaver.java
@@ -129,28 +129,28 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
             case Type.ARRAY:
                 return;
             case Type.INT:
-                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;");
+                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
                 break;
             case Type.LONG:
-                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;");
+                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;", false);
                 break;
             case Type.FLOAT:
-                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Floag", "valueOf", "(F)Ljava/lang/Floag;");
+                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Floag", "valueOf", "(F)Ljava/lang/Floag;", false);
                 break;
             case Type.DOUBLE:
-                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double;");
+                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double;", false);
                 break;
             case Type.SHORT:
-                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short;");
+                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short;", false);
                 break;
             case Type.CHAR:
-                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character;");
+                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character;", false);
                 break;
             case Type.BOOLEAN:
-                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;");
+                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;", false);
                 break;
             case Type.BYTE:
-                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte;");
+                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte;", false);
                 break;
             case Type.VOID:
                 mv.visitInsn(ACONST_NULL);
@@ -175,35 +175,35 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
                 break;
             case Type.INT:
                 mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
-                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I");
+                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false);
                 break;
             case Type.FLOAT:
                 mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
-                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F");
+                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "floatValue", "()F", false);
                 break;
             case Type.LONG:
                 mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
-                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J");
+                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "longValue", "()J", false);
                 break;
             case Type.DOUBLE:
                 mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
-                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D");
+                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "doubleValue", "()D", false);
                 break;
             case Type.BYTE:
                 mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
-                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "byteValue", "()B");
+                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "byteValue", "()B", false);
                 break;
             case Type.SHORT:
                 mv.visitTypeInsn(CHECKCAST, "java/lang/Number");
-                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "shortValue", "()S");
+                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "shortValue", "()S", false);
                 break;
             case Type.CHAR:
                 mv.visitTypeInsn(CHECKCAST, "java/lang/Character");
-                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C");
+                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Character", "charValue", "()C", false);
                 break;
             case Type.BOOLEAN:
                 mv.visitTypeInsn(CHECKCAST, "java/lang/Boolean");
-                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z");
+                mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false);
                 break;
         }
     }
@@ -284,9 +284,9 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
                 int nextIdx = callbacks.size();
                 mv.visitLdcInsn(nextIdx);
                 mv.visitMethodInsn(INVOKESPECIAL, getCurrentInvocationName(), "<init>",
-                        "(Ljava/lang/Object;[Ljava/lang/Object;I)V");
+                        "(Ljava/lang/Object;[Ljava/lang/Object;I)V", false);
 
-                mv.visitMethodInsn(INVOKESTATIC, toInternal(mapTo.owner), mapTo.name, mapTo.desc);
+                mv.visitMethodInsn(INVOKESTATIC, toInternal(mapTo.owner), mapTo.name, mapTo.desc, false);
                 unBox(ret, Type.getReturnType(mapTo.desc), mv);
                 mv.visitInsn(ret.getOpcode(IRETURN));
                 mv.visitMaxs(-1, -1);
@@ -331,7 +331,7 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
                     mv.visitInsn(AALOAD);
                     unBox(args[i], OBJECT_TYPE, mv);
                 }
-                mv.visitMethodInsn(opcode, toInternal(t.owner), t.name, t.desc);
+                mv.visitMethodInsn(opcode, toInternal(t.owner), t.name, t.desc, opcode == INVOKEINTERFACE);
                 Type ret = Type.getReturnType(t.desc);
                 box(ret, mv);
                 mv.visitInsn(ARETURN);
@@ -423,7 +423,7 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
                 }
 
                 @Override
-                public void visitMethodInsn(int opcode, String owner, String name, String desc) {
+                public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean isInterface) {
                     MtdInfo mapTo = findTargetMethod("L" + owner + ";", name, desc);
                     if (mapTo != null) {
                         boolean isStatic = opcode == INVOKESTATIC;
@@ -441,7 +441,7 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
                             t.name = name;
                             t.desc = desc;
                             MtdInfo n = newMethodA(opcode, t, mapTo);
-                            super.visitMethodInsn(INVOKESTATIC, clzName, n.name, n.desc);
+                            super.visitMethodInsn(INVOKESTATIC, clzName, n.name, n.desc, isInterface);
                         } else { // simple replace
                             // checking for invalid replace
                             if (isStatic) {
@@ -464,12 +464,12 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
                                 }
                             }
                             // replace it!
-                            super.visitMethodInsn(INVOKESTATIC, toInternal(mapTo.owner), mapTo.name, mapTo.desc);
+                            super.visitMethodInsn(INVOKESTATIC, toInternal(mapTo.owner), mapTo.name, mapTo.desc, isInterface);
                             unBox(orgRet, nRet, this.mv);
                         }
 
                     } else {
-                        super.visitMethodInsn(opcode, owner, name, desc);
+                        super.visitMethodInsn(opcode, owner, name, desc, isInterface);
                     }
                 }
             }
@@ -543,7 +543,7 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
                     null);
             mv.visitCode();
             mv.visitVarInsn(ALOAD, 0);
-            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
+            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
             mv.visitVarInsn(ALOAD, 0);
             mv.visitVarInsn(ALOAD, 1);
             mv.visitFieldInsn(PUTFIELD, typeName, "thiz", "Ljava/lang/Object;");
@@ -617,20 +617,20 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
                 if (cb.isStatic) {
                     mv.visitVarInsn(ALOAD, 0);
                     mv.visitFieldInsn(GETFIELD, typeName, "args", "[Ljava/lang/Object;");
-                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc);
+                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc, false);
                 } else if (cb.isSpecial) {
                     mv.visitVarInsn(ALOAD, 0);
                     mv.visitFieldInsn(GETFIELD, typeName, "thiz", "Ljava/lang/Object;");
                     mv.visitTypeInsn(CHECKCAST, toInternal(m.owner));
                     mv.visitVarInsn(ALOAD, 0);
                     mv.visitFieldInsn(GETFIELD, typeName, "args", "[Ljava/lang/Object;");
-                    mv.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.owner), m.name, m.desc);
+                    mv.visitMethodInsn(INVOKEVIRTUAL, toInternal(m.owner), m.name, m.desc, false);
                 } else {
                     mv.visitVarInsn(ALOAD, 0);
                     mv.visitFieldInsn(GETFIELD, typeName, "thiz", "Ljava/lang/Object;");
                     mv.visitVarInsn(ALOAD, 0);
                     mv.visitFieldInsn(GETFIELD, typeName, "args", "[Ljava/lang/Object;");
-                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc);
+                    mv.visitMethodInsn(INVOKESTATIC, toInternal(m.owner), m.name, m.desc, false);
                 }
                 Type ret = Type.getReturnType(m.desc);
                 box(ret, mv);
@@ -640,7 +640,7 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
             mv.visitTypeInsn(NEW, "java/lang/RuntimeException");
             mv.visitInsn(DUP);
             mv.visitLdcInsn("invalid idx");
-            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V");
+            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V", false);
             mv.visitInsn(ATHROW);
             mv.visitMaxs(-1, -1);
             mv.visitEnd();
@@ -683,7 +683,7 @@ public class InvocationWeaver extends BaseWeaver implements Opcodes {
         mv.visitTypeInsn(NEW, "java/lang/RuntimeException");
         mv.visitInsn(DUP);
         mv.visitLdcInsn("invalid idx");
-        mv.visitMethodInsn(INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V");
+        mv.visitMethodInsn(INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V", false);
         mv.visitInsn(ATHROW);
         mv.visitMaxs(-1, -1);
         mv.visitEnd();
diff --git a/dex-tools/src/main/java/com/googlecode/d2j/tools/jar/ScanBridgeAdapter.java b/dex-tools/src/main/java/com/googlecode/d2j/tools/jar/ScanBridgeAdapter.java
index 6ff5d26..62ce0ca 100644
--- a/dex-tools/src/main/java/com/googlecode/d2j/tools/jar/ScanBridgeAdapter.java
+++ b/dex-tools/src/main/java/com/googlecode/d2j/tools/jar/ScanBridgeAdapter.java
@@ -49,8 +49,8 @@ public class ScanBridgeAdapter extends ClassVisitor implements Opcodes {
             mv = new MethodVisitor(ASM9, mv) {
 
                 @Override
-                public void visitMethodInsn(int opcode, String owner, String name, String desc) {
-                    super.visitMethodInsn(opcode, owner, name, desc);
+                public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean isInterface) {
+                    super.visitMethodInsn(opcode, owner, name, desc, isInterface);
                     if (!name.equals(member.name)) {
                         bridge.put(owner + '.' + name + desc.substring(0, desc.lastIndexOf(')') + 1), member);
                     }
diff --git a/dex-tools/src/main/java/com/googlecode/dex2jar/tools/GenerateCompileStubFromOdex.java b/dex-tools/src/main/java/com/googlecode/dex2jar/tools/GenerateCompileStubFromOdex.java
index 03e0b6c..84d4c96 100644
--- a/dex-tools/src/main/java/com/googlecode/dex2jar/tools/GenerateCompileStubFromOdex.java
+++ b/dex-tools/src/main/java/com/googlecode/dex2jar/tools/GenerateCompileStubFromOdex.java
@@ -110,7 +110,7 @@ public class GenerateCompileStubFromOdex extends BaseCmd {
                         mv.visitInsn(Opcodes.DUP);
                         mv.visitLdcInsn("stub");
                         mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/RuntimeException", "<init>",
-                                "(Ljava/lang/String;)V");
+                                "(Ljava/lang/String;)V", false);
                         mv.visitInsn(Opcodes.ATHROW);
                         return mv;
                     }
diff --git a/dex-translator/src/main/java/com/googlecode/d2j/converter/IR2JConverter.java b/dex-translator/src/main/java/com/googlecode/d2j/converter/IR2JConverter.java
index 892b8c8..9bf8f24 100755
--- a/dex-translator/src/main/java/com/googlecode/d2j/converter/IR2JConverter.java
+++ b/dex-translator/src/main/java/com/googlecode/d2j/converter/IR2JConverter.java
@@ -815,7 +815,7 @@ public class IR2JConverter implements Opcodes {
             if (ie.vt == VT.INVOKE_NEW) {
                 p = new Proto(p.getParameterTypes(), "V");
             }
-            asm.visitMethodInsn(opcode, toInternal(ie.getOwner()), ie.getName(), p.getDesc());
+            asm.visitMethodInsn(opcode, toInternal(ie.getOwner()), ie.getName(), p.getDesc(), opcode == INVOKEINTERFACE);
         }
         break;
         case INVOKE_CUSTOM: {
diff --git a/dex-translator/src/main/java/com/googlecode/d2j/dex/BaseDexExceptionHandler.java b/dex-translator/src/main/java/com/googlecode/d2j/dex/BaseDexExceptionHandler.java
index 195423d..5c750f0 100644
--- a/dex-translator/src/main/java/com/googlecode/d2j/dex/BaseDexExceptionHandler.java
+++ b/dex-translator/src/main/java/com/googlecode/d2j/dex/BaseDexExceptionHandler.java
@@ -41,7 +41,7 @@ public class BaseDexExceptionHandler implements DexExceptionHandler {
         mv.visitTypeInsn(Opcodes.NEW, "java/lang/RuntimeException");
         mv.visitInsn(Opcodes.DUP);
         mv.visitLdcInsn(msg);
-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V");
+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/RuntimeException", "<init>", "(Ljava/lang/String;)V", false);
         mv.visitInsn(Opcodes.ATHROW);
     }
 }
