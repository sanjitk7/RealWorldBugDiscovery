diff --git a/Makefile b/Makefile
index 0add02f4..6a8ee386 100644
--- a/Makefile
+++ b/Makefile
@@ -11,15 +11,15 @@ test:
 #################################################################################
 
 .PHONY: serve
-serve: .venv/ | docs
+serve:
 	@.venv/bin/python -m http.server --directory ./example/docs/_build/html
 
 .PHONY: docs
-docs: .venv/
+docs: .venv/bin/activate
 	@bash -c "source .venv/bin/activate; pip install -q .[docs]; ./example/build.sh"
 
-.venv/:
-	python -m venv .venv
+.venv/bin/activate:
+	@python -m venv .venv
 
 #################################################################################
 # Version management
diff --git a/example/build.sh b/example/build.sh
index 38c5d66d..58942bac 100755
--- a/example/build.sh
+++ b/example/build.sh
@@ -23,16 +23,6 @@ output_dir="$script_dir/docs"
   --exclude "test/test_create_spoken_forms.py" \
   --exclude "test/test_dictation.py" \
   --exclude "test/test_formatters.py" \
-  --exclude "plugin/draft_editor/draft_editor_open.talon" \
-  --exclude "plugin/draft_editor/draft_editor.py" \
-  --exclude "plugin/draft_editor/draft_editor.talon" \
-  --exclude "plugin/talon_draft_window/__init__.py" \
-  --exclude "plugin/talon_draft_window/draft_global.talon" \
-  --exclude "plugin/talon_draft_window/draft_talon_helpers.py" \
-  --exclude "plugin/talon_draft_window/draft_ui.py" \
-  --exclude "plugin/talon_draft_window/draft_window_open.talon" \
-  --exclude "plugin/talon_draft_window/draft_window.talon" \
-  --exclude "plugin/talon_draft_window/test_draft_ui.py" \
   "$script_dir/knausj_talon/" \
   || echo > "$fail"
 
diff --git a/example/docs/conf.py b/example/docs/conf.py
index ba35cbb0..ab6a1118 100644
--- a/example/docs/conf.py
+++ b/example/docs/conf.py
@@ -70,16 +70,6 @@ talon_package = {
         "test/test_create_spoken_forms.py",
         "test/test_dictation.py",
         "test/test_formatters.py",
-        "plugin/draft_editor/draft_editor_open.talon",
-        "plugin/draft_editor/draft_editor.py",
-        "plugin/draft_editor/draft_editor.talon",
-        "plugin/talon_draft_window/__init__.py",
-        "plugin/talon_draft_window/draft_global.talon",
-        "plugin/talon_draft_window/draft_talon_helpers.py",
-        "plugin/talon_draft_window/draft_ui.py",
-        "plugin/talon_draft_window/draft_window_open.talon",
-        "plugin/talon_draft_window/draft_window.talon",
-        "plugin/talon_draft_window/test_draft_ui.py",
     ],
     "trigger": "ready",
 }
diff --git a/src/talondoc/registry/__init__.py b/src/talondoc/registry/__init__.py
index 2e6aa82f..414c77c5 100644
--- a/src/talondoc/registry/__init__.py
+++ b/src/talondoc/registry/__init__.py
@@ -1,3 +1,4 @@
+import inspect
 from dataclasses import dataclass
 from functools import singledispatchmethod
 from typing import (
@@ -328,9 +329,28 @@ class Registry:
     ) -> Optional[Callable[..., Any]]:
         value = self.lookup_default(cls, name)
         if value and value.function_name:
-            value_function = self.lookup(talon.Function, value.function_name)
-            if value_function:
-                return value_function.function
+            function = self.lookup(talon.Function, value.function_name)
+            if function:
+
+                def _function_wrapper(*args, **kwargs):
+                    func_name = function.function.__name__
+                    func_type = inspect.signature(function.function)
+                    act_argc = len(args) + len(kwargs)
+                    exp_argc = len(func_type.parameters)
+                    if act_argc != exp_argc:
+                        act_argv = []
+                        act_argv.extend(map(str, args))
+                        act_argv.extend(f"{key}={val}" for key, val in kwargs.items())
+                        _LOGGER.warning(
+                            f"mismatch in number of parameters for {func_name}\n"
+                            f"expected: {func_type}\n"
+                            f"found: ({', '.join(act_argv)})"
+                        )
+                    return function.function(*args, **kwargs)
+
+                return _function_wrapper
+            else:
+                return None
         return None
 
     def resolve_name(
diff --git a/src/talondoc/registry/analyzer/python/shims.py b/src/talondoc/registry/analyzer/python/shims.py
index 23348c7f..959adac4 100644
--- a/src/talondoc/registry/analyzer/python/shims.py
+++ b/src/talondoc/registry/analyzer/python/shims.py
@@ -354,10 +354,8 @@ class TalonShim(ModuleShim):
                 self._registry.register(action)
 
         def action(self, name: str) -> Optional[Callable[..., Any]]:
-            return (
-                self._registry.lookup_default_function(talon.Action, name)
-                or ObjectShim()
-            )
+            function = self._registry.lookup_default_function(talon.Action, name)
+            return function or ObjectShim()
 
         def capture(
             self, rule: str
@@ -518,8 +516,38 @@ class TalonShim(ModuleShim):
 
             return __decorator
 
-        def action(self, name: str) -> Optional[Callable[..., Any]]:
-            return self._registry.lookup_default_function(talon.Action, name)
+        def action(
+            self, name: str
+        ) -> Optional[Callable[[Callable[..., Any]], Callable[..., Any]]]:
+            def __decorator(func: Callable[..., Any]):
+                # LINT: check if function on decorated class is a function
+                assert callable(
+                    func
+                ), f"@ctx.action({repr(name)}) decorates {repr(func)}"
+                namespace = name.split(".")[0]
+
+                location = talon.Location.from_function(func)
+                function = talon.Function(
+                    namespace=namespace,
+                    function=func,
+                    location=location,
+                    parent_name=self._context.name,
+                    parent_type=talon.Context,
+                )
+                self._registry.register(function)
+                action = talon.Action(
+                    # NOTE: function names on actions are fully qualified
+                    name=name,
+                    description=func.__doc__,
+                    location=location,
+                    parent_name=self._context.name,
+                    parent_type=talon.Context,
+                    function_name=function.name,
+                    function_type_hints=None,
+                )
+                self._registry.register(action)
+
+            return __decorator
 
         def capture(
             self, name: Optional[str] = None, rule: Optional[str] = None
diff --git a/src/talondoc/registry/entries/abc.py b/src/talondoc/registry/entries/abc.py
index 63808bef..421d26ab 100644
--- a/src/talondoc/registry/entries/abc.py
+++ b/src/talondoc/registry/entries/abc.py
@@ -82,9 +82,7 @@ class Location:
 
     @staticmethod
     def from_function(function: Callable[..., Any]) -> "Location":
-        assert inspect.isfunction(
-            function
-        ), f"Location.from_function received {repr(function)}"
+        assert callable(function), f"Location.from_function received {repr(function)}"
         path = Path(function.__code__.co_filename)
         start_position = Point(function.__code__.co_firstlineno, -1)
         return Location(path=path, start_position=start_position)
diff --git a/src/talondoc/sphinx/directives/command/abc.py b/src/talondoc/sphinx/directives/command/abc.py
index b1df3468..f1079b6b 100644
--- a/src/talondoc/sphinx/directives/command/abc.py
+++ b/src/talondoc/sphinx/directives/command/abc.py
@@ -57,9 +57,9 @@ class TalonDocCommandDescription(TalonDocObjectDescription):
     def get_commands(
         self,
         *,
-        context: Optional[Sequence[str]] = None,
+        restrict_to: Optional[Sequence[str]] = None,
     ) -> Iterator[talon.Command]:
-        yield from self.talon.registry.get_commands(context=context)
+        yield from self.talon.registry.get_commands(restrict_to=restrict_to)
 
     @final
     def find_commands(
@@ -217,7 +217,7 @@ class TalonDocCommandListDescription(TalonDocCommandDescription):
 
     @property
     def commands(self) -> Iterator[talon.Command]:
-        for command in self.get_commands(context=self.context):
+        for command in self.get_commands(restrict_to=self.contexts):
             if self._should_include(command.rule):
                 yield command
 
