diff --git a/src/main/java/graphql/GraphQL.java b/src/main/java/graphql/GraphQL.java
index 5b496172..2ccb54b9 100644
--- a/src/main/java/graphql/GraphQL.java
+++ b/src/main/java/graphql/GraphQL.java
@@ -1,6 +1,7 @@
 package graphql;
 
 import graphql.execution.AbortExecutionException;
+import graphql.execution.Async;
 import graphql.execution.AsyncExecutionStrategy;
 import graphql.execution.AsyncSerialExecutionStrategy;
 import graphql.execution.DataFetcherExceptionHandler;
@@ -421,31 +422,33 @@ public class GraphQL {
         if (logNotSafe.isDebugEnabled()) {
             logNotSafe.debug("Executing request. operation name: '{}'. query: '{}'. variables '{}'", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables());
         }
-        executionInput = ensureInputHasId(executionInput);
+        ExecutionInput executionInputWithId = ensureInputHasId(executionInput);
 
-        InstrumentationState instrumentationState = instrumentation.createState(new InstrumentationCreateStateParameters(this.graphQLSchema, executionInput));
-        try {
-            InstrumentationExecutionParameters inputInstrumentationParameters = new InstrumentationExecutionParameters(executionInput, this.graphQLSchema, instrumentationState);
-            executionInput = instrumentation.instrumentExecutionInput(executionInput, inputInstrumentationParameters, instrumentationState);
-
-            CompletableFuture<ExecutionResult> beginExecutionCF = new CompletableFuture<>();
-            InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, this.graphQLSchema, instrumentationState);
-            InstrumentationContext<ExecutionResult> executionInstrumentation = nonNullCtx(instrumentation.beginExecution(instrumentationParameters, instrumentationState));
-            executionInstrumentation.onDispatched(beginExecutionCF);
-
-            GraphQLSchema graphQLSchema = instrumentation.instrumentSchema(this.graphQLSchema, instrumentationParameters, instrumentationState);
-
-            CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, graphQLSchema, instrumentationState);
-            //
-            // finish up instrumentation
-            executionResult = executionResult.whenComplete(completeInstrumentationCtxCF(executionInstrumentation, beginExecutionCF));
-            //
-            // allow instrumentation to tweak the result
-            executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters, instrumentationState));
-            return executionResult;
-        } catch (AbortExecutionException abortException) {
-            return handleAbortException(executionInput, instrumentationState, abortException);
-        }
+        CompletableFuture<InstrumentationState> instrumentationStateCF = instrumentation.createStateAsync(new InstrumentationCreateStateParameters(this.graphQLSchema, executionInput));
+        return Async.orNullCompletedFuture(instrumentationStateCF).thenCompose(instrumentationState -> {
+            try {
+                InstrumentationExecutionParameters inputInstrumentationParameters = new InstrumentationExecutionParameters(executionInputWithId, this.graphQLSchema, instrumentationState);
+                ExecutionInput instrumentedExecutionInput = instrumentation.instrumentExecutionInput(executionInputWithId, inputInstrumentationParameters, instrumentationState);
+
+                CompletableFuture<ExecutionResult> beginExecutionCF = new CompletableFuture<>();
+                InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(instrumentedExecutionInput, this.graphQLSchema, instrumentationState);
+                InstrumentationContext<ExecutionResult> executionInstrumentation = nonNullCtx(instrumentation.beginExecution(instrumentationParameters, instrumentationState));
+                executionInstrumentation.onDispatched(beginExecutionCF);
+
+                GraphQLSchema graphQLSchema = instrumentation.instrumentSchema(this.graphQLSchema, instrumentationParameters, instrumentationState);
+
+                CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(instrumentedExecutionInput, graphQLSchema, instrumentationState);
+                //
+                // finish up instrumentation
+                executionResult = executionResult.whenComplete(completeInstrumentationCtxCF(executionInstrumentation, beginExecutionCF));
+                //
+                // allow instrumentation to tweak the result
+                executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters, instrumentationState));
+                return executionResult;
+            } catch (AbortExecutionException abortException) {
+                return handleAbortException(executionInput, instrumentationState, abortException);
+            }
+        });
     }
 
     private CompletableFuture<ExecutionResult> handleAbortException(ExecutionInput executionInput, InstrumentationState instrumentationState, AbortExecutionException abortException) {
diff --git a/src/main/java/graphql/execution/Async.java b/src/main/java/graphql/execution/Async.java
index ec71e2bd..56f7a2f9 100644
--- a/src/main/java/graphql/execution/Async.java
+++ b/src/main/java/graphql/execution/Async.java
@@ -2,6 +2,8 @@ package graphql.execution;
 
 import graphql.Assert;
 import graphql.Internal;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -207,4 +209,15 @@ public class Async {
         return result;
     }
 
+    /**
+     * If the passed in CompletableFuture is null then it creates a CompletableFuture that resolves to null
+     *
+     * @param completableFuture the CF to use
+     * @param <T>               for two
+     *
+     * @return the completableFuture if it's not null or one that always resoles to null
+     */
+    public static <T> @NotNull CompletableFuture<T> orNullCompletedFuture(@Nullable CompletableFuture<T> completableFuture) {
+        return completableFuture != null ? completableFuture : CompletableFuture.completedFuture(null);
+    }
 }
diff --git a/src/main/java/graphql/execution/instrumentation/ChainedInstrumentation.java b/src/main/java/graphql/execution/instrumentation/ChainedInstrumentation.java
index bfafc49e..70e7bd06 100644
--- a/src/main/java/graphql/execution/instrumentation/ChainedInstrumentation.java
+++ b/src/main/java/graphql/execution/instrumentation/ChainedInstrumentation.java
@@ -22,6 +22,7 @@ import graphql.schema.DataFetcher;
 import graphql.schema.GraphQLSchema;
 import graphql.validation.ValidationError;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.util.Arrays;
 import java.util.List;
@@ -80,10 +81,19 @@ public class ChainedInstrumentation implements Instrumentation {
         return new ChainedInstrumentationContext<>(mapAndDropNulls(instrumentations, mapper));
     }
 
+    @Override
+    public InstrumentationState createState() {
+        return Assert.assertShouldNeverHappen("createStateAsync should only ever be used");
+    }
+
+    @Override
+    public @Nullable InstrumentationState createState(InstrumentationCreateStateParameters parameters) {
+        return Assert.assertShouldNeverHappen("createStateAsync should only ever be used");
+    }
 
     @Override
-    public InstrumentationState createState(InstrumentationCreateStateParameters parameters) {
-        return new ChainedInstrumentationState(instrumentations, parameters);
+    public @NotNull CompletableFuture<InstrumentationState> createStateAsync(InstrumentationCreateStateParameters parameters) {
+        return ChainedInstrumentationState.combineAll(instrumentations, parameters);
     }
 
     @Override
@@ -349,18 +359,31 @@ public class ChainedInstrumentation implements Instrumentation {
     }
 
     static class ChainedInstrumentationState implements InstrumentationState {
-        private final Map<Instrumentation, InstrumentationState> instrumentationStates;
+        private final Map<Instrumentation, InstrumentationState> instrumentationToStates;
 
 
-        private ChainedInstrumentationState(List<Instrumentation> instrumentations, InstrumentationCreateStateParameters parameters) {
-            instrumentationStates = Maps.newLinkedHashMapWithExpectedSize(instrumentations.size());
-            instrumentations.forEach(i -> instrumentationStates.put(i, i.createState(parameters)));
+        private ChainedInstrumentationState(List<Instrumentation> instrumentations, List<InstrumentationState> instrumentationStates) {
+            instrumentationToStates = Maps.newLinkedHashMapWithExpectedSize(instrumentations.size());
+            for (int i = 0; i < instrumentations.size(); i++) {
+                Instrumentation instrumentation = instrumentations.get(i);
+                InstrumentationState instrumentationState = instrumentationStates.get(i);
+                instrumentationToStates.put(instrumentation, instrumentationState);
+            }
         }
 
         private InstrumentationState getState(Instrumentation instrumentation) {
-            return instrumentationStates.get(instrumentation);
+            return instrumentationToStates.get(instrumentation);
         }
 
+        private static CompletableFuture<InstrumentationState> combineAll(List<Instrumentation> instrumentations, InstrumentationCreateStateParameters parameters) {
+            Async.CombinedBuilder<InstrumentationState> builder = Async.ofExpectedSize(instrumentations.size());
+            for (Instrumentation instrumentation : instrumentations) {
+                // state can be null including the CF so handle that
+                CompletableFuture<InstrumentationState> stateCF = Async.orNullCompletedFuture(instrumentation.createStateAsync(parameters));
+                builder.add(stateCF);
+            }
+            return builder.await().thenApply(instrumentationStates -> new ChainedInstrumentationState(instrumentations, instrumentationStates));
+        }
     }
 
     private static class ChainedInstrumentationContext<T> implements InstrumentationContext<T> {
diff --git a/src/main/java/graphql/execution/instrumentation/Instrumentation.java b/src/main/java/graphql/execution/instrumentation/Instrumentation.java
index 989364c4..77c4c6bd 100644
--- a/src/main/java/graphql/execution/instrumentation/Instrumentation.java
+++ b/src/main/java/graphql/execution/instrumentation/Instrumentation.java
@@ -63,11 +63,26 @@ public interface Instrumentation {
      *
      * @return a state object that is passed to each method
      */
+    @Deprecated
+    @DeprecatedAt("2023-08-25")
     @Nullable
     default InstrumentationState createState(InstrumentationCreateStateParameters parameters) {
         return createState();
     }
 
+    /**
+     * This will be called just before execution to create an object, in an asynchronous manner, that is given back to all instrumentation methods
+     * to allow them to have per execution request state
+     *
+     * @param parameters the parameters to this step
+     *
+     * @return a state object that is passed to each method
+     */
+    @Nullable
+    default CompletableFuture<InstrumentationState> createStateAsync(InstrumentationCreateStateParameters parameters) {
+        return CompletableFuture.completedFuture(createState(parameters));
+    }
+
     /**
      * This is called right at the start of query execution, and it's the first step in the instrumentation chain.
      *
diff --git a/src/main/java/graphql/execution/instrumentation/SimplePerformantInstrumentation.java b/src/main/java/graphql/execution/instrumentation/SimplePerformantInstrumentation.java
index b7835ffd..8ad5f8ee 100644
--- a/src/main/java/graphql/execution/instrumentation/SimplePerformantInstrumentation.java
+++ b/src/main/java/graphql/execution/instrumentation/SimplePerformantInstrumentation.java
@@ -56,6 +56,12 @@ public class SimplePerformantInstrumentation implements Instrumentation {
         return null;
     }
 
+    @Override
+    public @Nullable CompletableFuture<InstrumentationState> createStateAsync(InstrumentationCreateStateParameters parameters) {
+        InstrumentationState state = createState(parameters);
+        return state == null ? null : CompletableFuture.completedFuture(state);
+    }
+
     @Override
     public @NotNull InstrumentationContext<ExecutionResult> beginExecution(InstrumentationExecutionParameters parameters) {
         return assertShouldNeverHappen("The deprecated " + "beginExecution" + " was called");
diff --git a/src/main/java/graphql/schema/diffing/DiffImpl.java b/src/main/java/graphql/schema/diffing/DiffImpl.java
index 9cfd39b9..efff71cd 100644
--- a/src/main/java/graphql/schema/diffing/DiffImpl.java
+++ b/src/main/java/graphql/schema/diffing/DiffImpl.java
@@ -400,19 +400,21 @@ public class DiffImpl {
                                              Map<Vertex, Double> isolatedVerticesCache,
                                              Map<Vertex, Vertex> nonFixedParentRestrictions) {
         if (nonFixedParentRestrictions.containsKey(v) || partialMapping.hasParentRestriction(v)) {
-            Vertex uParentRestriction = nonFixedParentRestrictions.get(v);
-            if (uParentRestriction == null) {
-                uParentRestriction = partialMapping.getParentRestriction(v);
-            }
+            if (!u.isIsolated()) { // Always allow mapping to isolated nodes
+                Vertex uParentRestriction = nonFixedParentRestrictions.get(v);
+                if (uParentRestriction == null) {
+                    uParentRestriction = partialMapping.getParentRestriction(v);
+                }
 
-            Collection<Edge> parentEdges = completeTargetGraph.getAdjacentEdgesInverseNonCopy(u);
-            if (parentEdges.size() != 1) {
-                return Integer.MAX_VALUE;
-            }
+                Collection<Edge> parentEdges = completeTargetGraph.getAdjacentEdgesInverseNonCopy(u);
+                if (parentEdges.size() != 1) {
+                    return Integer.MAX_VALUE;
+                }
 
-            Vertex uParent = parentEdges.iterator().next().getFrom();
-            if (uParent != uParentRestriction) {
-                return Integer.MAX_VALUE;
+                Vertex uParent = parentEdges.iterator().next().getFrom();
+                if (uParent != uParentRestriction) {
+                    return Integer.MAX_VALUE;
+                }
             }
         }
 
diff --git a/src/test/groovy/graphql/execution/instrumentation/ChainedInstrumentationStateTest.groovy b/src/test/groovy/graphql/execution/instrumentation/ChainedInstrumentationStateTest.groovy
index c2c1ffb8..f1812e39 100644
--- a/src/test/groovy/graphql/execution/instrumentation/ChainedInstrumentationStateTest.groovy
+++ b/src/test/groovy/graphql/execution/instrumentation/ChainedInstrumentationStateTest.groovy
@@ -1,17 +1,13 @@
 package graphql.execution.instrumentation
 
+import graphql.ExecutionInput
 import graphql.ExecutionResult
 import graphql.GraphQL
 import graphql.StarWarsSchema
 import graphql.execution.AsyncExecutionStrategy
-import graphql.execution.instrumentation.parameters.InstrumentationExecuteOperationParameters
+import graphql.execution.instrumentation.parameters.InstrumentationCreateStateParameters
 import graphql.execution.instrumentation.parameters.InstrumentationExecutionParameters
-import graphql.execution.instrumentation.parameters.InstrumentationExecutionStrategyParameters
-import graphql.execution.instrumentation.parameters.InstrumentationFieldFetchParameters
-import graphql.execution.instrumentation.parameters.InstrumentationFieldParameters
 import graphql.execution.instrumentation.parameters.InstrumentationValidationParameters
-import graphql.language.Document
-import graphql.schema.DataFetcher
 import graphql.validation.ValidationError
 import spock.lang.Specification
 
@@ -279,6 +275,75 @@ class ChainedInstrumentationStateTest extends Specification {
 
     }
 
+
+    class StringInstrumentationState implements InstrumentationState {
+        StringInstrumentationState(String value) {
+            this.value = value
+        }
+
+        String value
+    }
+
+    def "can have an multiple async createState() calls in play"() {
+
+
+        given:
+
+        def query = '''query Q($var: String!) {
+                                  human(id: $var) {
+                                    id
+                                    name
+                                  }
+                                }
+                            '''
+
+
+        def instrumentation1 = new SimplePerformantInstrumentation() {
+            @Override
+            CompletableFuture<InstrumentationState> createStateAsync(InstrumentationCreateStateParameters parameters) {
+                return CompletableFuture.supplyAsync {
+                    return new StringInstrumentationState("I1")
+                } as CompletableFuture<InstrumentationState>
+            }
+
+            @Override
+            CompletableFuture<ExecutionResult> instrumentExecutionResult(ExecutionResult executionResult, InstrumentationExecutionParameters parameters, InstrumentationState state) {
+                return CompletableFuture.completedFuture(
+                        executionResult.transform { it.addExtension("i1", ((StringInstrumentationState) state).value) }
+                )
+            }
+        }
+        def instrumentation2 = new SimplePerformantInstrumentation() {
+            @Override
+            CompletableFuture<InstrumentationState> createStateAsync(InstrumentationCreateStateParameters parameters) {
+                return CompletableFuture.supplyAsync {
+                    return new StringInstrumentationState("I2")
+                } as CompletableFuture<InstrumentationState>
+            }
+
+            @Override
+            CompletableFuture<ExecutionResult> instrumentExecutionResult(ExecutionResult executionResult, InstrumentationExecutionParameters parameters, InstrumentationState state) {
+                return CompletableFuture.completedFuture(
+                        executionResult.transform { it.addExtension("i2", ((StringInstrumentationState) state).value) }
+                )
+            }
+
+        }
+
+        def graphQL = GraphQL
+                .newGraphQL(StarWarsSchema.starWarsSchema)
+                .instrumentation(new ChainedInstrumentation([instrumentation1, instrumentation2]))
+                .doNotAddDefaultInstrumentations() // important, otherwise a chained one wil be used
+                .build()
+
+        when:
+        def variables = [var: "1001"]
+        def er = graphQL.execute(ExecutionInput.newExecutionInput().query(query).variables(variables)) // Luke
+
+        then:
+        er.extensions == [i1: "I1", i2: "I2"]
+    }
+
     private void assertCalls(NamedInstrumentation instrumentation) {
         assert instrumentation.dfInvocations[0].getFieldDefinition().name == 'hero'
         assert instrumentation.dfInvocations[0].getExecutionStepInfo().getPath().toList() == ['hero']
diff --git a/src/test/groovy/graphql/execution/instrumentation/InstrumentationTest.groovy b/src/test/groovy/graphql/execution/instrumentation/InstrumentationTest.groovy
index 694e100c..85b27408 100644
--- a/src/test/groovy/graphql/execution/instrumentation/InstrumentationTest.groovy
+++ b/src/test/groovy/graphql/execution/instrumentation/InstrumentationTest.groovy
@@ -5,6 +5,7 @@ import graphql.ExecutionResult
 import graphql.GraphQL
 import graphql.StarWarsSchema
 import graphql.execution.AsyncExecutionStrategy
+import graphql.execution.instrumentation.parameters.InstrumentationCreateStateParameters
 import graphql.execution.instrumentation.parameters.InstrumentationExecutionParameters
 import graphql.execution.instrumentation.parameters.InstrumentationExecutionStrategyParameters
 import graphql.execution.instrumentation.parameters.InstrumentationFieldFetchParameters
@@ -404,4 +405,56 @@ class InstrumentationTest extends Specification {
 
         instrumentation.executionList == expected
     }
+
+    class StringInstrumentationState implements InstrumentationState {
+        StringInstrumentationState(String value) {
+            this.value = value
+        }
+
+        String value
+    }
+
+    def "can have an single async createState() in play"() {
+
+
+        given:
+
+        def query = '''query Q($var: String!) {
+                                  human(id: $var) {
+                                    id
+                                    name
+                                  }
+                                }
+                            '''
+
+
+        def instrumentation1 = new SimplePerformantInstrumentation() {
+            @Override
+            CompletableFuture<InstrumentationState> createStateAsync(InstrumentationCreateStateParameters parameters) {
+                return CompletableFuture.supplyAsync {
+                    return new StringInstrumentationState("I1")
+                } as CompletableFuture<InstrumentationState>
+            }
+
+            @Override
+            CompletableFuture<ExecutionResult> instrumentExecutionResult(ExecutionResult executionResult, InstrumentationExecutionParameters parameters, InstrumentationState state) {
+                return CompletableFuture.completedFuture(
+                        executionResult.transform { it.addExtension("i1", ((StringInstrumentationState) state).value) }
+                )
+            }
+        }
+
+        def graphQL = GraphQL
+                .newGraphQL(StarWarsSchema.starWarsSchema)
+                .instrumentation(instrumentation1)
+                .doNotAddDefaultInstrumentations() // important, otherwise a chained one wil be used
+                .build()
+
+        when:
+        def variables = [var: "1001"]
+        def er = graphQL.execute(ExecutionInput.newExecutionInput().query(query).variables(variables)) // Luke
+
+        then:
+        er.extensions == [i1: "I1"]
+    }
 }
diff --git a/src/test/groovy/graphql/schema/diffing/ana/EditOperationAnalyzerTest.groovy b/src/test/groovy/graphql/schema/diffing/ana/EditOperationAnalyzerTest.groovy
index ebc9463e..2ab7bbd7 100644
--- a/src/test/groovy/graphql/schema/diffing/ana/EditOperationAnalyzerTest.groovy
+++ b/src/test/groovy/graphql/schema/diffing/ana/EditOperationAnalyzerTest.groovy
@@ -3044,6 +3044,111 @@ class EditOperationAnalyzerTest extends Specification {
         userModification.details.isEmpty()
     }
 
+    def "deleted field with fixed parent binding can map to isolated node"() {
+        given:
+        def oldSdl = '''
+            type Query {
+                notifications: NotificationQuery
+            }
+            type NotificationQuery {
+                notificationFeed(
+                    feedFilter: NotificationFeedFilter
+                    first: Int = 25
+                    after: String
+                ): NotificationGroupedConnection!
+                unseenNotificationCount(workspaceId: String, product: String): Int!
+            }
+            input NotificationFeedFilter {
+                workspaceId: String
+                productFilter: String
+                groupId: String
+            }
+            type NotificationItem {
+                notificationId: ID!
+                workspaceId: String
+            }
+            type NotificationGroupedItem {
+                groupId: ID!
+                groupSize: Int!
+                headNotification: NotificationItem!
+                childItems(first: Int, after: String): [NotificationItem!]
+            }
+            type NotificationGroupedConnection {
+                nodes: [NotificationGroupedItem!]!
+            }
+        '''
+        def newSdl = '''
+            type Query {
+                notifications: NotificationQuery
+            }
+            type NotificationQuery {
+                notificationFeed(
+                    filter: NotificationFilter
+                    first: Int = 25
+                    after: String
+                ): NotificationFeedConnection!
+                notificationGroup(
+                    groupId: String!
+                    filter: NotificationFilter
+                    first: Int = 25
+                    after: String
+                ): NotificationGroupConnection!
+                unseenNotificationCount(workspaceId: String, product: String): Int!
+            }
+            input NotificationFilter {
+                workspaceId: String
+                productFilter: String
+            }
+            type NotificationEntityModel{
+                objectId: String!
+                containerId: String
+                workspaceId: String
+                cloudId: String
+            }
+            type NotificationItem {
+                notificationId: ID!
+                entityModel: NotificationEntityModel
+                workspaceId: String
+            }
+            type NotificationHeadItem {
+                groupId: ID!
+                groupSize: Int!
+                readStates: [String]!
+                additionalTypes: [String!]!
+                headNotification: NotificationItem!
+                endCursor: String
+            }
+            type NotificationFeedConnection {
+                nodes: [NotificationHeadItem!]!
+            }
+            type NotificationGroupConnection {
+                nodes: [NotificationItem!]!
+            }
+        '''
+
+        when:
+        def changes = calcDiff(oldSdl, newSdl)
+
+        then:
+        changes.objectDifferences["NotificationGroupedItem"] === changes.objectDifferences["NotificationHeadItem"]
+        changes.objectDifferences["NotificationGroupedConnection"] === changes.objectDifferences["NotificationFeedConnection"]
+        changes.objectDifferences["NotificationGroupedItem"] instanceof ObjectModification
+        changes.objectDifferences["NotificationGroupedConnection"] instanceof ObjectModification
+        changes.objectDifferences["NotificationEntityModel"] instanceof ObjectAddition
+        changes.objectDifferences["NotificationGroupConnection"] instanceof ObjectAddition
+        changes.objectDifferences["NotificationItem"] instanceof ObjectModification
+        changes.objectDifferences["NotificationQuery"] instanceof ObjectModification
+
+        changes.inputObjectDifferences["NotificationFeedFilter"] === changes.inputObjectDifferences["NotificationFilter"]
+        changes.inputObjectDifferences["NotificationFeedFilter"] instanceof InputObjectModification
+
+        def notificationFeedFilterChange = changes.inputObjectDifferences["NotificationFeedFilter"] as InputObjectModification
+        notificationFeedFilterChange.details.size() == 1
+        notificationFeedFilterChange.details[0] instanceof InputObjectFieldDeletion
+        def groupIdInputObjectFieldDeletion = notificationFeedFilterChange.details[0] as InputObjectFieldDeletion
+        groupIdInputObjectFieldDeletion.name == "groupId"
+    }
+
     EditOperationAnalysisResult calcDiff(
             String oldSdl,
             String newSdl
diff --git a/src/test/groovy/graphql/schema/idl/SchemaParserTest.groovy b/src/test/groovy/graphql/schema/idl/SchemaParserTest.groovy
index 24d9af71..762cce71 100644
--- a/src/test/groovy/graphql/schema/idl/SchemaParserTest.groovy
+++ b/src/test/groovy/graphql/schema/idl/SchemaParserTest.groovy
@@ -480,4 +480,14 @@ type Virus {
         def printedSchema = new SchemaPrinter(options).print(graphQL.graphQLSchema)
         printedSchema == schema
     }
+
+    def "testNumberFormatException"() {
+        when:
+        SchemaParser parser = new SchemaParser();
+        parser.parse("{B(t:66E3333333320,t:#\n66666666660)},622»» »»»6666662}}6666660t:z6666")
+
+        then:
+        thrown(SchemaProblem)
+    }
+
 }
diff --git a/src/test/java/graphql/schema/idl/SchemaParserTest.java b/src/test/java/graphql/schema/idl/SchemaParserTest.java
deleted file mode 100644
index 304fd0c4..00000000
--- a/src/test/java/graphql/schema/idl/SchemaParserTest.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package graphql.schema.idl;
-
-import org.testng.annotations.Test;
-import graphql.GraphQLException;
-
-public class SchemaParserTest {
-
-    @Test
-    public void testNumberFormatException() {
-      String[] malformedStrings = {
-        "{B(t:66E3333333320,t:#\n66666666660)},622»» »»»6666662}}6666660t:z6666"
-      };
-
-      for (String malformed : malformedStrings) {
-        try {
-          SchemaParser parser = new SchemaParser();
-          parser.parse(malformed);
-        } catch (GraphQLException e) {
-          // Known exception
-        }
-      }
-    }
-}
