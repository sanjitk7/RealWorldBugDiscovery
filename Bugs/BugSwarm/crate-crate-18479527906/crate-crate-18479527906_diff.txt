diff --git a/docs/appendices/release-notes/4.8.0.rst b/docs/appendices/release-notes/4.8.0.rst
index 9e707c25f6..7b5ad54dd9 100644
--- a/docs/appendices/release-notes/4.8.0.rst
+++ b/docs/appendices/release-notes/4.8.0.rst
@@ -49,8 +49,7 @@ SQL Statements and Compatibility
 - Implemented cancelling requests section of PostgreSQL wire protocol.
 
 - Added a ``WITH`` clause parameter, ``validation`` to ``COPY FROM`` which
-  can enable or disable the newly added type validation feature. Please see
-  :ref:`validation <sql-copy-from-validation>` for more details.
+  can enable or disable the newly added type validation feature.
 
 - Added type validation logic to ``COPY FROM``. Now raw data will be parsed and
   validated against the target table schema and casted if possible utilizing
diff --git a/docs/appendices/release-notes/5.4.6.rst b/docs/appendices/release-notes/5.4.6.rst
index 76220e3dfe..b3d8ca689f 100644
--- a/docs/appendices/release-notes/5.4.6.rst
+++ b/docs/appendices/release-notes/5.4.6.rst
@@ -46,4 +46,6 @@ See the :ref:`version_5.4.0` release notes for a full list of changes in the
 Fixes
 =====
 
-None
+- Fixed an issue that caused queries with a ``NOT`` or ``!=`` on a ``CASE``
+  expression containing a nullable column to exclude ``NULL`` entries.
+
diff --git a/docs/appendices/release-notes/5.5.1.rst b/docs/appendices/release-notes/5.5.1.rst
index 13aa86fcc1..14412d78b8 100644
--- a/docs/appendices/release-notes/5.5.1.rst
+++ b/docs/appendices/release-notes/5.5.1.rst
@@ -49,6 +49,9 @@ See the :ref:`version_5.5.0` release notes for a full list of changes in the
 Fixes
 =====
 
+- Fixed an issue that caused queries with a ``NOT`` or ``!=`` on a ``CASE``
+  expression containing a nullable column to exclude ``NULL`` entries.
+
 - Re-added ``jcmd`` to the bundled JDK distribution.
 
 - Return meaningful error when trying to drop a column which itself or its
diff --git a/docs/config/session.rst b/docs/config/session.rst
index e2dad2ce9d..fd56207ee8 100644
--- a/docs/config/session.rst
+++ b/docs/config/session.rst
@@ -226,7 +226,7 @@ releases.
 
 .. vale on
 
-.... _experimental-warning:
+.. _experimental-warning:
 
 .. WARNING::
 
diff --git a/libs/sql-parser/src/main/antlr/io/crate/sql/parser/antlr/SqlBaseParser.g4 b/libs/sql-parser/src/main/antlr/io/crate/sql/parser/antlr/SqlBaseParser.g4
index 93d63a1c92..2942b8088e 100644
--- a/libs/sql-parser/src/main/antlr/io/crate/sql/parser/antlr/SqlBaseParser.g4
+++ b/libs/sql-parser/src/main/antlr/io/crate/sql/parser/antlr/SqlBaseParser.g4
@@ -106,7 +106,7 @@ dropStmt
     | DROP FUNCTION (IF EXISTS)? name=qname
         OPEN_ROUND_BRACKET (functionArgument (COMMA functionArgument)*)?
         CLOSE_ROUND_BRACKET                                                          #dropFunction
-    | DROP USER (IF EXISTS)? name=ident                                              #dropUser
+    | DROP (USER | ROLE) (IF EXISTS)? name=ident                                     #dropRole
     | DROP VIEW (IF EXISTS)? names=qnames                                            #dropView
     | DROP ANALYZER name=ident                                                       #dropAnalyzer
     | DROP PUBLICATION (IF EXISTS)? name=ident                                       #dropPublication
@@ -132,8 +132,8 @@ alterStmt
     | ALTER CLUSTER SWAP TABLE source=qname TO target=qname withProperties?          #alterClusterSwapTable
     | ALTER CLUSTER DECOMMISSION node=expr                                           #alterClusterDecommissionNode
     | ALTER CLUSTER GC DANGLING ARTIFACTS                                            #alterClusterGCDanglingArtifacts
-    | ALTER USER name=ident
-        SET OPEN_ROUND_BRACKET genericProperties CLOSE_ROUND_BRACKET                 #alterUser
+    | ALTER (USER | ROLE) name=ident
+        SET OPEN_ROUND_BRACKET genericProperties CLOSE_ROUND_BRACKET                 #alterRole
     | ALTER PUBLICATION name=ident
         ((ADD | SET | DROP) TABLE qname ASTERISK?  (COMMA qname ASTERISK? )*)        #alterPublication
     | ALTER SUBSCRIPTION name=ident alterSubscriptionMode                            #alterSubscription
diff --git a/libs/sql-parser/src/main/java/io/crate/sql/SqlFormatter.java b/libs/sql-parser/src/main/java/io/crate/sql/SqlFormatter.java
index a3a101011f..d1eb2d83ed 100644
--- a/libs/sql-parser/src/main/java/io/crate/sql/SqlFormatter.java
+++ b/libs/sql-parser/src/main/java/io/crate/sql/SqlFormatter.java
@@ -42,6 +42,7 @@ import io.crate.common.collections.Lists2;
 import io.crate.sql.tree.AliasedRelation;
 import io.crate.sql.tree.AllColumns;
 import io.crate.sql.tree.AlterPublication;
+import io.crate.sql.tree.AlterRole;
 import io.crate.sql.tree.AlterSubscription;
 import io.crate.sql.tree.Assignment;
 import io.crate.sql.tree.AstVisitor;
@@ -73,7 +74,7 @@ import io.crate.sql.tree.DropRepository;
 import io.crate.sql.tree.DropSnapshot;
 import io.crate.sql.tree.DropSubscription;
 import io.crate.sql.tree.DropTable;
-import io.crate.sql.tree.DropUser;
+import io.crate.sql.tree.DropRole;
 import io.crate.sql.tree.DropView;
 import io.crate.sql.tree.EscapedCharStringLiteral;
 import io.crate.sql.tree.Explain;
@@ -687,8 +688,20 @@ public final class SqlFormatter {
         }
 
         @Override
-        public Void visitDropUser(DropUser node, Integer indent) {
-            builder.append("DROP USER ");
+        public Void visitAlterRole(AlterRole<?> node, Integer indent) {
+            builder.append("ALTER ROLE ");
+            builder.append(quoteIdentifierIfNeeded(node.name()));
+            if (node.properties().properties().isEmpty() == false) {
+                builder.append("SET (");
+                appendProperties(node.properties().properties(), 0);
+                builder.append(")");
+            }
+            return null;
+        }
+
+        @Override
+        public Void visitDropRole(DropRole node, Integer indent) {
+            builder.append("DROP ROLE ");
             if (node.ifExists()) {
                 builder.append("IF EXISTS ");
             }
@@ -720,23 +733,9 @@ public final class SqlFormatter {
 
         @Override
         public Void visitGenericProperties(GenericProperties<?> node, Integer indent) {
-            int count = 0;
-            int max = node.properties().size();
-            if (max > 0) {
+            if (node.properties().isEmpty() == false) {
                 builder.append("WITH (\n");
-                @SuppressWarnings({"unchecked", "rawtypes"})
-                TreeMap<String, Expression> sortedMap = new TreeMap(node.properties());
-                for (Map.Entry<String, Expression> propertyEntry : sortedMap.entrySet()) {
-                    builder.append(indentString(indent + 1));
-                    String key = propertyEntry.getKey();
-                    if (propertyEntry.getKey().contains(".")) {
-                        key = String.format(Locale.ENGLISH, "\"%s\"", key);
-                    }
-                    builder.append(key).append(" = ");
-                    propertyEntry.getValue().accept(this, indent);
-                    if (++count < max) builder.append(",");
-                    builder.append("\n");
-                }
+                appendProperties(node.properties(), indent);
                 append(indent, ")");
             }
             return null;
@@ -1341,6 +1340,23 @@ public final class SqlFormatter {
             return null;
         }
 
+        @SuppressWarnings({"unchecked", "rawtypes"})
+        private void appendProperties(Map<String, ?> properties, Integer indent) {
+            int count = 0;
+            TreeMap<String, Expression> sortedMap = new TreeMap(properties);
+            for (Map.Entry<String, Expression> propertyEntry : sortedMap.entrySet()) {
+                builder.append(indentString(indent + 1));
+                String key = propertyEntry.getKey();
+                if (propertyEntry.getKey().contains(".")) {
+                    key = String.format(Locale.ENGLISH, "\"%s\"", key);
+                }
+                builder.append(key).append(" = ");
+                propertyEntry.getValue().accept(this, indent);
+                if (++count < properties.size()) builder.append(",");
+                builder.append("\n");
+            }
+        }
+
         private void appendPrivilegesList(List<String> privilegeTypes) {
             int j = 0;
             for (String privilegeType : privilegeTypes) {
diff --git a/libs/sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java b/libs/sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java
index 2cbb2cd9e0..064bb203c2 100644
--- a/libs/sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java
+++ b/libs/sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java
@@ -73,7 +73,7 @@ import io.crate.sql.tree.AlterTableDropColumn;
 import io.crate.sql.tree.AlterTableOpenClose;
 import io.crate.sql.tree.AlterTableRename;
 import io.crate.sql.tree.AlterTableReroute;
-import io.crate.sql.tree.AlterUser;
+import io.crate.sql.tree.AlterRole;
 import io.crate.sql.tree.AnalyzeStatement;
 import io.crate.sql.tree.AnalyzerElement;
 import io.crate.sql.tree.ArithmeticExpression;
@@ -136,7 +136,7 @@ import io.crate.sql.tree.DropRepository;
 import io.crate.sql.tree.DropSnapshot;
 import io.crate.sql.tree.DropSubscription;
 import io.crate.sql.tree.DropTable;
-import io.crate.sql.tree.DropUser;
+import io.crate.sql.tree.DropRole;
 import io.crate.sql.tree.DropView;
 import io.crate.sql.tree.EscapedCharStringLiteral;
 import io.crate.sql.tree.Except;
@@ -560,8 +560,8 @@ class AstBuilder extends SqlBaseParserBaseVisitor<Node> {
     }
 
     @Override
-    public Node visitDropUser(SqlBaseParser.DropUserContext context) {
-        return new DropUser(
+    public Node visitDropRole(SqlBaseParser.DropRoleContext context) {
+        return new DropRole(
             getIdentText(context.name),
             context.EXISTS() != null
         );
@@ -1359,7 +1359,6 @@ class AstBuilder extends SqlBaseParserBaseVisitor<Node> {
         );
     }
 
-    @SuppressWarnings({"rawtypes", "unchecked"})
     @Override
     public Node visitAlterTableReroute(SqlBaseParser.AlterTableRerouteContext context) {
         return new AlterTableReroute<>(
@@ -1374,8 +1373,8 @@ class AstBuilder extends SqlBaseParserBaseVisitor<Node> {
     }
 
     @Override
-    public Node visitAlterUser(SqlBaseParser.AlterUserContext context) {
-        return new AlterUser<>(
+    public Node visitAlterRole(SqlBaseParser.AlterRoleContext context) {
+        return new AlterRole<>(
             getIdentText(context.name),
             extractGenericProperties(context.genericProperties())
         );
diff --git a/libs/sql-parser/src/main/java/io/crate/sql/tree/AlterRole.java b/libs/sql-parser/src/main/java/io/crate/sql/tree/AlterRole.java
new file mode 100644
index 0000000000..a41890186b
--- /dev/null
+++ b/libs/sql-parser/src/main/java/io/crate/sql/tree/AlterRole.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed to Crate.io GmbH ("Crate") under one or more contributor
+ * license agreements.  See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.  Crate licenses
+ * this file to you under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ * However, if you have executed another commercial license agreement
+ * with Crate these terms will supersede the license and you may use the
+ * software solely pursuant to the terms of the relevant commercial agreement.
+ */
+
+package io.crate.sql.tree;
+
+import java.util.Objects;
+import java.util.function.Function;
+
+public class AlterRole<T> extends Statement {
+
+    private final GenericProperties<T> properties;
+    private final String name;
+
+    public AlterRole(String name, GenericProperties<T> properties) {
+        this.properties = properties;
+        this.name = name;
+    }
+
+    public GenericProperties<T> properties() {
+        return properties;
+    }
+
+    public String name() {
+        return name;
+    }
+
+    public <U> AlterRole<U> map(Function<? super T, ? extends U> mapper) {
+        return new AlterRole<>(name, properties.map(mapper));
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        AlterRole<?> alterRole = (AlterRole<?>) o;
+        return Objects.equals(properties, alterRole.properties) &&
+               Objects.equals(name, alterRole.name);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(properties, name);
+    }
+
+    @Override
+    public String toString() {
+        return "AlterRole{" +
+               "properties=" + properties +
+               ", name='" + name + '\'' +
+               '}';
+    }
+
+    @Override
+    public <R, C> R accept(AstVisitor<R, C> visitor, C context) {
+        return visitor.visitAlterRole(this, context);
+    }
+}
diff --git a/libs/sql-parser/src/main/java/io/crate/sql/tree/AstVisitor.java b/libs/sql-parser/src/main/java/io/crate/sql/tree/AstVisitor.java
index 63a460f5b9..3fcba0db0a 100644
--- a/libs/sql-parser/src/main/java/io/crate/sql/tree/AstVisitor.java
+++ b/libs/sql-parser/src/main/java/io/crate/sql/tree/AstVisitor.java
@@ -304,7 +304,7 @@ public abstract class AstVisitor<R, C> {
         return visitStatement(node, context);
     }
 
-    public R visitDropUser(DropUser node, C context) {
+    public R visitDropRole(DropRole node, C context) {
         return visitStatement(node, context);
     }
 
@@ -355,11 +355,11 @@ public abstract class AstVisitor<R, C> {
     public R visitNotNullColumnConstraint(NotNullColumnConstraint<?> node, C context) {
         return visitNode(node, context);
     }
-    
+
     public R visitNullColumnConstraint(NullColumnConstraint<?> node, C context) {
         return visitNode(node, context);
     }
-    
+
     public R visitIndexColumnConstraint(IndexColumnConstraint<?> node, C context) {
         return visitNode(node, context);
     }
@@ -464,7 +464,7 @@ public abstract class AstVisitor<R, C> {
         return visitStatement(node, context);
     }
 
-    public R visitAlterUser(AlterUser<?> node, C context) {
+    public R visitAlterRole(AlterRole<?> node, C context) {
         return visitStatement(node, context);
     }
 
diff --git a/libs/sql-parser/src/main/java/io/crate/sql/tree/DropRole.java b/libs/sql-parser/src/main/java/io/crate/sql/tree/DropRole.java
new file mode 100644
index 0000000000..f2876932a5
--- /dev/null
+++ b/libs/sql-parser/src/main/java/io/crate/sql/tree/DropRole.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed to Crate.io GmbH ("Crate") under one or more contributor
+ * license agreements.  See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.  Crate licenses
+ * this file to you under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ * However, if you have executed another commercial license agreement
+ * with Crate these terms will supersede the license and you may use the
+ * software solely pursuant to the terms of the relevant commercial agreement.
+ */
+
+package io.crate.sql.tree;
+
+import java.util.Objects;
+
+public class DropRole extends Statement {
+
+    private final String name;
+    private final boolean ifExists;
+
+    public DropRole(String name, boolean ifExists) {
+        this.name = name;
+        this.ifExists = ifExists;
+    }
+
+    public String name() {
+        return name;
+    }
+
+    public boolean ifExists() {
+        return ifExists;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        DropRole dropRole = (DropRole) o;
+        return ifExists == dropRole.ifExists &&
+               Objects.equals(name, dropRole.name);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(name, ifExists);
+    }
+
+    @Override
+    public String toString() {
+        return "DropRole{" +
+               "name='" + name + '\'' +
+               ", ifExists=" + ifExists +
+               '}';
+    }
+
+    @Override
+    public <R, C> R accept(AstVisitor<R, C> visitor, C context) {
+        return visitor.visitDropRole(this, context);
+    }
+}
diff --git a/libs/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java b/libs/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java
index 37a79459aa..11e8072b2b 100644
--- a/libs/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java
+++ b/libs/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java
@@ -37,6 +37,7 @@ import org.junit.Test;
 import io.crate.sql.Literals;
 import io.crate.sql.SqlFormatter;
 import io.crate.sql.tree.AlterPublication;
+import io.crate.sql.tree.AlterRole;
 import io.crate.sql.tree.AlterSubscription;
 import io.crate.sql.tree.ArrayComparisonExpression;
 import io.crate.sql.tree.ArrayLikePredicate;
@@ -62,10 +63,10 @@ import io.crate.sql.tree.DropBlobTable;
 import io.crate.sql.tree.DropFunction;
 import io.crate.sql.tree.DropPublication;
 import io.crate.sql.tree.DropRepository;
+import io.crate.sql.tree.DropRole;
 import io.crate.sql.tree.DropSnapshot;
 import io.crate.sql.tree.DropSubscription;
 import io.crate.sql.tree.DropTable;
-import io.crate.sql.tree.DropUser;
 import io.crate.sql.tree.DropView;
 import io.crate.sql.tree.EscapedCharStringLiteral;
 import io.crate.sql.tree.Explain;
@@ -857,6 +858,13 @@ public class TestStatementBuilder {
         printStatement("drop user if exists root");
     }
 
+    @Test
+    public void testDropRoleStmtBuilder() {
+        printStatement("drop role \"Günter\"");
+        printStatement("drop role root");
+        printStatement("drop role if exists root");
+    }
+
     @Test
     public void testGrantPrivilegeStmtBuilder() {
         printStatement("grant DML To \"Günter\"");
@@ -1804,7 +1812,13 @@ public class TestStatementBuilder {
     @Test
     public void testAlterUser() {
         printStatement("alter user crate set (password = 'password')");
-        printStatement("alter user crate set (password = null)");
+        printStatement("alter user crate set (password = null, session_setting='foo')");
+    }
+
+    @Test
+    public void testAlterRole() {
+        printStatement("alter role r1 set (password = 'password')");
+        printStatement("alter role r1 set (password = null, session_setting='foo')");
     }
 
     @Test
@@ -1815,6 +1829,14 @@ public class TestStatementBuilder {
             .hasMessage("line 1:17: mismatched input '<EOF>' expecting 'SET'");
     }
 
+    @Test
+    public void testAlterRoleWithMissingProperties() {
+        assertThatThrownBy(
+            () -> printStatement("alter role r1"))
+            .isExactlyInstanceOf(ParsingException.class)
+            .hasMessage("line 1:14: mismatched input '<EOF>' expecting 'SET'");
+    }
+
     @Test
     public void testSubSelects() {
         printStatement("select * from (select * from foo) as f");
@@ -2037,7 +2059,8 @@ public class TestStatementBuilder {
             statement instanceof GrantPrivilege ||
             statement instanceof DenyPrivilege ||
             statement instanceof RevokePrivilege ||
-            statement instanceof DropUser ||
+            statement instanceof AlterRole ||
+            statement instanceof DropRole ||
             statement instanceof DropAnalyzer ||
             statement instanceof DropFunction ||
             statement instanceof DropTable ||
diff --git a/pom.xml b/pom.xml
index 9e613a246b..e7870f401a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -212,7 +212,7 @@
     <versions.antlr>4.13.1</versions.antlr>
     <versions.quickcheck>1.0</versions.quickcheck>
     <versions.hppc>0.8.2</versions.hppc>
-    <versions.netty>4.1.100.Final</versions.netty>
+    <versions.netty>4.1.101.Final</versions.netty>
     <versions.lucene>9.8.0</versions.lucene>
     <versions.spatial4j>0.8</versions.spatial4j>
     <versions.jts>1.19.0</versions.jts>
diff --git a/server/src/main/java/io/crate/analyze/Analyzer.java b/server/src/main/java/io/crate/analyze/Analyzer.java
index e5a63ea0bd..dd59eb4a97 100644
--- a/server/src/main/java/io/crate/analyze/Analyzer.java
+++ b/server/src/main/java/io/crate/analyze/Analyzer.java
@@ -48,7 +48,7 @@ import io.crate.sql.tree.AlterTableDropColumn;
 import io.crate.sql.tree.AlterTableOpenClose;
 import io.crate.sql.tree.AlterTableRename;
 import io.crate.sql.tree.AlterTableReroute;
-import io.crate.sql.tree.AlterUser;
+import io.crate.sql.tree.AlterRole;
 import io.crate.sql.tree.AnalyzeStatement;
 import io.crate.sql.tree.AstVisitor;
 import io.crate.sql.tree.BeginStatement;
@@ -82,7 +82,7 @@ import io.crate.sql.tree.DropRepository;
 import io.crate.sql.tree.DropSnapshot;
 import io.crate.sql.tree.DropSubscription;
 import io.crate.sql.tree.DropTable;
-import io.crate.sql.tree.DropUser;
+import io.crate.sql.tree.DropRole;
 import io.crate.sql.tree.DropView;
 import io.crate.sql.tree.Explain;
 import io.crate.sql.tree.Expression;
@@ -318,9 +318,9 @@ public class Analyzer {
         }
 
         @Override
-        public AnalyzedStatement visitAlterUser(AlterUser<?> node, Analysis context) {
+        public AnalyzedStatement visitAlterRole(AlterRole<?> node, Analysis context) {
             return userAnalyzer.analyze(
-                (AlterUser<Expression>) node,
+                (AlterRole<Expression>) node,
                 context.paramTypeHints(),
                 context.transactionContext());
         }
@@ -484,7 +484,7 @@ public class Analyzer {
         }
 
         @Override
-        public AnalyzedStatement visitDropUser(DropUser node, Analysis context) {
+        public AnalyzedStatement visitDropRole(DropRole node, Analysis context) {
             return new AnalyzedDropUser(node.name(), node.ifExists());
         }
 
diff --git a/server/src/main/java/io/crate/analyze/UserAnalyzer.java b/server/src/main/java/io/crate/analyze/UserAnalyzer.java
index 782fff06f3..aef72f769f 100644
--- a/server/src/main/java/io/crate/analyze/UserAnalyzer.java
+++ b/server/src/main/java/io/crate/analyze/UserAnalyzer.java
@@ -27,7 +27,7 @@ import io.crate.analyze.relations.FieldProvider;
 import io.crate.expression.symbol.Symbol;
 import io.crate.metadata.CoordinatorTxnCtx;
 import io.crate.metadata.NodeContext;
-import io.crate.sql.tree.AlterUser;
+import io.crate.sql.tree.AlterRole;
 import io.crate.sql.tree.CreateUser;
 import io.crate.sql.tree.Expression;
 import io.crate.sql.tree.GenericProperties;
@@ -48,7 +48,7 @@ public class UserAnalyzer {
             mappedProperties(node.properties(), paramTypeHints, txnContext));
     }
 
-    public AnalyzedAlterUser analyze(AlterUser<Expression> node,
+    public AnalyzedAlterUser analyze(AlterRole<Expression> node,
                                      ParamTypeHints paramTypeHints,
                                      CoordinatorTxnCtx txnContext) {
         return new AnalyzedAlterUser(
diff --git a/server/src/main/java/io/crate/analyze/expressions/TableReferenceResolver.java b/server/src/main/java/io/crate/analyze/expressions/TableReferenceResolver.java
index 8783863251..43369ba11d 100644
--- a/server/src/main/java/io/crate/analyze/expressions/TableReferenceResolver.java
+++ b/server/src/main/java/io/crate/analyze/expressions/TableReferenceResolver.java
@@ -21,9 +21,8 @@
 
 package io.crate.analyze.expressions;
 
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 
 import org.jetbrains.annotations.Nullable;
 
@@ -37,12 +36,11 @@ import io.crate.sql.tree.QualifiedName;
 
 public class TableReferenceResolver implements FieldProvider<Reference> {
 
-    private final Collection<Reference> tableReferences;
+    private final Map<ColumnIdent, Reference> references;
     private final RelationName relationName;
-    private final List<Reference> references = new ArrayList<>();
 
-    public TableReferenceResolver(Collection<Reference> tableReferences, RelationName relationName) {
-        this.tableReferences = tableReferences;
+    public TableReferenceResolver(Map<ColumnIdent, Reference> references, RelationName relationName) {
+        this.references = references;
         this.relationName = relationName;
     }
 
@@ -52,17 +50,10 @@ public class TableReferenceResolver implements FieldProvider<Reference> {
                                   Operation operation,
                                   boolean errorOnUnknownObjectKey) {
         ColumnIdent columnIdent = ColumnIdent.fromNameSafe(qualifiedName, path);
-        for (var reference : tableReferences) {
-            if (reference.column().equals(columnIdent)) {
-                references.add(reference);
-                return reference;
-            }
+        Reference reference = references.get(columnIdent);
+        if (reference == null) {
+            throw new ColumnUnknownException(columnIdent, relationName);
         }
-
-        throw new ColumnUnknownException(columnIdent, relationName);
-    }
-
-    public List<Reference> references() {
-        return references;
+        return reference;
     }
 }
diff --git a/server/src/main/java/io/crate/execution/dsl/phases/HashJoinPhase.java b/server/src/main/java/io/crate/execution/dsl/phases/HashJoinPhase.java
index bcfd850490..ec6fb1cd79 100644
--- a/server/src/main/java/io/crate/execution/dsl/phases/HashJoinPhase.java
+++ b/server/src/main/java/io/crate/execution/dsl/phases/HashJoinPhase.java
@@ -27,6 +27,8 @@ import io.crate.expression.symbol.Symbols;
 import io.crate.sql.tree.JoinType;
 import io.crate.types.DataType;
 import io.crate.types.DataTypes;
+
+import org.elasticsearch.Version;
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
 
@@ -43,7 +45,6 @@ public class HashJoinPhase extends JoinPhase {
 
     private final List<DataType<?>> leftOutputTypes;
     private final long estimatedRowSizeForLeft;
-    private final long numberOfRowsForLeft;
 
     public HashJoinPhase(UUID jobId,
                          int executionNodeId,
@@ -58,8 +59,7 @@ public class HashJoinPhase extends JoinPhase {
                          List<Symbol> leftJoinConditionInputs,
                          List<Symbol> rightJoinConditionInputs,
                          List<DataType<?>> leftOutputTypes,
-                         long estimatedRowSizeForLeft,
-                         long numberOfRowsForLeft) {
+                         long estimatedRowSizeForLeft) {
         super(
             jobId,
             executionNodeId,
@@ -77,7 +77,6 @@ public class HashJoinPhase extends JoinPhase {
         this.rightJoinConditionInputs = rightJoinConditionInputs;
         this.leftOutputTypes = leftOutputTypes;
         this.estimatedRowSizeForLeft = estimatedRowSizeForLeft;
-        this.numberOfRowsForLeft = numberOfRowsForLeft;
     }
 
     public HashJoinPhase(StreamInput in) throws IOException {
@@ -88,7 +87,10 @@ public class HashJoinPhase extends JoinPhase {
         leftOutputTypes = DataTypes.listFromStream(in);
 
         estimatedRowSizeForLeft = in.readZLong();
-        numberOfRowsForLeft = in.readZLong();
+        if (in.getVersion().before(Version.V_5_6_0)) {
+            // Version before 5.6.0 used to send numberOfRowsForLeft
+            in.readZLong();
+        }
     }
 
     @Override
@@ -100,7 +102,11 @@ public class HashJoinPhase extends JoinPhase {
         DataTypes.toStream(leftOutputTypes, out);
 
         out.writeZLong(estimatedRowSizeForLeft);
-        out.writeZLong(numberOfRowsForLeft);
+        if (out.getVersion().before(Version.V_5_6_0)) {
+            // Version before 5.6.0 used to send numberOfRowsForLeft,
+            // sending neutral value, indicating that this stat is unavailable.
+            out.writeZLong(-1);
+        }
     }
 
     @Override
@@ -128,8 +134,4 @@ public class HashJoinPhase extends JoinPhase {
     public long estimatedRowSizeForLeft() {
         return estimatedRowSizeForLeft;
     }
-
-    public long numberOfRowsForLeft() {
-        return numberOfRowsForLeft;
-    }
 }
diff --git a/server/src/main/java/io/crate/expression/predicate/NotPredicate.java b/server/src/main/java/io/crate/expression/predicate/NotPredicate.java
index fef07514e2..5a0d7264c3 100644
--- a/server/src/main/java/io/crate/expression/predicate/NotPredicate.java
+++ b/server/src/main/java/io/crate/expression/predicate/NotPredicate.java
@@ -21,12 +21,11 @@
 
 package io.crate.expression.predicate;
 
-import static io.crate.expression.predicate.IsNullPredicate.isNullFuncToQuery;
-
 import java.util.HashSet;
 import java.util.Set;
 
 import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
 import org.elasticsearch.common.lucene.search.Queries;
@@ -37,6 +36,7 @@ import io.crate.expression.operator.any.AnyEqOperator;
 import io.crate.expression.operator.any.AnyNeqOperator;
 import io.crate.expression.operator.any.AnyRangeOperator;
 import io.crate.expression.scalar.Ignore3vlFunction;
+import io.crate.expression.scalar.conditional.CaseFunction;
 import io.crate.expression.scalar.conditional.CoalesceFunction;
 import io.crate.expression.symbol.Function;
 import io.crate.expression.symbol.Literal;
@@ -132,7 +132,8 @@ public class NotPredicate extends Scalar<Boolean, Boolean> {
                 AnyRangeOperator.Comparison.LTE.opName(),
                 LikeOperators.ANY_LIKE,
                 LikeOperators.ANY_NOT_LIKE,
-                CoalesceFunction.NAME
+                CoalesceFunction.NAME,
+                CaseFunction.NAME
             );
 
         @Override
@@ -186,26 +187,27 @@ public class NotPredicate extends Scalar<Boolean, Boolean> {
         Query innerQuery = arg.accept(context.visitor(), context);
         Query notX = Queries.not(innerQuery);
 
+        SymbolToNotNullContext ctx = new SymbolToNotNullContext();
+        arg.accept(INNER_VISITOR, ctx);
+
+        if (ctx.hasStrictThreeValuedLogicFunction) {
+            return new BooleanQuery.Builder()
+                .add(notX, Occur.MUST)
+                .add(LuceneQueryBuilder.genericFunctionFilter(input, context), Occur.FILTER)
+                .build();
+        }
+
         // not x =  not x & x is not null
         BooleanQuery.Builder builder = new BooleanQuery.Builder();
         builder.add(notX, BooleanClause.Occur.MUST);
-        SymbolToNotNullContext ctx = new SymbolToNotNullContext();
-        arg.accept(INNER_VISITOR, ctx);
         for (Reference reference : ctx.references()) {
             if (reference.isNullable()) {
                 var refExistsQuery = IsNullPredicate.refExistsQuery(reference, context, false);
                 if (refExistsQuery != null) {
-                    // we don't count empty arrays here as we count them below explicitly if 3Vl logic is needed.
                     builder.add(refExistsQuery, BooleanClause.Occur.MUST);
                 }
             }
         }
-        if (ctx.hasStrictThreeValuedLogicFunction) {
-            builder.add(
-                Queries.not(isNullFuncToQuery(arg, context)),
-                BooleanClause.Occur.MUST
-            );
-        }
         return builder.build();
     }
 }
diff --git a/server/src/main/java/io/crate/expression/udf/UserDefinedFunctionService.java b/server/src/main/java/io/crate/expression/udf/UserDefinedFunctionService.java
index a030694269..5fc4eec902 100644
--- a/server/src/main/java/io/crate/expression/udf/UserDefinedFunctionService.java
+++ b/server/src/main/java/io/crate/expression/udf/UserDefinedFunctionService.java
@@ -32,7 +32,6 @@ import java.util.Map;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-import org.jetbrains.annotations.Nullable;
 import javax.script.ScriptException;
 
 import org.apache.logging.log4j.LogManager;
@@ -45,6 +44,7 @@ import org.elasticsearch.cluster.metadata.Metadata;
 import org.elasticsearch.cluster.service.ClusterService;
 import org.elasticsearch.common.inject.Inject;
 import org.elasticsearch.common.inject.Singleton;
+import org.jetbrains.annotations.Nullable;
 
 import io.crate.analyze.ParamTypeHints;
 import io.crate.analyze.expressions.ExpressionAnalysisContext;
@@ -56,6 +56,7 @@ import io.crate.common.unit.TimeValue;
 import io.crate.exceptions.UnsupportedFunctionException;
 import io.crate.exceptions.UserDefinedFunctionAlreadyExistsException;
 import io.crate.exceptions.UserDefinedFunctionUnknownException;
+import io.crate.metadata.ColumnIdent;
 import io.crate.metadata.CoordinatorTxnCtx;
 import io.crate.metadata.FunctionName;
 import io.crate.metadata.FunctionProvider;
@@ -305,8 +306,11 @@ public class UserDefinedFunctionService {
 
         for (var indexParts : indices) {
             var tableInfo = docTableFactory.create(indexParts.toRelationName(), currentState);
-            var functionParameters = getAllReferencedColumnsOfGeneratedColumns(tableInfo.generatedColumns());
-            TableReferenceResolver tableReferenceResolver = new TableReferenceResolver(functionParameters, tableInfo.ident());
+            var functionParameters = getReferencedRefs(tableInfo.generatedColumns());
+            TableReferenceResolver tableReferenceResolver = new TableReferenceResolver(
+                functionParameters,
+                tableInfo.ident()
+            );
             CoordinatorTxnCtx coordinatorTxnCtx = CoordinatorTxnCtx.systemTransactionContext();
             ExpressionAnalyzer exprAnalyzer = new ExpressionAnalyzer(
                 coordinatorTxnCtx, nodeCtxWithRemovedFunction, ParamTypeHints.EMPTY, tableReferenceResolver, null);
@@ -326,10 +330,12 @@ public class UserDefinedFunctionService {
         }
     }
 
-    private List<Reference> getAllReferencedColumnsOfGeneratedColumns(List<GeneratedReference> generatedReferences) {
-        List<Reference> referencedReferences = new ArrayList<>();
+    private static Map<ColumnIdent, Reference> getReferencedRefs(List<GeneratedReference> generatedReferences) {
+        Map<ColumnIdent, Reference> referencedReferences = new HashMap<>();
         for (var generatedRef : generatedReferences) {
-            referencedReferences.addAll(generatedRef.referencedReferences());
+            for (var referencedRef : generatedRef.referencedReferences()) {
+                referencedReferences.put(referencedRef.column(), referencedRef);
+            }
         }
         return referencedReferences;
     }
diff --git a/server/src/main/java/io/crate/metadata/GeneratedReference.java b/server/src/main/java/io/crate/metadata/GeneratedReference.java
index 4675842600..86192f68af 100644
--- a/server/src/main/java/io/crate/metadata/GeneratedReference.java
+++ b/server/src/main/java/io/crate/metadata/GeneratedReference.java
@@ -37,6 +37,7 @@ import org.elasticsearch.common.io.stream.StreamOutput;
 import org.jetbrains.annotations.Nullable;
 
 import io.crate.expression.scalar.cast.CastMode;
+import io.crate.expression.symbol.RefVisitor;
 import io.crate.expression.symbol.Symbol;
 import io.crate.expression.symbol.SymbolType;
 import io.crate.expression.symbol.SymbolVisitor;
@@ -132,8 +133,13 @@ public class GeneratedReference implements Reference {
         assert generatedExpression == null || generatedExpression.valueType().equals(valueType())
             : "The type of the generated expression must match the valueType of the `GeneratedReference`";
         this.generatedExpression = generatedExpression;
-        if (generatedExpression != null && SymbolVisitors.any(Symbols::isAggregate, generatedExpression)) {
-            throw new UnsupportedOperationException("Aggregation functions are not allowed in generated columns: " + generatedExpression);
+        if (generatedExpression != null) {
+            if (SymbolVisitors.any(Symbols::isAggregate, generatedExpression)) {
+                throw new UnsupportedOperationException(
+                    "Aggregation functions are not allowed in generated columns: " + generatedExpression);
+            }
+            this.referencedReferences = new ArrayList<>();
+            RefVisitor.visitRefs(generatedExpression, referencedReferences::add);
         }
     }
 
@@ -142,10 +148,6 @@ public class GeneratedReference implements Reference {
         return generatedExpression;
     }
 
-    public void referencedReferences(List<Reference> references) {
-        this.referencedReferences = references;
-    }
-
     public List<Reference> referencedReferences() {
         return referencedReferences;
     }
diff --git a/server/src/main/java/io/crate/metadata/IndexReference.java b/server/src/main/java/io/crate/metadata/IndexReference.java
index 870d429688..5e334ff6ea 100644
--- a/server/src/main/java/io/crate/metadata/IndexReference.java
+++ b/server/src/main/java/io/crate/metadata/IndexReference.java
@@ -30,7 +30,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.function.LongSupplier;
-import java.util.stream.Collectors;
 
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
@@ -110,7 +109,14 @@ public class IndexReference extends SimpleReference {
                 // This code handles outdated shards case.
                 return new IndexReference(position, oid, isDropped, ident, indexType, columns, analyzer);
             }
-            List<Reference> sources = references.values().stream().filter(ref -> sourceNames.contains(ref.storageIdent())).collect(Collectors.toList());
+            List<Reference> sources = new ArrayList<>(sourceNames.size());
+            for (String sourceName : sourceNames) {
+                Reference ref = references.values().stream()
+                    .filter(r -> r.storageIdent().equals(sourceName))
+                    .findAny()
+                    .orElseThrow();
+                sources.add(ref);
+            }
             return new IndexReference(position, oid, isDropped, ident, indexType, sources, analyzer);
         }
     }
diff --git a/server/src/main/java/io/crate/metadata/PartitionInfos.java b/server/src/main/java/io/crate/metadata/PartitionInfos.java
index 5facf93cad..3afee472c0 100644
--- a/server/src/main/java/io/crate/metadata/PartitionInfos.java
+++ b/server/src/main/java/io/crate/metadata/PartitionInfos.java
@@ -28,18 +28,19 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.stream.StreamSupport;
 
-import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
-
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.elasticsearch.cluster.metadata.IndexMetadata;
+import org.elasticsearch.cluster.metadata.IndexMetadata.State;
 import org.elasticsearch.cluster.metadata.MappingMetadata;
 import org.elasticsearch.cluster.service.ClusterService;
 import org.elasticsearch.common.settings.Settings;
 
+import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
+
 import io.crate.analyze.NumberOfReplicas;
-import io.crate.metadata.doc.DocIndexMetadata;
 import io.crate.types.DataType;
+import io.crate.types.DataTypes;
 
 public class PartitionInfos implements Iterable<PartitionInfo> {
 
@@ -80,7 +81,7 @@ public class PartitionInfos implements Iterable<PartitionInfo> {
                     numberOfReplicas,
                     IndexMetadata.SETTING_INDEX_VERSION_CREATED.get(settings),
                     settings.getAsVersion(IndexMetadata.SETTING_VERSION_UPGRADED, null),
-                    DocIndexMetadata.isClosed(indexMetadata, mappingMap, false),
+                    indexMetadata.getState() == State.CLOSE,
                     valuesMap,
                     settings);
         } catch (Exception e) {
@@ -110,7 +111,7 @@ public class PartitionInfos implements Iterable<PartitionInfo> {
             String dottedColumnName = columnAndType.get(0);
             String sqlFqn = ColumnIdent.fromPath(dottedColumnName).sqlFqn();
             String typeName = columnAndType.get(1);
-            DataType<?> type = DocIndexMetadata.getColumnDataType(Map.of("type", typeName));
+            DataType<?> type = DataTypes.ofMappingName(typeName);
             Object value = type.implicitCast(partitionName.values().get(i));
             valuesByColumn.put(sqlFqn, value);
         }
diff --git a/server/src/main/java/io/crate/metadata/Reference.java b/server/src/main/java/io/crate/metadata/Reference.java
index 9311b85868..eaed4a84ae 100644
--- a/server/src/main/java/io/crate/metadata/Reference.java
+++ b/server/src/main/java/io/crate/metadata/Reference.java
@@ -25,6 +25,7 @@ import static org.elasticsearch.cluster.metadata.Metadata.COLUMN_OID_UNASSIGNED;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Comparator;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -42,6 +43,10 @@ import io.crate.sql.tree.ColumnPolicy;
 
 public interface Reference extends Symbol {
 
+    public static final Comparator<Reference> CMP_BY_POSITION_THEN_NAME = Comparator
+        .comparing(Reference::position)
+        .thenComparing(r -> r.column().fqn());
+
     static int indexOf(Iterable<? extends Reference> refs, ColumnIdent column) {
         int i = 0;
         for (Reference ref : refs) {
diff --git a/server/src/main/java/io/crate/metadata/cluster/DDLClusterStateHelpers.java b/server/src/main/java/io/crate/metadata/cluster/DDLClusterStateHelpers.java
index 3a1a9c81b1..47685563e2 100644
--- a/server/src/main/java/io/crate/metadata/cluster/DDLClusterStateHelpers.java
+++ b/server/src/main/java/io/crate/metadata/cluster/DDLClusterStateHelpers.java
@@ -21,19 +21,14 @@
 
 package io.crate.metadata.cluster;
 
-import static io.crate.metadata.doc.DocIndexMetadata.furtherColumnProperties;
-
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-import org.elasticsearch.cluster.metadata.ColumnPositionResolver;
-import org.elasticsearch.index.mapper.ContentPath;
-import org.jetbrains.annotations.Nullable;
-
 import org.elasticsearch.ElasticsearchException;
+import org.elasticsearch.cluster.metadata.ColumnPositionResolver;
 import org.elasticsearch.cluster.metadata.IndexMetadata;
 import org.elasticsearch.cluster.metadata.IndexTemplateMetadata;
 import org.elasticsearch.cluster.metadata.Metadata;
@@ -44,6 +39,8 @@ import org.elasticsearch.common.xcontent.DeprecationHandler;
 import org.elasticsearch.common.xcontent.NamedXContentRegistry;
 import org.elasticsearch.common.xcontent.XContentParser;
 import org.elasticsearch.common.xcontent.json.JsonXContent;
+import org.elasticsearch.index.mapper.ContentPath;
+import org.jetbrains.annotations.Nullable;
 
 import io.crate.Constants;
 import io.crate.common.annotations.VisibleForTesting;
@@ -177,7 +174,7 @@ public class DDLClusterStateHelpers {
             String name = e.getKey();
             contentPath.add(name);
             Map<String, Object> columnProperties = (Map<String, Object>) e.getValue();
-            columnProperties = furtherColumnProperties(columnProperties);
+            columnProperties = Maps.getOrDefault(columnProperties, "inner", columnProperties);
             assert columnProperties.containsKey("inner") || (columnProperties.containsKey("position") && columnProperties.get("position") != null)
                 : "Column position is missing: " + name;
             // BWC compatibility with nodes < 5.1, position could be NULL if column is created on that nodes
diff --git a/server/src/main/java/io/crate/metadata/doc/DocIndexMetadata.java b/server/src/main/java/io/crate/metadata/doc/DocIndexMetadata.java
deleted file mode 100644
index 4eea264980..0000000000
--- a/server/src/main/java/io/crate/metadata/doc/DocIndexMetadata.java
+++ /dev/null
@@ -1,900 +0,0 @@
-/*
- * Licensed to Crate.io GmbH ("Crate") under one or more contributor
- * license agreements.  See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.  Crate licenses
- * this file to you under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- * However, if you have executed another commercial license agreement
- * with Crate these terms will supersede the license and you may use the
- * software solely pursuant to the terms of the relevant commercial agreement.
- */
-
-package io.crate.metadata.doc;
-
-import static org.elasticsearch.cluster.metadata.Metadata.COLUMN_OID_UNASSIGNED;
-import static org.elasticsearch.index.mapper.TypeParsers.DOC_VALUES;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.stream.Collectors;
-
-import org.elasticsearch.Version;
-import org.elasticsearch.cluster.metadata.IndexMetadata;
-import org.elasticsearch.cluster.metadata.MappingMetadata;
-import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.index.mapper.BitStringFieldMapper;
-import org.elasticsearch.index.mapper.DateFieldMapper;
-import org.elasticsearch.index.mapper.KeywordFieldMapper;
-import org.jetbrains.annotations.Nullable;
-
-import io.crate.analyze.NumberOfReplicas;
-import io.crate.analyze.ParamTypeHints;
-import io.crate.analyze.expressions.ExpressionAnalysisContext;
-import io.crate.analyze.expressions.ExpressionAnalyzer;
-import io.crate.analyze.expressions.TableReferenceResolver;
-import io.crate.analyze.relations.FieldProvider;
-import io.crate.common.Booleans;
-import io.crate.common.collections.Lists2;
-import io.crate.common.collections.MapBuilder;
-import io.crate.common.collections.Maps;
-import io.crate.expression.symbol.Symbol;
-import io.crate.metadata.ColumnIdent;
-import io.crate.metadata.CoordinatorTxnCtx;
-import io.crate.metadata.GeneratedReference;
-import io.crate.metadata.GeoReference;
-import io.crate.metadata.IndexReference;
-import io.crate.metadata.IndexType;
-import io.crate.metadata.NodeContext;
-import io.crate.metadata.Reference;
-import io.crate.metadata.ReferenceIdent;
-import io.crate.metadata.RelationName;
-import io.crate.metadata.RowGranularity;
-import io.crate.metadata.SimpleReference;
-import io.crate.metadata.table.Operation;
-import io.crate.replication.logical.metadata.PublicationsMetadata;
-import io.crate.sql.parser.SqlParser;
-import io.crate.sql.tree.CheckConstraint;
-import io.crate.sql.tree.ColumnPolicy;
-import io.crate.sql.tree.Expression;
-import io.crate.types.ArrayType;
-import io.crate.types.BitStringType;
-import io.crate.types.CharacterType;
-import io.crate.types.DataType;
-import io.crate.types.DataTypes;
-import io.crate.types.FloatVectorType;
-import io.crate.types.ObjectType;
-import io.crate.types.StorageSupport;
-import io.crate.types.StringType;
-
-public class DocIndexMetadata {
-
-    private static final String SETTING_CLOSED = "closed";
-
-    private final Map<String, Object> mappingMap;
-    private final Map<ColumnIdent, IndexReference.Builder> indicesBuilder = new HashMap<>();
-
-    @SuppressWarnings("unchecked")
-    private static final Comparator<Map.Entry<String, Object>> SORT_BY_POSITION_THEN_NAME = Comparator
-        .comparing((Map.Entry<String, Object> e) -> {
-            Map<String, Object> columnProperties = furtherColumnProperties((Map<String, Object>) e.getValue());
-            return Objects.requireNonNullElse((Integer) columnProperties.get("position"), 0);
-        })
-        .thenComparing(Map.Entry::getKey);
-
-    private static final Comparator<Reference> SORT_REFS_BY_POSTITON_THEN_NAME = Comparator
-        .comparing(Reference::position)
-        .thenComparing(o -> o.column().fqn());
-
-    private final List<Reference> columns = new ArrayList<>();
-    private final List<Reference> nestedColumns = new ArrayList<>();
-    private final ArrayList<GeneratedReference> generatedColumnReferencesBuilder = new ArrayList<>();
-
-    private final Set<Reference> droppedColumns = new HashSet<>();
-
-    private final NodeContext nodeCtx;
-    private final RelationName ident;
-    private final int numberOfShards;
-    private final String numberOfReplicas;
-    private final Settings tableParameters;
-    private final Map<String, Object> indicesMap;
-    private final List<ColumnIdent> partitionedBy;
-    private final Set<Operation> supportedOperations;
-    private Map<ColumnIdent, IndexReference> indices;
-    private List<Reference> partitionedByColumns;
-    private List<GeneratedReference> generatedColumnReferences;
-    private Map<ColumnIdent, Reference> references;
-    @Nullable
-    private String pkConstraintName;
-    private List<ColumnIdent> primaryKey;
-    private List<CheckConstraint<Symbol>> checkConstraints;
-    private Collection<ColumnIdent> notNullColumns;
-    private ColumnIdent routingCol;
-    private boolean hasAutoGeneratedPrimaryKey = false;
-    private boolean closed;
-    Map<Integer, String> takenPositions = new HashMap<>();
-
-    private ColumnPolicy columnPolicy = ColumnPolicy.STRICT;
-    private Map<String, String> generatedColumns;
-
-    @Nullable
-    private final Version versionCreated;
-    @Nullable
-    private final Version versionUpgraded;
-
-    /**
-     * Analyzer used for Column Default expressions
-     */
-    private final ExpressionAnalyzer expressionAnalyzer;
-
-    DocIndexMetadata(NodeContext nodeCtx, IndexMetadata metadata, RelationName ident, @Nullable PublicationsMetadata publicationsMetadata) {
-        this.nodeCtx = nodeCtx;
-        this.ident = ident;
-        this.numberOfShards = metadata.getNumberOfShards();
-        Settings settings = metadata.getSettings();
-        this.numberOfReplicas = NumberOfReplicas.fromSettings(settings);
-        this.mappingMap = getMappingMap(metadata);
-        this.tableParameters = metadata.getSettings();
-
-        Map<String, Object> metaMap = Maps.get(mappingMap, "_meta");
-        indicesMap = Maps.getOrDefault(metaMap, "indices", Map.of());
-        List<List<String>> partitionedByList = Maps.getOrDefault(metaMap, "partitioned_by", List.of());
-        this.partitionedBy = getPartitionedBy(partitionedByList);
-        generatedColumns = Maps.getOrDefault(metaMap, "generated_columns", Map.of());
-        IndexMetadata.State state = isClosed(metadata, mappingMap, !partitionedByList.isEmpty()) ?
-            IndexMetadata.State.CLOSE : IndexMetadata.State.OPEN;
-        var isPublished = isPublished(ident, publicationsMetadata);
-        supportedOperations = Operation.buildFromIndexSettingsAndState(metadata.getSettings(), state, isPublished);
-        versionCreated = IndexMetadata.SETTING_INDEX_VERSION_CREATED.get(settings);
-        versionUpgraded = settings.getAsVersion(IndexMetadata.SETTING_VERSION_UPGRADED, null);
-        closed = state == IndexMetadata.State.CLOSE;
-
-        this.expressionAnalyzer = new ExpressionAnalyzer(
-            CoordinatorTxnCtx.systemTransactionContext(),
-            nodeCtx,
-            ParamTypeHints.EMPTY,
-            FieldProvider.UNSUPPORTED,
-            null);
-    }
-
-    private static Map<String, Object> getMappingMap(IndexMetadata metadata) {
-        MappingMetadata mappingMetadata = metadata.mapping();
-        if (mappingMetadata == null) {
-            return Map.of();
-        }
-        return mappingMetadata.sourceAsMap();
-    }
-
-    static boolean isPublished(RelationName ident, PublicationsMetadata publicationsMetadata) {
-        if (publicationsMetadata != null) {
-            return publicationsMetadata.isPublished(ident);
-        }
-        return false;
-    }
-
-    public static boolean isClosed(IndexMetadata indexMetadata, Map<String, Object> mappingMap, boolean isPartitioned) {
-        // Checking here for whether the closed flag exists on the template metadata, as partitioned tables that are
-        // empty (and thus have no indexes who have states) need a way to set their state.
-        if (isPartitioned) {
-            return Maps.getOrDefault(
-                Maps.getOrDefault(mappingMap, "_meta", null),
-                SETTING_CLOSED,
-                false);
-        }
-        return indexMetadata.getState() == IndexMetadata.State.CLOSE;
-    }
-
-    private void add(Map<String, Object> columnProperties,
-                     int position,
-                     long oid,
-                     boolean isDropped,
-                     ColumnIdent column,
-                     DataType<?> type,
-                     @Nullable Symbol defaultExpression,
-                     ColumnPolicy columnPolicy,
-                     IndexType indexType,
-                     boolean nullable,
-                     boolean hasDocValues) {
-        Reference ref;
-        boolean partitionByColumn = partitionedBy.contains(column);
-        String generatedExpression = generatedColumns.get(column.fqn());
-        if (partitionByColumn) {
-            indexType = IndexType.PLAIN;
-        }
-
-        Reference simpleRef = new SimpleReference(
-            refIdent(column),
-            granularity(column),
-            removeDroppedColsFromInnerTypes(columnProperties, type),
-            columnPolicy,
-            indexType,
-            nullable,
-            hasDocValues,
-            position,
-            oid,
-            isDropped,
-            defaultExpression
-        );
-        if (generatedExpression == null) {
-            ref = simpleRef;
-        } else {
-            ref = new GeneratedReference(simpleRef, generatedExpression, null);
-        }
-        if (isDropped) {
-            droppedColumns.add(ref);
-            return;
-        }
-        if (column.isRoot()) {
-            columns.add(ref);
-        } else {
-            nestedColumns.add(ref);
-        }
-        if (ref instanceof GeneratedReference genRef) {
-            generatedColumnReferencesBuilder.add(genRef);
-        }
-    }
-
-    private void addGeoReference(Integer position,
-                                 long oid,
-                                 boolean isDropped,
-                                 ColumnIdent column,
-                                 Symbol defaultExpression,
-                                 @Nullable String tree,
-                                 @Nullable String precision,
-                                 @Nullable Integer treeLevels,
-                                 @Nullable Double distanceErrorPct,
-                                 boolean nullable,
-                                 DataType<?> type) {
-        Reference info = new GeoReference(
-            refIdent(column),
-            type,
-            ColumnPolicy.DYNAMIC,
-            IndexType.PLAIN,
-            nullable,
-            position,
-            oid,
-            isDropped,
-            defaultExpression,
-            tree,
-            precision,
-            treeLevels,
-            distanceErrorPct
-        );
-        if (isDropped) {
-            droppedColumns.add(info);
-            return;
-        }
-
-
-        String generatedExpression = generatedColumns.get(column.fqn());
-        if (generatedExpression != null) {
-            info = new GeneratedReference(info, generatedExpression, null);
-            generatedColumnReferencesBuilder.add((GeneratedReference) info);
-        }
-
-        if (column.isRoot()) {
-            columns.add(info);
-        } else {
-            nestedColumns.add(info);
-        }
-    }
-
-    private ReferenceIdent refIdent(ColumnIdent column) {
-        return new ReferenceIdent(ident, column);
-    }
-
-    private RowGranularity granularity(ColumnIdent column) {
-        if (partitionedBy.contains(column)) {
-            return RowGranularity.PARTITION;
-        }
-        return RowGranularity.DOC;
-    }
-
-    record InnerObjectType(String name, int position, DataType<?> type) {}
-
-    /**
-     * extract dataType from given columnProperties
-     *
-     * @param columnProperties map of String to Object containing column properties
-     * @return dataType of the column with columnProperties
-     */
-    @SuppressWarnings("unchecked")
-    public static DataType<?> getColumnDataType(Map<String, Object> columnProperties) {
-        DataType<?> type;
-        String typeName = (String) columnProperties.get("type");
-
-        if (typeName == null || ObjectType.NAME.equals(typeName)) {
-            Map<String, Object> innerProperties = (Map<String, Object>) columnProperties.get("properties");
-            if (innerProperties != null) {
-                List<InnerObjectType> children = new ArrayList<>();
-                for (Map.Entry<String, Object> entry : innerProperties.entrySet()) {
-                    Map<String, Object> value = (Map<String, Object>) entry.getValue();
-                    int position = (int) value.getOrDefault("position", -1);
-                    children.add(new InnerObjectType(entry.getKey(), position, getColumnDataType(value)));
-                }
-                children.sort(Comparator.comparingInt(x -> x.position()));
-                ObjectType.Builder builder = ObjectType.builder();
-                for (var child : children) {
-                    builder.setInnerType(child.name, child.type);
-                }
-                type = builder.build();
-            } else {
-                type = Objects.requireNonNullElse(DataTypes.ofMappingName(typeName), DataTypes.NOT_SUPPORTED);
-            }
-        } else if (typeName.equalsIgnoreCase("array")) {
-            Map<String, Object> innerProperties = Maps.get(columnProperties, "inner");
-            DataType<?> innerType = getColumnDataType(innerProperties);
-            type = new ArrayType<>(innerType);
-        } else {
-            typeName = typeName.toLowerCase(Locale.ENGLISH);
-            switch (typeName) {
-                case DateFieldMapper.CONTENT_TYPE:
-                    Boolean ignoreTimezone = (Boolean) columnProperties.get("ignore_timezone");
-                    if (ignoreTimezone != null && ignoreTimezone) {
-                        return DataTypes.TIMESTAMP;
-                    } else {
-                        return DataTypes.TIMESTAMPZ;
-                    }
-                case KeywordFieldMapper.CONTENT_TYPE:
-                    Integer lengthLimit = (Integer) columnProperties.get("length_limit");
-                    var blankPadding = columnProperties.get("blank_padding");
-                    if (blankPadding != null && (Boolean) blankPadding) {
-                        return new CharacterType(lengthLimit);
-                    }
-                    return lengthLimit != null
-                        ? StringType.of(lengthLimit)
-                        : DataTypes.STRING;
-
-                case BitStringFieldMapper.CONTENT_TYPE:
-                    Integer length = (Integer) columnProperties.get("length");
-                    assert length != null : "Length is required for bit string type";
-                    return new BitStringType(length);
-
-                case FloatVectorType.NAME:
-                    Integer dimensions = (Integer) columnProperties.get("dimensions");
-                    return new FloatVectorType(dimensions);
-
-                default:
-                    type = Objects.requireNonNullElse(DataTypes.ofMappingName(typeName), DataTypes.NOT_SUPPORTED);
-            }
-        }
-        return type;
-    }
-
-    /**
-     * Get the IndexType from columnProperties.
-     * <br />
-     * Properties might look like:
-     * <pre>
-     *     {
-     *         "type": "integer"
-     *     }
-     *
-     *
-     *     {
-     *         "type": "text",
-     *         "analyzer": "english"
-     *     }
-     *
-     *
-     *     {
-     *          "type": "text",
-     *          "fields": {
-     *              "keyword": {
-     *                  "type": "keyword",
-     *                  "ignore_above": "256"
-     *              }
-     *          }
-     *     }
-     *
-     *     {
-     *         "type": "date",
-     *         "index": "no"
-     *     }
-     *
-     *     {
-     *          "type": "keyword",
-     *          "index": false
-     *     }
-     * </pre>
-     */
-    private static IndexType getColumnIndexType(Map<String, Object> columnProperties) {
-        Object index = columnProperties.get("index");
-        if (index == null) {
-            if ("text".equals(columnProperties.get("type"))) {
-                return IndexType.FULLTEXT;
-            }
-            return IndexType.PLAIN;
-        }
-        if (Boolean.FALSE.equals(index) || "no".equals(index) || "false".equals(index)) {
-            return IndexType.NONE;
-        }
-
-        if ("not_analyzed".equals(index)) {
-            return IndexType.PLAIN;
-        }
-        return IndexType.FULLTEXT;
-    }
-
-    private static ColumnIdent columnIdent(@Nullable ColumnIdent parent, String name) {
-        if (parent == null) {
-            return new ColumnIdent(name);
-        }
-        return parent.getChild(name);
-    }
-
-    /**
-     * extracts index definitions as well
-     */
-    @SuppressWarnings("unchecked")
-    private void internalExtractColumnDefinitions(@Nullable ColumnIdent parent,
-                                                  @Nullable Map<String, Object> propertiesMap) {
-        if (propertiesMap == null) {
-            return;
-        }
-
-        var cols = propertiesMap.entrySet().stream().sorted(SORT_BY_POSITION_THEN_NAME)
-            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,
-                                      (e1, e2) -> e1, LinkedHashMap::new));
-
-        for (Map.Entry<String, Object> columnEntry : cols.entrySet()) {
-            Map<String, Object> columnProperties = (Map<String, Object>) columnEntry.getValue();
-            final DataType<?> columnDataType = getColumnDataType(columnProperties);
-            String columnName = columnEntry.getKey();
-            ColumnIdent newIdent = columnIdent(parent, columnName);
-
-            boolean nullable = !notNullColumns.contains(newIdent) && !primaryKey.contains(newIdent);
-            columnProperties = furtherColumnProperties(columnProperties);
-            assert columnProperties.containsKey("position") && columnProperties.get("position") != null : "Column position is missing: " + newIdent.fqn();
-            // BWC compatibility with nodes < 5.1, position could be NULL if column is created on that nodes
-            int position = (int) columnProperties.getOrDefault("position", 0);
-            assert !takenPositions.containsKey(position) : "Duplicate column position assigned to " + newIdent.fqn() + " and " + takenPositions.get(position);
-            boolean isDropped = (Boolean) columnProperties.getOrDefault("dropped", false);
-            if (!isDropped) {
-                // Columns, added later can get positions of the dropped columns.
-                // Absolute values of the positions is not important
-                // and relative positions still meet the requirement that new columns have higher positions.
-                takenPositions.put(position, newIdent.fqn());
-            }
-            String formattedDefaultExpression = (String) columnProperties.getOrDefault("default_expr", null);
-            Symbol defaultExpression = null;
-            if (formattedDefaultExpression != null) {
-                Expression expression = SqlParser.createExpression(formattedDefaultExpression);
-                defaultExpression = this.expressionAnalyzer.convert(
-                    expression,
-                    new ExpressionAnalysisContext(CoordinatorTxnCtx.systemTransactionContext().sessionSettings()));
-            }
-            IndexType columnIndexType = getColumnIndexType(columnProperties);
-            StorageSupport<?> storageSupport = columnDataType.storageSupportSafe();
-            boolean docValuesDefault = storageSupport.getComputedDocValuesDefault(columnIndexType);
-            boolean hasDocValues = Booleans.parseBoolean(columnProperties.getOrDefault(DOC_VALUES, docValuesDefault).toString());
-
-            // columnProperties.getOrDefault doesn't work here for OID values fitting into int.
-            // Jackson optimizes writes of small long values as stores them as ints:
-            long oid = ((Number) columnProperties.getOrDefault("oid", COLUMN_OID_UNASSIGNED)).longValue();
-
-            DataType<?> elementType = ArrayType.unnest(columnDataType);
-            if (elementType.equals(DataTypes.GEO_SHAPE)) {
-                String geoTree = (String) columnProperties.get("tree");
-                String precision = (String) columnProperties.get("precision");
-                Integer treeLevels = (Integer) columnProperties.get("tree_levels");
-                Double distanceErrorPct = (Double) columnProperties.get("distance_error_pct");
-                addGeoReference(
-                    position,
-                    oid,
-                    isDropped,
-                    newIdent,
-                    defaultExpression,
-                    geoTree,
-                    precision,
-                    treeLevels,
-                    distanceErrorPct,
-                    nullable,
-                    columnDataType
-                );
-            } else if (columnDataType.id() == ObjectType.ID
-                       || (columnDataType.id() == ArrayType.ID
-                           && ((ArrayType<?>) columnDataType).innerType().id() == ObjectType.ID)) {
-                ColumnPolicy columnPolicy = ColumnPolicy.fromMappingValue(columnProperties.get("dynamic"));
-                add(columnProperties, position, oid, isDropped, newIdent, columnDataType, defaultExpression,
-                    columnPolicy, IndexType.NONE, nullable, hasDocValues);
-
-                if (columnProperties.get("properties") != null) {
-                    // walk nested
-                    internalExtractColumnDefinitions(newIdent, (Map<String, Object>) columnProperties.get("properties"));
-                }
-            } else if (columnDataType != DataTypes.NOT_SUPPORTED) {
-                List<String> copyToColumns = Maps.get(columnProperties, "copy_to");
-
-                // TODO: copy_to is deprecated and has to be removed after 5.4
-                // extract columns this column is copied to, needed for indices
-                if (copyToColumns != null) {
-                    for (String copyToColumn : copyToColumns) {
-                        ColumnIdent targetIdent = ColumnIdent.fromPath(copyToColumn);
-                        IndexReference.Builder builder = getOrCreateIndexBuilder(targetIdent);
-                        builder.addColumn(new SimpleReference(
-                            refIdent(newIdent),
-                            granularity(newIdent),
-                            columnDataType,
-                            ColumnPolicy.DYNAMIC,
-                            columnIndexType,
-                            nullable,
-                            hasDocValues,
-                            position,
-                            oid,
-                            isDropped,
-                            defaultExpression
-                        ));
-                    }
-                }
-                // is it an index?
-                var indicesKey = oid == COLUMN_OID_UNASSIGNED ? newIdent.fqn() : Long.toString(oid);
-                if (indicesMap.containsKey(indicesKey)) {
-                    List<String> sources = Maps.get(columnProperties, "sources");
-                    if (sources != null) {
-                        IndexReference.Builder builder = getOrCreateIndexBuilder(newIdent);
-                        builder.indexType(columnIndexType)
-                            .position(position)
-                            .oid(oid)
-                            .analyzer((String) columnProperties.get("analyzer"))
-                            .sources(sources);
-                    }
-                } else {
-                    add(columnProperties, position, oid, isDropped, newIdent, columnDataType, defaultExpression,
-                        ColumnPolicy.DYNAMIC, columnIndexType, nullable, hasDocValues);
-                }
-            }
-        }
-    }
-
-    /**
-     * get the real column properties from a possible array mapping,
-     * keeping most of this stuff inside "inner"
-     */
-    @SuppressWarnings("unchecked")
-    public static Map<String, Object> furtherColumnProperties(Map<String, Object> columnProperties) {
-        if (columnProperties.get("inner") != null) {
-            return (Map<String, Object>) columnProperties.get("inner");
-        } else {
-            return columnProperties;
-        }
-    }
-
-    private IndexReference.Builder getOrCreateIndexBuilder(ColumnIdent ident) {
-        return indicesBuilder.computeIfAbsent(ident, k -> new IndexReference.Builder(refIdent(ident)));
-    }
-
-    @Nullable
-    private String getPkConstraintName() {
-        Map<String, Object> metaMap = Maps.get(mappingMap, "_meta");
-        return (metaMap != null) ? (String) metaMap.get("pk_constraint_name") : null;
-    }
-
-    private List<ColumnIdent> getPrimaryKey() {
-        Map<String, Object> metaMap = Maps.get(mappingMap, "_meta");
-        if (metaMap != null) {
-            ArrayList<ColumnIdent> builder = new ArrayList<>();
-            Object pKeys = metaMap.get("primary_keys");
-            if (pKeys != null) {
-                if (pKeys instanceof String str) {
-                    builder.add(ColumnIdent.fromPath(str));
-                    return List.copyOf(builder);
-                } else if (pKeys instanceof Collection<?> keys) {
-                    if (!keys.isEmpty()) {
-                        for (Object pkey : keys) {
-                            builder.add(ColumnIdent.fromPath(pkey.toString()));
-                        }
-                        return List.copyOf(builder);
-                    }
-                }
-            }
-        }
-        if (getCustomRoutingCol() == null && partitionedBy.isEmpty()) {
-            hasAutoGeneratedPrimaryKey = true;
-            return List.of(DocSysColumns.ID);
-        }
-        return List.of();
-    }
-
-    private Collection<ColumnIdent> getNotNullColumns() {
-        Map<String, Object> metaMap = Maps.get(mappingMap, "_meta");
-        if (metaMap != null) {
-            HashSet<ColumnIdent> builder = new HashSet<>();
-            Map<String, Object> constraintsMap = Maps.get(metaMap, "constraints");
-            if (constraintsMap != null) {
-                Object notNullColumnsMeta = constraintsMap.get("not_null");
-                if (notNullColumnsMeta != null) {
-                    Collection<?> notNullCols = (Collection<?>) notNullColumnsMeta;
-                    if (!notNullCols.isEmpty()) {
-                        for (Object notNullColumn : notNullCols) {
-                            builder.add(ColumnIdent.fromPath(notNullColumn.toString()));
-                        }
-                        return Collections.unmodifiableSet(builder);
-                    }
-                }
-            }
-        }
-        return List.of();
-    }
-
-    private static List<ColumnIdent> getPartitionedBy(List<List<String>> partitionedByList) {
-        ArrayList<ColumnIdent> builder = new ArrayList<>();
-        for (List<String> partitionedByInfo : partitionedByList) {
-            builder.add(ColumnIdent.fromPath(partitionedByInfo.get(0)));
-        }
-        return List.copyOf(builder);
-    }
-
-    private ColumnPolicy getColumnPolicy() {
-        return ColumnPolicy.fromMappingValue(mappingMap.get("dynamic"));
-    }
-
-    private void createColumnDefinitions() {
-        Map<String, Object> propertiesMap = Maps.get(mappingMap, "properties");
-        internalExtractColumnDefinitions(null, propertiesMap);
-    }
-
-    private Map<ColumnIdent, IndexReference> createIndexDefinitions() {
-        MapBuilder<ColumnIdent, IndexReference> builder = MapBuilder.newMapBuilder();
-        for (Map.Entry<ColumnIdent, IndexReference.Builder> entry : indicesBuilder.entrySet()) {
-            var indexRef = entry.getValue().build(references);
-            assert indexRef.isDropped() == false : "A named index is not expected to be dropped";
-            builder.put(entry.getKey(), indexRef);
-        }
-        indices = builder.immutableMap();
-        return indices;
-    }
-
-    private ColumnIdent getCustomRoutingCol() {
-        if (mappingMap != null) {
-            Map<String, Object> metaMap = Maps.get(mappingMap, "_meta");
-            if (metaMap != null) {
-                String routingPath = (String) metaMap.get("routing");
-                if (routingPath != null && !routingPath.equals(DocSysColumns.Names.ID)) {
-                    return ColumnIdent.fromPath(routingPath);
-                }
-            }
-        }
-        return null;
-    }
-
-    private ColumnIdent getRoutingCol() {
-        ColumnIdent col = getCustomRoutingCol();
-        if (col != null) {
-            return col;
-        }
-        if (primaryKey.size() == 1) {
-            return primaryKey.get(0);
-        }
-        return DocSysColumns.ID;
-    }
-
-    public DocIndexMetadata build() {
-        notNullColumns = getNotNullColumns();
-        pkConstraintName = getPkConstraintName();
-        primaryKey = getPrimaryKey();
-        columnPolicy = getColumnPolicy();
-        // notNullColumns and primaryKey must be resolved before creating column definitions.
-        createColumnDefinitions();
-        references = new LinkedHashMap<>();
-        DocSysColumns.forTable(ident, references::put);
-        columns.sort(SORT_REFS_BY_POSTITON_THEN_NAME);
-        nestedColumns.sort(SORT_REFS_BY_POSTITON_THEN_NAME);
-        for (Reference ref : columns) {
-            references.put(ref.column(), ref);
-            for (Reference nestedColumn : nestedColumns) {
-                if (nestedColumn.column().getRoot().equals(ref.column())) {
-                    references.put(nestedColumn.column(), nestedColumn);
-                }
-            }
-        }
-        // createIndexDefinitions() resolves sources by FQN using references.
-        // Index definition can include sub-columns, so we need to create index definitions after adding nested columns into references ^
-        indices = createIndexDefinitions();
-        // Order of the partitionedByColumns is important; Must be the same order as `partitionedBy` is in.
-        partitionedByColumns = Lists2.map(partitionedBy, references::get);
-        generatedColumnReferences = List.copyOf(generatedColumnReferencesBuilder);
-
-        routingCol = getRoutingCol();
-
-        Collection<Reference> refs = this.references.values();
-        TableReferenceResolver tableReferenceResolver = new TableReferenceResolver(refs, ident);
-        CoordinatorTxnCtx txnCtx = CoordinatorTxnCtx.systemTransactionContext();
-        ExpressionAnalyzer exprAnalyzer = new ExpressionAnalyzer(
-            txnCtx, nodeCtx, ParamTypeHints.EMPTY, tableReferenceResolver, null);
-        ExpressionAnalysisContext analysisCtx = new ExpressionAnalysisContext(txnCtx.sessionSettings());
-
-        ArrayList<CheckConstraint<Symbol>> checkConstraintsBuilder = null;
-        Map<String, Object> metaMap = Maps.get(mappingMap, "_meta");
-        if (metaMap != null) {
-            Map<String, String> checkConstraintsMap = Maps.get(metaMap, "check_constraints");
-            if (checkConstraintsMap != null) {
-                checkConstraintsBuilder = new ArrayList<>();
-                for (Map.Entry<String, String> entry : checkConstraintsMap.entrySet()) {
-                    String name = entry.getKey();
-                    String expressionStr = entry.getValue();
-                    Expression expr = SqlParser.createExpression(expressionStr);
-                    Symbol analyzedExpr = exprAnalyzer.convert(expr, analysisCtx);
-                    checkConstraintsBuilder.add(new CheckConstraint<>(name, null, analyzedExpr, expressionStr));
-                }
-            }
-        }
-        checkConstraints = checkConstraintsBuilder != null ? List.copyOf(checkConstraintsBuilder) : List.of();
-
-        for (var generatedReference : generatedColumnReferences) {
-            Expression expression = SqlParser.createExpression(generatedReference.formattedGeneratedExpression());
-            tableReferenceResolver.references().clear();
-            Symbol generatedExpression = exprAnalyzer.convert(expression, analysisCtx)
-                .cast(generatedReference.valueType());
-            generatedReference.generatedExpression(generatedExpression);
-            generatedReference.referencedReferences(List.copyOf(tableReferenceResolver.references()));
-        }
-        return this;
-    }
-
-    public Map<ColumnIdent, Reference> references() {
-        return references;
-    }
-
-    public Collection<Reference> columns() {
-        return columns;
-    }
-
-    public Set<Reference> droppedColumns() {
-        return droppedColumns;
-    }
-
-    public Map<ColumnIdent, IndexReference> indices() {
-        return indices;
-    }
-
-    public List<Reference> partitionedByColumns() {
-        return partitionedByColumns;
-    }
-
-    List<GeneratedReference> generatedColumnReferences() {
-        return generatedColumnReferences;
-    }
-
-    Collection<ColumnIdent> notNullColumns() {
-        return notNullColumns;
-    }
-
-    List<CheckConstraint<Symbol>> checkConstraints() {
-        return checkConstraints;
-    }
-
-    @Nullable
-    public String pkConstraintName() {
-        return pkConstraintName;
-    }
-
-    public List<ColumnIdent> primaryKey() {
-        return primaryKey;
-    }
-
-    ColumnIdent routingCol() {
-        return routingCol;
-    }
-
-    boolean hasAutoGeneratedPrimaryKey() {
-        return hasAutoGeneratedPrimaryKey;
-    }
-
-    public int numberOfShards() {
-        return numberOfShards;
-    }
-
-    public String numberOfReplicas() {
-        return numberOfReplicas;
-    }
-
-    public List<ColumnIdent> partitionedBy() {
-        return partitionedBy;
-    }
-
-    public ColumnPolicy columnPolicy() {
-        return columnPolicy;
-    }
-
-    public Settings tableParameters() {
-        return tableParameters;
-    }
-
-    @SuppressWarnings("unchecked")
-    private Map<ColumnIdent, String> getAnalyzers(@Nullable ColumnIdent columnIdent, Map<String, Object> propertiesMap) {
-        MapBuilder<ColumnIdent, String> builder = MapBuilder.newMapBuilder();
-        for (Map.Entry<String, Object> columnEntry : propertiesMap.entrySet()) {
-            Map<String, Object> columnProperties = (Map<String, Object>) columnEntry.getValue();
-            DataType<?> columnDataType = getColumnDataType(columnProperties);
-            ColumnIdent newIdent = columnIdent(columnIdent, columnEntry.getKey());
-            columnProperties = furtherColumnProperties(columnProperties);
-            if (columnDataType.id() == ObjectType.ID
-                || (columnDataType.id() == ArrayType.ID
-                    && ((ArrayType<?>) columnDataType).innerType().id() == ObjectType.ID)) {
-                if (columnProperties.get("properties") != null) {
-                    builder.putAll(getAnalyzers(newIdent, (Map<String, Object>) columnProperties.get("properties")));
-                }
-            }
-            String analyzer = (String) columnProperties.get("analyzer");
-            if (analyzer != null) {
-                builder.put(newIdent, analyzer);
-            }
-        }
-        return builder.map();
-    }
-
-    Map<ColumnIdent, String> analyzers() {
-        Map<String, Object> propertiesMap = Maps.get(mappingMap, "properties");
-        if (propertiesMap == null) {
-            return Map.of();
-        } else {
-            return getAnalyzers(null, propertiesMap);
-        }
-    }
-
-    Set<Operation> supportedOperations() {
-        return supportedOperations;
-    }
-
-    @Nullable
-    public Version versionCreated() {
-        return versionCreated;
-    }
-
-    @Nullable
-    public Version versionUpgraded() {
-        return versionUpgraded;
-    }
-
-    public boolean isClosed() {
-        return closed;
-    }
-
-    /**
-     * Even though referenced marked as "dropped" are excluded from {@link #columns}, when a sub-column
-     * of an object col is dropped, the {@link ObjectType#innerTypes()} still contain those dropped sub-columns.
-     */
-    @SuppressWarnings("unchecked")
-    private DataType<?> removeDroppedColsFromInnerTypes(Map<String, Object> columnProperties, DataType<?> type) {
-        if (type.id() == ObjectType.ID) {
-            ObjectType.Builder builder = new ObjectType.Builder();
-            for (var entry : ((ObjectType) type).innerTypes().entrySet()) {
-                Map<String, Object> innerProps =
-                    ((Map<String, Object>)((Map<String, Object>) columnProperties.get("properties"))
-                        .get(entry.getKey()));
-                if (innerProps.get("dropped") == null || (Boolean) innerProps.get("dropped") == false) {
-                    builder.setInnerType(entry.getKey(), removeDroppedColsFromInnerTypes(innerProps, entry.getValue()));
-                }
-            }
-            return builder.build();
-        } else if (type.id() == ArrayType.ID) {
-            Map<String, Object> innerProps = (Map<String, Object>) columnProperties.get("inner");
-            if (innerProps == null) {
-                innerProps = columnProperties;
-            }
-            var newInnerType = removeDroppedColsFromInnerTypes(innerProps, ((ArrayType<?>) type).innerType());
-            return new ArrayType<>(newInnerType);
-        }
-        return type;
-    }
-}
diff --git a/server/src/main/java/io/crate/metadata/doc/DocTableInfo.java b/server/src/main/java/io/crate/metadata/doc/DocTableInfo.java
index 3fb09bdfcc..2710723e2f 100644
--- a/server/src/main/java/io/crate/metadata/doc/DocTableInfo.java
+++ b/server/src/main/java/io/crate/metadata/doc/DocTableInfo.java
@@ -30,8 +30,10 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.function.Function;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import org.elasticsearch.Version;
@@ -42,6 +44,7 @@ import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import io.crate.analyze.WhereClause;
+import io.crate.common.collections.Lists2;
 import io.crate.exceptions.ColumnUnknownException;
 import io.crate.expression.symbol.DynamicReference;
 import io.crate.expression.symbol.Symbol;
@@ -120,6 +123,7 @@ import io.crate.sql.tree.ColumnPolicy;
  */
 public class DocTableInfo implements TableInfo, ShardedTable, StoredTable {
 
+
     private final Collection<Reference> columns;
     private final Set<Reference> droppedColumns;
     private final List<GeneratedReference> generatedColumns;
@@ -157,13 +161,9 @@ public class DocTableInfo implements TableInfo, ShardedTable, StoredTable {
     private final ColumnPolicy columnPolicy;
 
     public DocTableInfo(RelationName ident,
-                        Collection<Reference> columns,
-                        Set<Reference> droppedColumns,
-                        List<Reference> partitionedByColumns,
-                        List<GeneratedReference> generatedColumns,
+                        Map<ColumnIdent, Reference> references,
                         Collection<ColumnIdent> notNullColumns,
                         Map<ColumnIdent, IndexReference> indexColumns,
-                        Map<ColumnIdent, Reference> references,
                         Map<ColumnIdent, String> analyzers,
                         @Nullable String pkConstraintName,
                         List<ColumnIdent> primaryKeys,
@@ -182,17 +182,30 @@ public class DocTableInfo implements TableInfo, ShardedTable, StoredTable {
                         @Nullable Version versionUpgraded,
                         boolean closed,
                         Set<Operation> supportedOperations) {
-        assert (partitionedBy.size() ==
-                partitionedByColumns.size()) : "partitionedBy and partitionedByColumns must have same amount of items in list";
-        this.columns = columns;
-        this.droppedColumns = droppedColumns;
-        this.partitionedByColumns = partitionedByColumns;
-        this.generatedColumns = generatedColumns;
+        this.droppedColumns = references.values().stream()
+            .filter(Reference::isDropped)
+            .collect(Collectors.toSet());
+        this.references = references.entrySet().stream()
+            .filter(entry -> !entry.getValue().isDropped())
+            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
+        this.columns = this.references.values().stream()
+            .filter(r -> !r.column().isSystemColumn())
+            .filter(r -> r.column().isRoot())
+            .sorted(Reference.CMP_BY_POSITION_THEN_NAME)
+            .toList();
+        this.partitionedByColumns = Lists2.map(partitionedBy, x -> {
+            Reference ref = this.references.get(x);
+            assert ref != null : "Column in `partitionedBy` must be present in `references`";
+            return ref;
+        });
+        this.generatedColumns = this.references.values().stream()
+            .filter(r -> r instanceof GeneratedReference)
+            .map(r -> (GeneratedReference) r)
+            .toList();
         this.notNullColumns = notNullColumns;
         this.indexColumns = indexColumns;
-        this.references = references;
         leafNamesByOid = new HashMap<>();
-        Stream.concat(Stream.concat(references.values().stream(), indexColumns.values().stream()), droppedColumns.stream())
+        Stream.concat(Stream.concat(this.references.values().stream(), indexColumns.values().stream()), droppedColumns.stream())
             .filter(r -> r.oid() != COLUMN_OID_UNASSIGNED)
             .forEach(r -> leafNamesByOid.put(Long.toString(r.oid()), r.column().leafName()));
         this.analyzers = analyzers;
@@ -215,8 +228,8 @@ public class DocTableInfo implements TableInfo, ShardedTable, StoredTable {
         this.versionUpgraded = versionUpgraded;
         this.closed = closed;
         this.supportedOperations = supportedOperations;
-        this.docColumn = new TableColumn(DocSysColumns.DOC, references);
-        this.defaultExpressionColumns = references.values()
+        this.docColumn = new TableColumn(DocSysColumns.DOC, this.references);
+        this.defaultExpressionColumns = this.references.values()
             .stream()
             .filter(r -> r.defaultExpression() != null)
             .toList();
@@ -393,7 +406,9 @@ public class DocTableInfo implements TableInfo, ShardedTable, StoredTable {
 
     @Override
     public Iterator<Reference> iterator() {
-        return references.values().iterator();
+        return references.values().stream()
+            .sorted(Reference.CMP_BY_POSITION_THEN_NAME)
+            .iterator();
     }
 
     /**
diff --git a/server/src/main/java/io/crate/metadata/doc/DocTableInfoFactory.java b/server/src/main/java/io/crate/metadata/doc/DocTableInfoFactory.java
index 5deea38a09..74c40a42bf 100644
--- a/server/src/main/java/io/crate/metadata/doc/DocTableInfoFactory.java
+++ b/server/src/main/java/io/crate/metadata/doc/DocTableInfoFactory.java
@@ -21,15 +21,18 @@
 
 package io.crate.metadata.doc;
 
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Objects;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -37,6 +40,7 @@ import org.elasticsearch.Version;
 import org.elasticsearch.action.support.IndicesOptions;
 import org.elasticsearch.cluster.ClusterState;
 import org.elasticsearch.cluster.metadata.IndexMetadata;
+import org.elasticsearch.cluster.metadata.IndexMetadata.State;
 import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
 import org.elasticsearch.cluster.metadata.IndexTemplateMetadata;
 import org.elasticsearch.cluster.metadata.MappingMetadata;
@@ -44,7 +48,11 @@ import org.elasticsearch.cluster.metadata.Metadata;
 import org.elasticsearch.common.inject.Inject;
 import org.elasticsearch.common.inject.Singleton;
 import org.elasticsearch.common.settings.Settings;
+import org.elasticsearch.common.xcontent.XContentType;
 import org.elasticsearch.index.IndexNotFoundException;
+import org.elasticsearch.index.mapper.BitStringFieldMapper;
+import org.elasticsearch.index.mapper.DateFieldMapper;
+import org.elasticsearch.index.mapper.KeywordFieldMapper;
 import org.elasticsearch.index.mapper.TypeParsers;
 import org.jetbrains.annotations.Nullable;
 
@@ -52,32 +60,40 @@ import io.crate.analyze.NumberOfReplicas;
 import io.crate.analyze.ParamTypeHints;
 import io.crate.analyze.expressions.ExpressionAnalysisContext;
 import io.crate.analyze.expressions.ExpressionAnalyzer;
+import io.crate.analyze.expressions.TableReferenceResolver;
 import io.crate.analyze.relations.FieldProvider;
 import io.crate.common.Booleans;
 import io.crate.common.collections.Maps;
 import io.crate.exceptions.RelationUnknown;
-import io.crate.exceptions.UnhandledServerException;
 import io.crate.expression.symbol.Symbol;
 import io.crate.metadata.ColumnIdent;
 import io.crate.metadata.CoordinatorTxnCtx;
-import io.crate.metadata.IndexParts;
+import io.crate.metadata.GeneratedReference;
+import io.crate.metadata.GeoReference;
 import io.crate.metadata.IndexReference;
 import io.crate.metadata.IndexType;
 import io.crate.metadata.NodeContext;
 import io.crate.metadata.PartitionName;
 import io.crate.metadata.Reference;
+import io.crate.metadata.ReferenceIdent;
 import io.crate.metadata.RelationName;
+import io.crate.metadata.RowGranularity;
 import io.crate.metadata.SimpleReference;
 import io.crate.metadata.table.Operation;
 import io.crate.replication.logical.metadata.PublicationsMetadata;
+import io.crate.server.xcontent.XContentHelper;
 import io.crate.sql.parser.SqlParser;
 import io.crate.sql.tree.CheckConstraint;
 import io.crate.sql.tree.ColumnPolicy;
 import io.crate.types.ArrayType;
+import io.crate.types.BitStringType;
+import io.crate.types.CharacterType;
 import io.crate.types.DataType;
 import io.crate.types.DataTypes;
+import io.crate.types.FloatVectorType;
 import io.crate.types.ObjectType;
 import io.crate.types.StorageSupport;
+import io.crate.types.StringType;
 
 @Singleton
 public class DocTableInfoFactory {
@@ -101,9 +117,12 @@ public class DocTableInfoFactory {
         );
     }
 
-    public DocTableInfo createNew(RelationName relation, Metadata metadata) {
+    public DocTableInfo create(RelationName relation, ClusterState state) {
+        return create(relation, state.metadata());
+    }
+
+    public DocTableInfo create(RelationName relation, Metadata metadata) {
         String templateName = PartitionName.templateName(relation.schema(), relation.name());
-        PublicationsMetadata publicationsMetadata = metadata.custom(PublicationsMetadata.TYPE);
         IndexTemplateMetadata indexTemplateMetadata = metadata.templates().get(templateName);
         Version versionCreated;
         Version versionUpgraded;
@@ -111,11 +130,34 @@ public class DocTableInfoFactory {
         Settings tableParameters;
         IndexMetadata.State state;
         int numberOfShards;
-        String numberOfReplicas;
+        String[] concreteIndices;
+        try {
+            concreteIndices = IndexNameExpressionResolver.concreteIndexNames(
+                metadata,
+                indexTemplateMetadata == null
+                    ? IndicesOptions.strictExpandOpen()
+                    : IndicesOptions.lenientExpandOpen(),
+                relation.indexNameOrAlias()
+            );
+        } catch (IndexNotFoundException e) {
+            throw new RelationUnknown(relation.fqn(), e);
+        }
+        String[] concreteOpenIndices;
+        List<PartitionName> partitions;
         if (indexTemplateMetadata == null) {
             IndexMetadata index = metadata.index(relation.indexNameOrAlias());
             if (index == null) {
-                throw new RelationUnknown(relation);
+                if (concreteIndices.length > 0) {
+                    index = metadata.index(concreteIndices[0]);
+                    LOGGER.info(
+                        "Found indices={} for relation={} without index template. Orphaned partition?",
+                        concreteIndices,
+                        relation
+                    );
+                }
+                if (index == null) {
+                    throw new RelationUnknown(relation);
+                }
             }
             Settings indexSettings = index.getSettings();
             tableParameters = indexSettings;
@@ -125,35 +167,109 @@ public class DocTableInfoFactory {
             MappingMetadata mapping = index.mapping();
             mappingSource = mapping == null ? Map.of() : mapping.sourceAsMap();
             numberOfShards = index.getNumberOfShards();
-            numberOfReplicas = NumberOfReplicas.fromSettings(indexSettings);
+            concreteOpenIndices = concreteIndices;
+            if (concreteIndices.length == 0) {
+                throw new RelationUnknown(relation);
+            }
+            partitions = List.of();
         } else {
+            mappingSource = XContentHelper.toMap(
+                indexTemplateMetadata.mapping().compressedReference(),
+                XContentType.JSON
+            );
+            mappingSource = Maps.getOrDefault(mappingSource, "default", mappingSource);
+            Settings indexSettings = indexTemplateMetadata.settings();
+            tableParameters = indexSettings;
+            versionCreated = indexSettings.getAsVersion(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT);
+            versionUpgraded = null;
+            boolean isClosed = Maps.getOrDefault(
+                Maps.getOrDefault(mappingSource, "_meta", Map.of()), "closed", false);
+            state = isClosed ? State.CLOSE : State.OPEN;
+            numberOfShards = indexSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 5);
+            // We need all concrete open indices, as closed indices must not appear in the routing.
+            concreteOpenIndices = IndexNameExpressionResolver.concreteIndexNames(
+                metadata,
+                IndicesOptions.fromOptions(true, true, true, false, IndicesOptions.strictExpandOpenAndForbidClosed()),
+                relation.indexNameOrAlias()
+            );
+            partitions = new ArrayList<>(concreteIndices.length);
+            for (String indexName : concreteIndices) {
+                partitions.add(PartitionName.fromIndexOrTemplate(indexName));
+            }
+
         }
-        Map<String, Object> metaMap = Maps.getOrDefault(mappingSource, "_meta", Map.of());
-        Map<String, String> generatedColumns = Maps.getOrDefault(metaMap, "generated_columns", Map.of());
-        List<ColumnIdent> partitionedBy = parsePartitionedByStringsList(
+        final String numberOfReplicas = NumberOfReplicas.fromSettings(tableParameters);
+        final Map<String, Object> metaMap = Maps.getOrDefault(mappingSource, "_meta", Map.of());
+        final List<ColumnIdent> partitionedBy = parsePartitionedByStringsList(
             Maps.getOrDefault(metaMap, "partitioned_by", List.of())
         );
         String routing = Maps.get(metaMap, "routing");
         List<ColumnIdent> primaryKeys = getPrimaryKeys(metaMap);
         boolean hasAutoGeneratedPrimaryKey = false;
-        if (primaryKeys == null && routing == null && indexTemplateMetadata == null) {
+        if (primaryKeys.isEmpty() && routing == null && indexTemplateMetadata == null) {
             hasAutoGeneratedPrimaryKey = true;
             primaryKeys = List.of(DocSysColumns.ID);
         }
         Set<ColumnIdent> notNullColumns = getNotNullColumns(metaMap);
-        Map<Object, Object> indicesMap = Maps.getOrDefault(metaMap, "indices", Map.of());
+
+        Map<String, Object> indicesMap = Maps.getOrDefault(metaMap, "indices", Map.of());
         Map<String, Object> properties = Maps.getOrDefault(mappingSource, "properties", Map.of());
-        List<CheckConstraint<Symbol>> checkConstraints = getCheckConstraints(metaMap);
+        Map<ColumnIdent, Reference> references = new HashMap<>();
+        Map<ColumnIdent, IndexReference.Builder> indexColumns = new HashMap<>();
+        Map<ColumnIdent, String> analyzers = new HashMap<>();
 
-        return new DocTableInfo(
+        parseColumns(
             relation,
-            columns,
-            droppedColumns,
-            partitionedByColumns,
-            generatedColumns,
+            null,
+            indicesMap,
             notNullColumns,
+            primaryKeys,
+            partitionedBy,
+            properties,
             indexColumns,
+            analyzers,
+            references
+        );
+        DocSysColumns.forTable(relation, references::put);
+
+        var refExpressionAnalyzer = new ExpressionAnalyzer(
+            systemTransactionContext,
+            nodeCtx,
+            ParamTypeHints.EMPTY,
+            new TableReferenceResolver(references, relation),
+            null
+        );
+        var expressionAnalysisContext = new ExpressionAnalysisContext(systemTransactionContext.sessionSettings());
+        Map<String, String> generatedColumns = Maps.getOrDefault(metaMap, "generated_columns", Map.of());
+        for (Entry<String,String> entry : generatedColumns.entrySet()) {
+            ColumnIdent column = ColumnIdent.fromPath(entry.getKey());
+            String generatedExpressionStr = entry.getValue();
+            Reference reference = references.get(column);
+            Symbol generatedExpression = refExpressionAnalyzer.convert(
+                SqlParser.createExpression(generatedExpressionStr),
+                expressionAnalysisContext
+            ).cast(reference.valueType());
+            assert reference != null : "Column present in generatedColumns must exist";
+            GeneratedReference generatedRef = new GeneratedReference(
+                reference,
+                generatedExpressionStr,
+                generatedExpression
+            );
+            references.put(column, generatedRef);
+        }
+        List<CheckConstraint<Symbol>> checkConstraints = getCheckConstraints(
+            refExpressionAnalyzer,
+            expressionAnalysisContext,
+            metaMap
+        );
+        PublicationsMetadata publicationsMetadata = metadata.custom(PublicationsMetadata.TYPE);
+        ColumnIdent clusteredBy = getClusteredBy(primaryKeys, routing);
+        return new DocTableInfo(
+            relation,
             references,
+            notNullColumns,
+            indexColumns.entrySet().stream()
+                .collect(Collectors.toMap(Entry::getKey, e -> e.getValue().build(references))),
             analyzers,
             Maps.get(metaMap, "pk_constraint_name"),
             primaryKeys,
@@ -172,14 +288,27 @@ public class DocTableInfoFactory {
             versionUpgraded,
             state == IndexMetadata.State.CLOSE,
             Operation.buildFromIndexSettingsAndState(
-                metadata.settings(),
+                tableParameters,
                 state,
                 publicationsMetadata == null ? false : publicationsMetadata.isPublished(relation)
             )
         );
     }
 
-    private List<CheckConstraint<Symbol>> getCheckConstraints(Map<String, Object> metaMap) {
+    private static ColumnIdent getClusteredBy(List<ColumnIdent> primaryKeys, @Nullable String routing) {
+        if (routing != null) {
+            return ColumnIdent.fromPath(routing);
+        }
+        if (primaryKeys.size() == 1) {
+            return primaryKeys.get(0);
+        }
+        return DocSysColumns.ID;
+    }
+
+    private static List<CheckConstraint<Symbol>> getCheckConstraints(
+            ExpressionAnalyzer expressionAnalyzer,
+            ExpressionAnalysisContext expressionAnalysisContext,
+            Map<String, Object> metaMap) {
         Map<String, String> checkConstraints = Maps.get(metaMap, "check_constraints");
         if (checkConstraints == null) {
             return List.of();
@@ -188,7 +317,10 @@ public class DocTableInfoFactory {
         for (Entry<String,String> entry : checkConstraints.entrySet()) {
             String name = entry.getKey();
             String expressionStr = entry.getValue();
-            Symbol expression = parseExpression(expressionStr);
+            Symbol expression = expressionAnalyzer.convert(
+                SqlParser.createExpression(expressionStr),
+                expressionAnalysisContext
+            );
             var checkConstraint = new CheckConstraint<>(name, null, expression, expressionStr);
             result.add(checkConstraint);
         }
@@ -196,57 +328,163 @@ public class DocTableInfoFactory {
     }
 
     @SuppressWarnings("unchecked")
-    private void parseColumns(@Nullable ColumnIdent parent,
-                             Map<String, Object> properties) {
+    private void parseColumns(RelationName relationName,
+                              @Nullable ColumnIdent parent,
+                              Map<String, Object> indicesMap,
+                              Set<ColumnIdent> notNullColumns,
+                              List<ColumnIdent> primaryKeys,
+                              List<ColumnIdent> partitionedBy,
+                              Map<String, Object> properties,
+                              Map<ColumnIdent, IndexReference.Builder> indexColumns,
+                              Map<ColumnIdent, String> analyzers,
+                              Map<ColumnIdent, Reference> references) {
         for (Entry<String,Object> entry : properties.entrySet()) {
             String columnName = entry.getKey();
             Map<String, Object> columnProperties = (Map<String, Object>) entry.getValue();
-            DataType<?> type = DocIndexMetadata.getColumnDataType(columnProperties);
+            DataType<?> type = getColumnDataType(columnProperties);
             ColumnIdent column = parent == null ? new ColumnIdent(columnName) : parent.getChild(columnName);
+            ReferenceIdent refIdent = new ReferenceIdent(relationName, column);
             columnProperties = innerProperties(columnProperties);
 
+            String analyzer = (String) columnProperties.get("analyzer");
+            if (analyzer != null) {
+                analyzers.put(column, analyzer);
+            }
+
             Symbol defaultExpression = parseExpression(Maps.get(columnProperties, "default_expr"));
-            IndexType indexType = getColumnIndexType(columnProperties);
+            boolean isPartitionColumn = partitionedBy.contains(column);
+            IndexType indexType = isPartitionColumn
+                ? IndexType.PLAIN
+                : getColumnIndexType(columnProperties);
+            RowGranularity granularity = isPartitionColumn
+                ? RowGranularity.PARTITION
+                : RowGranularity.DOC;
 
             StorageSupport<?> storageSupport = type.storageSupportSafe();
             boolean docValuesDefault = storageSupport.getComputedDocValuesDefault(indexType);
-            String docValues = columnProperties.get(TypeParsers.DOC_VALUES).toString();
-            boolean hasDocValues = docValues == null ? docValuesDefault : Booleans.parseBoolean(docValues);
+            Object docValues = columnProperties.get(TypeParsers.DOC_VALUES);
+            boolean hasDocValues = docValues == null
+                ? docValuesDefault
+                : Booleans.parseBoolean(docValues.toString());
 
             int position = Maps.getOrDefault(columnProperties, "position", 0);
             Number oidNum = Maps.getOrDefault(columnProperties, "oid", Metadata.COLUMN_OID_UNASSIGNED);
             long oid = oidNum.longValue();
             DataType<?> elementType = ArrayType.unnest(type);
 
+            boolean isDropped = Maps.getOrDefault(columnProperties, "dropped", false);
+            boolean nullable = !notNullColumns.contains(column) && !primaryKeys.contains(column);
+
             if (elementType.equals(DataTypes.GEO_SHAPE)) {
                 String geoTree = (String) columnProperties.get("tree");
                 String precision = (String) columnProperties.get("precision");
                 Integer treeLevels = (Integer) columnProperties.get("tree_levels");
                 Double distanceErrorPct = (Double) columnProperties.get("distance_error_pct");
+                Reference ref = new GeoReference(
+                    refIdent,
+                    type,
+                    ColumnPolicy.DYNAMIC,
+                    IndexType.PLAIN,
+                    nullable,
+                    position,
+                    oid,
+                    isDropped,
+                    defaultExpression,
+                    geoTree,
+                    precision,
+                    treeLevels,
+                    distanceErrorPct
+                );
+                references.put(column, ref);
             } else if (elementType.id() == ObjectType.ID) {
                 ColumnPolicy columnPolicy = ColumnPolicy.fromMappingValue(columnProperties.get("dynamic"));
+
+                Reference ref = new SimpleReference(
+                    refIdent,
+                    granularity,
+                    type,
+                    columnPolicy,
+                    indexType,
+                    nullable,
+                    hasDocValues,
+                    position,
+                    oid,
+                    isDropped,
+                    defaultExpression
+                );
+                references.put(column, ref);
+
+                Map<String, Object> nestedProperties = Maps.get(columnProperties, "properties");
+                if (nestedProperties != null) {
+                    parseColumns(
+                        relationName,
+                        column,
+                        indicesMap,
+                        notNullColumns,
+                        primaryKeys,
+                        partitionedBy,
+                        nestedProperties,
+                        indexColumns,
+                        analyzers,
+                        references
+                    );
+                }
             } else if (type != DataTypes.NOT_SUPPORTED) {
-                // TODO: copy_to
+                List<String> copyToColumns = Maps.get(columnProperties, "copy_to");
+                // TODO: copy_to is deprecated and has to be removed after 5.4
+                // extract columns this column is copied to, needed for indices
+                if (copyToColumns != null) {
+                    for (String copyToColumn : copyToColumns) {
+                        ColumnIdent targetIdent = ColumnIdent.fromPath(copyToColumn);
+                        IndexReference.Builder builder = indexColumns.computeIfAbsent(
+                            targetIdent,
+                            k -> new IndexReference.Builder(refIdent)
+                        );
+                        builder.addColumn(new SimpleReference(
+                            refIdent,
+                            granularity,
+                            type,
+                            ColumnPolicy.DYNAMIC,
+                            indexType,
+                            nullable,
+                            hasDocValues,
+                            position,
+                            oid,
+                            isDropped,
+                            defaultExpression
+                        ));
+                    }
+                }
 
                 var indicesKey = oid == Metadata.COLUMN_OID_UNASSIGNED ? column.fqn() : Long.toString(oid);
                 if (indicesMap.containsKey(indicesKey)) {
                     List<String> sources = Maps.get(columnProperties, "sources");
                     if (sources != null) {
-                        IndexReference.Builder builder = getOrCreateIndexBuilder(newIdent);
+                        IndexReference.Builder builder = indexColumns.computeIfAbsent(
+                            column,
+                            k -> new IndexReference.Builder(refIdent)
+                        );
                         builder.indexType(indexType)
                             .position(position)
                             .oid(oid)
-                            .analyzer((String) columnProperties.get("analyzer"))
+                            .analyzer(analyzer)
                             .sources(sources);
                     }
                 } else {
                     Reference ref = new SimpleReference(
-                        ident,
+                        refIdent,
                         granularity,
                         type,
+                        ColumnPolicy.DYNAMIC,
+                        indexType,
+                        nullable,
+                        hasDocValues,
                         position,
+                        oid,
+                        isDropped,
                         defaultExpression
                     );
+                    references.put(column, ref);
                 }
             }
         }
@@ -328,11 +566,10 @@ public class DocTableInfoFactory {
         return inner == null ? columnProperties : inner;
     }
 
-    @Nullable
     private static List<ColumnIdent> getPrimaryKeys(Map<String, Object> metaMap) {
         Object primaryKeys = metaMap.get("primary_keys");
         if (primaryKeys == null) {
-            return null;
+            return List.of();
         }
         if (primaryKeys instanceof String pkString) {
             return List.of(ColumnIdent.fromPath(pkString));
@@ -344,7 +581,7 @@ public class DocTableInfoFactory {
             }
             return result;
         }
-        return null;
+        return List.of();
     }
 
     private static Set<ColumnIdent> getNotNullColumns(Map<String, Object> metaMap) {
@@ -368,153 +605,76 @@ public class DocTableInfoFactory {
         return List.copyOf(builder);
     }
 
-    public DocTableInfo create(RelationName relation, ClusterState state) {
-        var metadata = state.metadata();
-        PublicationsMetadata publicationsMetadata = metadata.custom(PublicationsMetadata.TYPE);
+    record InnerObjectType(String name, int position, DataType<?> type) {}
 
-        DocIndexMetadata docIndexMetadata;
-        String[] concreteIndices;
-        String[] concreteOpenIndices;
-        String templateName = PartitionName.templateName(relation.schema(), relation.name());
-        if (metadata.templates().containsKey(templateName)) {
-            docIndexMetadata = buildDocIndexMetadataFromTemplate(
-                metadata,
-                publicationsMetadata,
-                relation,
-                templateName
-            );
-            // We need all concrete indices, regardless of their state, for operations such as reopening.
-            concreteIndices = IndexNameExpressionResolver.concreteIndexNames(
-                metadata,
-                IndicesOptions.lenientExpandOpen(),
-                relation.indexNameOrAlias()
-            );
-            // We need all concrete open indices, as closed indices must not appear in the routing.
-            concreteOpenIndices = IndexNameExpressionResolver.concreteIndexNames(
-                metadata,
-                IndicesOptions.fromOptions(true, true, true, false, IndicesOptions.strictExpandOpenAndForbidClosed()),
-                relation.indexNameOrAlias()
-            );
-        } else {
-            try {
-                concreteIndices = IndexNameExpressionResolver.concreteIndexNames(
-                    metadata, IndicesOptions.strictExpandOpen(), relation.indexNameOrAlias());
-                concreteOpenIndices = concreteIndices;
-                if (concreteIndices.length == 0) {
-                    // no matching index found
-                    throw new RelationUnknown(relation);
-                }
-                docIndexMetadata = buildDocIndexMetadata(metadata, publicationsMetadata, relation, concreteIndices[0]);
-            } catch (IndexNotFoundException ex) {
-                throw new RelationUnknown(relation.fqn(), ex);
-            }
-        }
-        List<PartitionName> partitions = buildPartitions(
-            relation,
-            concreteIndices,
-            docIndexMetadata
-        );
-        return new DocTableInfo(
-            relation,
-            docIndexMetadata.columns(),
-            docIndexMetadata.droppedColumns(),
-            docIndexMetadata.partitionedByColumns(),
-            docIndexMetadata.generatedColumnReferences(),
-            docIndexMetadata.notNullColumns(),
-            docIndexMetadata.indices(),
-            docIndexMetadata.references(),
-            docIndexMetadata.analyzers(),
-            docIndexMetadata.pkConstraintName(),
-            docIndexMetadata.primaryKey(),
-            docIndexMetadata.checkConstraints(),
-            docIndexMetadata.routingCol(),
-            docIndexMetadata.hasAutoGeneratedPrimaryKey(),
-            concreteIndices,
-            concreteOpenIndices,
-            docIndexMetadata.numberOfShards(), docIndexMetadata.numberOfReplicas(),
-            docIndexMetadata.tableParameters(),
-            docIndexMetadata.partitionedBy(),
-            partitions,
-            docIndexMetadata.columnPolicy(),
-            docIndexMetadata.versionCreated(),
-            docIndexMetadata.versionUpgraded(),
-            docIndexMetadata.isClosed(),
-            docIndexMetadata.supportedOperations());
-    }
+    /**
+     * extract dataType from given columnProperties
+     *
+     * @param columnProperties map of String to Object containing column properties
+     * @return dataType of the column with columnProperties
+     */
+    @SuppressWarnings("unchecked")
+    private static DataType<?> getColumnDataType(Map<String, Object> columnProperties) {
+        String typeName = (String) columnProperties.get("type");
 
-    private DocIndexMetadata buildDocIndexMetadata(Metadata metadata,
-                                                   PublicationsMetadata publicationsMetadata,
-                                                   RelationName relation,
-                                                   String concreteIndex) {
-        DocIndexMetadata docIndexMetadata;
-        IndexMetadata indexMetadata = metadata.index(concreteIndex);
-        try {
-            docIndexMetadata = new DocIndexMetadata(
-                nodeCtx,
-                indexMetadata,
-                relation,
-                publicationsMetadata);
-        } catch (Exception e) {
-            throw new UnhandledServerException("Unable to build DocIndexMetadata", e);
-        }
-        try {
-            return docIndexMetadata.build();
-        } catch (Exception e) {
-            try {
-                LOGGER.error(
-                    "Could not build DocIndexMetadata from: {}", indexMetadata.mapping().sourceAsMap());
-            } catch (Exception ignored) {
+        if (typeName == null || ObjectType.NAME.equals(typeName)) {
+            Map<String, Object> innerProperties = (Map<String, Object>) columnProperties.get("properties");
+            if (innerProperties == null) {
+                return Objects.requireNonNullElse(DataTypes.ofMappingName(typeName), DataTypes.NOT_SUPPORTED);
             }
-            throw e;
-        }
-    }
 
-    private DocIndexMetadata buildDocIndexMetadataFromTemplate(Metadata metadata,
-                                                               PublicationsMetadata publicationsMetadata,
-                                                               RelationName relation,
-                                                               String templateName) {
-        IndexTemplateMetadata indexTemplateMetadata = metadata.templates().get(templateName);
-        DocIndexMetadata docIndexMetadata;
-        try {
-            IndexMetadata.Builder builder = new IndexMetadata.Builder(relation.indexNameOrAlias());
-            builder.putMapping(indexTemplateMetadata.mapping().toString());
-
-            Settings.Builder settingsBuilder = Settings.builder()
-                .put(indexTemplateMetadata.settings());
-            if (indexTemplateMetadata.settings().get(IndexMetadata.SETTING_VERSION_CREATED) == null) {
-                settingsBuilder.put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT);
+            List<InnerObjectType> children = new ArrayList<>();
+            for (Map.Entry<String, Object> entry : innerProperties.entrySet()) {
+                Map<String, Object> value = (Map<String, Object>) entry.getValue();
+                boolean isDropped = Maps.getOrDefault(value, "dropped", false);
+                if (!isDropped) {
+                    int position = (int) value.getOrDefault("position", -1);
+                    children.add(new InnerObjectType(entry.getKey(), position, getColumnDataType(value)));
+                }
             }
-
-            Settings settings = settingsBuilder.build();
-            builder.settings(settings);
-            builder.numberOfShards(settings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 5));
-            builder.numberOfReplicas(settings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1));
-            docIndexMetadata = new DocIndexMetadata(nodeCtx, builder.build(), relation, publicationsMetadata);
-        } catch (IOException e) {
-            throw new UnhandledServerException("Unable to build DocIndexMetadata from template", e);
+            children.sort(Comparator.comparingInt(x -> x.position()));
+            ObjectType.Builder builder = ObjectType.builder();
+            for (var child : children) {
+                builder.setInnerType(child.name, child.type);
+            }
+            return builder.build();
         }
-        return docIndexMetadata.build();
-    }
 
-    private static List<PartitionName> buildPartitions(RelationName relation,
-                                                       String[] concreteIndices,
-                                                       DocIndexMetadata md) {
-        if (md.partitionedBy().isEmpty()) {
-            return List.of();
+        if (typeName.equalsIgnoreCase("array")) {
+            Map<String, Object> innerProperties = Maps.get(columnProperties, "inner");
+            DataType<?> innerType = getColumnDataType(innerProperties);
+            return new ArrayType<>(innerType);
         }
-        List<PartitionName> partitions = new ArrayList<>();
-        for (String indexName : concreteIndices) {
-            if (IndexParts.isPartitioned(indexName)) {
-                try {
-                    PartitionName partitionName = PartitionName.fromIndexOrTemplate(indexName);
-                    assert partitionName.relationName().equals(relation) : "ident must equal partitionName";
-                    partitions.add(partitionName);
-                } catch (IllegalArgumentException e) {
-                    // ignore
-                    LOGGER.warn(String.format(Locale.ENGLISH, "Cannot build partition %s of index %s", indexName, relation.indexNameOrAlias()));
+
+        return switch (typeName.toLowerCase(Locale.ENGLISH)) {
+            case DateFieldMapper.CONTENT_TYPE -> {
+                Boolean ignoreTimezone = (Boolean) columnProperties.get("ignore_timezone");
+                if (ignoreTimezone != null && ignoreTimezone) {
+                    yield DataTypes.TIMESTAMP;
+                } else {
+                    yield DataTypes.TIMESTAMPZ;
                 }
             }
-        }
-        return partitions;
+            case KeywordFieldMapper.CONTENT_TYPE -> {
+                Integer lengthLimit = (Integer) columnProperties.get("length_limit");
+                var blankPadding = columnProperties.get("blank_padding");
+                if (blankPadding != null && (Boolean) blankPadding) {
+                    yield new CharacterType(lengthLimit);
+                }
+                yield lengthLimit != null
+                    ? StringType.of(lengthLimit)
+                    : DataTypes.STRING;
+            }
+            case BitStringFieldMapper.CONTENT_TYPE -> {
+                Integer length = (Integer) columnProperties.get("length");
+                assert length != null : "Length is required for bit string type";
+                yield new BitStringType(length);
+            }
+            case FloatVectorType.NAME -> {
+                Integer dimensions = (Integer) columnProperties.get("dimensions");
+                yield new FloatVectorType(dimensions);
+            }
+            default -> Objects.requireNonNullElse(DataTypes.ofMappingName(typeName), DataTypes.NOT_SUPPORTED);
+        };
     }
 }
diff --git a/server/src/main/java/io/crate/metadata/upgrade/IndexTemplateUpgrader.java b/server/src/main/java/io/crate/metadata/upgrade/IndexTemplateUpgrader.java
index 1dbe64752e..24574e6e91 100644
--- a/server/src/main/java/io/crate/metadata/upgrade/IndexTemplateUpgrader.java
+++ b/server/src/main/java/io/crate/metadata/upgrade/IndexTemplateUpgrader.java
@@ -21,7 +21,6 @@
 
 package io.crate.metadata.upgrade;
 
-import static io.crate.metadata.doc.DocIndexMetadata.furtherColumnProperties;
 import static org.elasticsearch.common.settings.AbstractScopedSettings.ARCHIVED_SETTINGS_PREFIX;
 import static org.elasticsearch.common.settings.IndexScopedSettings.DEFAULT_SCOPED_SETTINGS;
 
@@ -145,7 +144,7 @@ public class IndexTemplateUpgrader implements UnaryOperator<Map<String, IndexTem
         for (var e : properties.entrySet()) {
             String name = parentName + e.getKey();
             Map<String, Object> columnProperties = (Map<String, Object>) e.getValue();
-            columnProperties = furtherColumnProperties(columnProperties);
+            columnProperties = Maps.getOrDefault(columnProperties, "inner", columnProperties);
             Integer position = (Integer) columnProperties.get("position");
             if (position == null || takenPositions.contains(position)) {
                 columnPositionResolver.addColumnToReposition(name,
diff --git a/server/src/main/java/io/crate/planner/operators/HashJoin.java b/server/src/main/java/io/crate/planner/operators/HashJoin.java
index 017375b106..e2fc0d6e40 100644
--- a/server/src/main/java/io/crate/planner/operators/HashJoin.java
+++ b/server/src/main/java/io/crate/planner/operators/HashJoin.java
@@ -177,8 +177,8 @@ public class HashJoin extends AbstractJoinPlan {
             InputColumns.create(lhsHashSymbols, new InputColumns.SourceSymbols(leftOutputs)),
             InputColumns.create(rhsHashSymbols, new InputColumns.SourceSymbols(rightOutputs)),
             Symbols.typeView(leftOutputs),
-            lhStats.estimateSizeForColumns(leftOutputs),
-            lhStats.numDocs());
+            lhStats.estimateSizeForColumns(leftOutputs)
+        );
         return new Join(
             joinPhase,
             leftExecutionPlan,
diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataMappingService.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataMappingService.java
index df04a15cb5..32c3a41f26 100644
--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataMappingService.java
+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataMappingService.java
@@ -19,7 +19,6 @@
 
 package org.elasticsearch.cluster.metadata;
 
-import static io.crate.metadata.doc.DocIndexMetadata.furtherColumnProperties;
 import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;
 
 import java.util.ArrayList;
@@ -28,8 +27,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-import org.jetbrains.annotations.Nullable;
-
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.message.ParameterizedMessage;
@@ -52,6 +49,7 @@ import org.elasticsearch.index.mapper.DocumentMapper;
 import org.elasticsearch.index.mapper.MapperService;
 import org.elasticsearch.index.mapper.MapperService.MergeReason;
 import org.elasticsearch.indices.IndicesService;
+import org.jetbrains.annotations.Nullable;
 
 import io.crate.common.annotations.VisibleForTesting;
 import io.crate.common.collections.Maps;
@@ -413,8 +411,8 @@ public class MetadataMappingService {
             if (templateColumnProperties == null) {
                 templateColumnProperties = Map.of();
             }
-            templateColumnProperties = furtherColumnProperties(templateColumnProperties);
-            indexColumnProperties = furtherColumnProperties(indexColumnProperties);
+            templateColumnProperties = Maps.getOrDefault(templateColumnProperties, "inner", templateColumnProperties);
+            indexColumnProperties = Maps.getOrDefault(indexColumnProperties, "inner", indexColumnProperties);
 
             Integer templateChildPosition = (Integer) templateColumnProperties.get("position");
             assert templateColumnProperties.containsKey("position") && templateChildPosition != null : "the template mapping is missing column positions";
diff --git a/server/src/test/java/io/crate/expression/predicate/NotPredicateTest.java b/server/src/test/java/io/crate/expression/predicate/NotPredicateTest.java
index 96b1aa8923..98c7eab39d 100644
--- a/server/src/test/java/io/crate/expression/predicate/NotPredicateTest.java
+++ b/server/src/test/java/io/crate/expression/predicate/NotPredicateTest.java
@@ -23,11 +23,16 @@ package io.crate.expression.predicate;
 
 import static io.crate.testing.Asserts.isFunction;
 import static io.crate.testing.Asserts.isLiteral;
+import static org.assertj.core.api.Assertions.assertThat;
 
+import java.util.List;
+
+import org.elasticsearch.Version;
 import org.junit.Test;
 
 import io.crate.expression.scalar.ScalarTestCase;
 import io.crate.expression.symbol.Literal;
+import io.crate.testing.QueryTester;
 import io.crate.types.DataTypes;
 
 public class NotPredicateTest extends ScalarTestCase {
@@ -51,4 +56,25 @@ public class NotPredicateTest extends ScalarTestCase {
     public void testEvaluate() throws Exception {
         assertEvaluate("not name = 'foo'", false, Literal.of("foo"));
     }
+
+    @Test
+    public void test_not_on_case_uses_strict_3vl() throws Exception {
+        QueryTester.Builder builder = new QueryTester.Builder(
+            createTempDir(),
+            THREAD_POOL,
+            clusterService,
+            Version.CURRENT,
+            "create table tbl (x int)"
+        );
+        builder.indexValue("x", null);
+        builder.indexValue("x", 2);
+
+        try (var tester = builder.build()) {
+            List<Object> result = tester.runQuery("x", "(case when true then 2 else x end) != 1");
+            assertThat(result).containsExactly(null, 2);
+
+            result = tester.runQuery("x", "(case when true then 2 else x end) != 2");
+            assertThat(result).isEmpty();
+        }
+    }
 }
diff --git a/server/src/test/java/io/crate/integrationtests/TransportSQLActionTest.java b/server/src/test/java/io/crate/integrationtests/TransportSQLActionTest.java
index 0c0162cc09..611fbc3e66 100644
--- a/server/src/test/java/io/crate/integrationtests/TransportSQLActionTest.java
+++ b/server/src/test/java/io/crate/integrationtests/TransportSQLActionTest.java
@@ -28,6 +28,7 @@ import static io.crate.testing.Asserts.assertThat;
 import static io.crate.testing.TestingHelpers.printedTable;
 import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
 import static io.netty.handler.codec.http.HttpResponseStatus.NOT_FOUND;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -1609,7 +1610,7 @@ public class TransportSQLActionTest extends IntegTestCase {
         assertThat(response).hasRowCount(1L);
 
         execute("SELECT b, i FROM t WHERE NOT (coalesce(b, false) = true AND i IS NULL)");
-        assertThat(response).hasRowCount(2L);
+        assertThat(response).hasRowCount(3L);
     }
 
     @Test
diff --git a/server/src/test/java/io/crate/lucene/ThreeValuedLogicQueryBuilderTest.java b/server/src/test/java/io/crate/lucene/ThreeValuedLogicQueryBuilderTest.java
index efe3906259..551e38c891 100644
--- a/server/src/test/java/io/crate/lucene/ThreeValuedLogicQueryBuilderTest.java
+++ b/server/src/test/java/io/crate/lucene/ThreeValuedLogicQueryBuilderTest.java
@@ -21,7 +21,7 @@
 
 package io.crate.lucene;
 
-import static io.crate.testing.Asserts.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import org.apache.lucene.search.Query;
 import org.junit.Test;
@@ -31,9 +31,9 @@ public class ThreeValuedLogicQueryBuilderTest extends LuceneQueryBuilderTest {
     @Test
     public void testNotAnyEqWith3vl() {
         assertThat(convert("NOT 10 = ANY(y_array)")).hasToString(
-            "+(+*:* -y_array:[10 TO 10]) +(+*:* -((10::bigint = ANY(y_array)) IS NULL))");
+            "+(+*:* -y_array:[10 TO 10]) #(NOT (10::bigint = ANY(y_array)))");
         assertThat(convert("NOT d = ANY([1,2,3])")).hasToString(
-            "+(+*:* -d:{1.0 2.0 3.0}) +(+*:* -((d = ANY([1.0, 2.0, 3.0])) IS NULL))");
+            "+(+*:* -d:{1.0 2.0 3.0}) #(NOT (d = ANY([1.0, 2.0, 3.0])))");
     }
 
     @Test
diff --git a/server/src/test/java/io/crate/metadata/GeneratedReferenceTest.java b/server/src/test/java/io/crate/metadata/GeneratedReferenceTest.java
index f3015c1ccd..2d94689395 100644
--- a/server/src/test/java/io/crate/metadata/GeneratedReferenceTest.java
+++ b/server/src/test/java/io/crate/metadata/GeneratedReferenceTest.java
@@ -26,7 +26,6 @@ import static io.crate.testing.T3.T1;
 import static io.crate.testing.T3.T1_DEFINITION;
 
 import java.util.Collections;
-import java.util.List;
 
 import org.elasticsearch.common.io.stream.BytesStreamOutput;
 import org.elasticsearch.common.io.stream.StreamInput;
@@ -68,7 +67,6 @@ public class GeneratedReferenceTest extends CrateDummyClusterServiceUnitTest {
         SimpleReference simpleRef = new SimpleReference(referenceIdent, RowGranularity.DOC, StringType.INSTANCE, 1, null);
         Symbol generatedExpression = expressions.normalize(executor.asSymbol(formattedGeneratedExpression));
         GeneratedReference generatedReferenceInfo = new GeneratedReference(simpleRef, formattedGeneratedExpression, generatedExpression);
-        generatedReferenceInfo.referencedReferences(List.of(t1Info.getReference(new ColumnIdent("a"))));
 
         BytesStreamOutput out = new BytesStreamOutput();
         Reference.toStream(out, generatedReferenceInfo);
diff --git a/server/src/test/java/io/crate/metadata/doc/DocIndexMetadataTest.java b/server/src/test/java/io/crate/metadata/doc/DocIndexMetadataTest.java
index 78f9d1b9d7..ea2abc8dbf 100644
--- a/server/src/test/java/io/crate/metadata/doc/DocIndexMetadataTest.java
+++ b/server/src/test/java/io/crate/metadata/doc/DocIndexMetadataTest.java
@@ -26,6 +26,7 @@ import static io.crate.testing.Asserts.isLiteral;
 import static io.crate.testing.Asserts.isReference;
 import static io.crate.testing.TestingHelpers.createNodeContext;
 import static java.util.Collections.emptyMap;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 import java.io.IOException;
@@ -37,9 +38,11 @@ import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
 import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
 
 import org.elasticsearch.cluster.metadata.IndexMetadata;
 import org.elasticsearch.cluster.metadata.MappingMetadata;
+import org.elasticsearch.cluster.metadata.Metadata;
 import org.elasticsearch.common.bytes.BytesReference;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.xcontent.XContentBuilder;
@@ -58,13 +61,11 @@ import io.crate.analyze.BoundCreateTable;
 import io.crate.analyze.CreateTableStatementAnalyzer;
 import io.crate.analyze.NumberOfShards;
 import io.crate.analyze.ParamTypeHints;
-import io.crate.common.collections.Lists2;
 import io.crate.data.Row;
 import io.crate.expression.scalar.cast.ImplicitCastFunction;
 import io.crate.expression.symbol.Function;
 import io.crate.expression.symbol.SymbolType;
 import io.crate.expression.symbol.format.Style;
-import io.crate.expression.udf.UserDefinedFunctionService;
 import io.crate.metadata.ColumnIdent;
 import io.crate.metadata.CoordinatorTxnCtx;
 import io.crate.metadata.FulltextAnalyzerResolver;
@@ -76,7 +77,6 @@ import io.crate.metadata.Reference;
 import io.crate.metadata.RelationName;
 import io.crate.metadata.Schemas;
 import io.crate.metadata.settings.CoordinatorSessionSettings;
-import io.crate.metadata.view.ViewInfoFactory;
 import io.crate.planner.operators.SubQueryResults;
 import io.crate.server.xcontent.XContentHelper;
 import io.crate.sql.parser.SqlParser;
@@ -96,8 +96,8 @@ import io.crate.types.StringType;
 // @formatter:off
 public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
 
-    private UserDefinedFunctionService udfService;
     private NodeContext nodeCtx;
+    private DocTableInfoFactory docTableFactory;
 
     private IndexMetadata getIndexMetadata(String indexName,
                                            XContentBuilder builder) throws IOException {
@@ -115,14 +115,18 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
         return mdBuilder.build();
     }
 
-    private DocIndexMetadata newMeta(IndexMetadata metadata, String name) throws IOException {
-        return new DocIndexMetadata(nodeCtx, metadata, new RelationName(Schemas.DOC_SCHEMA_NAME, name), null).build();
+    private DocTableInfo newTable(IndexMetadata indexMetadata, String name) throws IOException {
+        RelationName relation = new RelationName(Schemas.DOC_SCHEMA_NAME, name);
+        Metadata metadata = Metadata.builder()
+            .put(indexMetadata, true)
+            .build();
+        return docTableFactory.create(relation, metadata);
     }
 
     @Before
-    public void setupUdfService() {
+    public void setupNodeCtx() {
         nodeCtx = createNodeContext();
-        udfService = new UserDefinedFunctionService(clusterService, new DocTableInfoFactory(nodeCtx), nodeCtx);
+        docTableFactory = new DocTableInfoFactory(nodeCtx);
     }
 
     @Test
@@ -152,9 +156,9 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject();
 
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
-        Reference reference = md.references().get(new ColumnIdent("person", Arrays.asList("addresses", "city")));
+        Reference reference = table.getReference(new ColumnIdent("person", Arrays.asList("addresses", "city")));
         assertThat(reference).isNotNull();
     }
 
@@ -213,13 +217,13 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
-        assertThat(md.columns()).hasSize(4);
-        assertThat(md.references()).hasSize(20);
-        assertThat(md.references().get(new ColumnIdent("implicit_dynamic")).columnPolicy()).isEqualTo(ColumnPolicy.DYNAMIC);
-        assertThat(md.references().get(new ColumnIdent("explicit_dynamic")).columnPolicy()).isEqualTo(ColumnPolicy.DYNAMIC);
-        assertThat(md.references().get(new ColumnIdent("ignored")).columnPolicy()).isEqualTo(ColumnPolicy.IGNORED);
-        assertThat(md.references().get(new ColumnIdent("strict")).columnPolicy()).isEqualTo(ColumnPolicy.STRICT);
+        DocTableInfo table = newTable(metadata, "test1");
+        assertThat(table.columns()).hasSize(4);
+        assertThat(table).hasSize(20);
+        assertThat(table.getReference(new ColumnIdent("implicit_dynamic")).columnPolicy()).isEqualTo(ColumnPolicy.DYNAMIC);
+        assertThat(table.getReference(new ColumnIdent("explicit_dynamic")).columnPolicy()).isEqualTo(ColumnPolicy.DYNAMIC);
+        assertThat(table.getReference(new ColumnIdent("ignored")).columnPolicy()).isEqualTo(ColumnPolicy.IGNORED);
+        assertThat(table.getReference(new ColumnIdent("strict")).columnPolicy()).isEqualTo(ColumnPolicy.STRICT);
     }
 
     @Test
@@ -297,57 +301,60 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
         // @formatter:on
 
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
-        assertThat(md.columns()).hasSize(11);
-        assertThat(md.references()).hasSize(23);
+        assertThat(table.columns()).hasSize(11);
+        assertThat(table).hasSize(23);
 
-        Reference birthday = md.references().get(new ColumnIdent("person", "birthday"));
+        Reference birthday = table.getReference(new ColumnIdent("person", "birthday"));
         assertThat(birthday.valueType()).isEqualTo(DataTypes.TIMESTAMPZ);
         assertThat(birthday.indexType()).isEqualTo(IndexType.PLAIN);
         assertThat(birthday.defaultExpression()).isNull();
 
-        Reference integerIndexed = md.references().get(new ColumnIdent("integerIndexed"));
+        Reference integerIndexed = table.getReference(new ColumnIdent("integerIndexed"));
         assertThat(integerIndexed.indexType()).isEqualTo(IndexType.PLAIN);
         assertThat(integerIndexed.defaultExpression()).isNull();
 
-        Reference integerIndexedBWC = md.references().get(new ColumnIdent("integerIndexedBWC"));
+        Reference integerIndexedBWC = table.getReference(new ColumnIdent("integerIndexedBWC"));
         assertThat(integerIndexedBWC.indexType()).isEqualTo(IndexType.PLAIN);
         assertThat(integerIndexedBWC.defaultExpression()).isNull();
 
-        Reference integerNotIndexed = md.references().get(new ColumnIdent("integerNotIndexed"));
+        Reference integerNotIndexed = table.getReference(new ColumnIdent("integerNotIndexed"));
         assertThat(integerNotIndexed.indexType()).isEqualTo(IndexType.NONE);
         assertThat(integerNotIndexed.defaultExpression()).isNull();
 
-        Reference integerNotIndexedBWC = md.references().get(new ColumnIdent("integerNotIndexedBWC"));
+        Reference integerNotIndexedBWC = table.getReference(new ColumnIdent("integerNotIndexedBWC"));
         assertThat(integerNotIndexedBWC.indexType()).isEqualTo(IndexType.NONE);
         assertThat(integerNotIndexedBWC.defaultExpression()).isNull();
 
-        Reference stringNotIndexed = md.references().get(new ColumnIdent("stringNotIndexed"));
+        Reference stringNotIndexed = table.getReference(new ColumnIdent("stringNotIndexed"));
         assertThat(stringNotIndexed.indexType()).isEqualTo(IndexType.NONE);
         assertThat(stringNotIndexed.defaultExpression()).isNull();
 
-        Reference stringNotIndexedBWC = md.references().get(new ColumnIdent("stringNotIndexedBWC"));
+        Reference stringNotIndexedBWC = table.getReference(new ColumnIdent("stringNotIndexedBWC"));
         assertThat(stringNotIndexedBWC.indexType()).isEqualTo(IndexType.NONE);
         assertThat(stringNotIndexedBWC.defaultExpression()).isNull();
 
-        Reference stringNotAnalyzed = md.references().get(new ColumnIdent("stringNotAnalyzed"));
+        Reference stringNotAnalyzed = table.getReference(new ColumnIdent("stringNotAnalyzed"));
         assertThat(stringNotAnalyzed.indexType()).isEqualTo(IndexType.PLAIN);
         assertThat(stringNotAnalyzed.defaultExpression()).isNull();
 
-        Reference stringNotAnalyzedBWC = md.references().get(new ColumnIdent("stringNotAnalyzedBWC"));
+        Reference stringNotAnalyzedBWC = table.getReference(new ColumnIdent("stringNotAnalyzedBWC"));
         assertThat(stringNotAnalyzedBWC.indexType()).isEqualTo(IndexType.PLAIN);
         assertThat(stringNotAnalyzedBWC.defaultExpression()).isNull();
 
-        Reference stringAnalyzed = md.references().get(new ColumnIdent("stringAnalyzed"));
+        Reference stringAnalyzed = table.getReference(new ColumnIdent("stringAnalyzed"));
         assertThat(stringAnalyzed.indexType()).isEqualTo(IndexType.FULLTEXT);
         assertThat(stringAnalyzed.defaultExpression()).isNull();
 
-        Reference stringAnalyzedBWC = md.references().get(new ColumnIdent("stringAnalyzedBWC"));
+        Reference stringAnalyzedBWC = table.getReference(new ColumnIdent("stringAnalyzedBWC"));
         assertThat(stringAnalyzedBWC.indexType()).isEqualTo(IndexType.FULLTEXT);
         assertThat(stringAnalyzedBWC.defaultExpression()).isNull();
 
-        assertThat(Lists2.map(md.references().values(), r -> r.column().fqn())).containsExactlyInAnyOrder(
+        List<String> allRefNames = StreamSupport.stream(table.spliterator(), false)
+            .map(r -> r.column().fqn())
+            .toList();
+        assertThat(allRefNames).containsExactlyInAnyOrder(
             "_doc", "_fetchid", "_id", "_raw", "_score", "_uid", "_version", "_docid", "_seq_no",
             "_primary_term", "integerIndexed", "integerIndexedBWC", "integerNotIndexed", "integerNotIndexedBWC",
             "person", "person.birthday", "person.first_name",
@@ -409,44 +416,47 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
         // @formatter:on
 
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
-        assertThat(md.columns()).hasSize(7);
-        assertThat(md.references()).hasSize(17);
+        assertThat(table.columns()).hasSize(7);
+        assertThat(table).hasSize(17);
 
-        Reference birthday = md.references().get(new ColumnIdent("birthday"));
+        Reference birthday = table.getReference(new ColumnIdent("birthday"));
         assertThat(birthday.valueType()).isEqualTo(DataTypes.TIMESTAMPZ);
         assertThat(birthday.defaultExpression())
             .isFunction("current_timestamp", List.of(DataTypes.INTEGER));
 
-        Reference integerIndexed = md.references().get(new ColumnIdent("integerIndexed"));
+        Reference integerIndexed = table.getReference(new ColumnIdent("integerIndexed"));
         assertThat(integerIndexed.indexType()).isEqualTo(IndexType.PLAIN);
         assertThat(integerIndexed.defaultExpression()).isLiteral(1);
 
 
-        Reference integerNotIndexed = md.references().get(new ColumnIdent("integerNotIndexed"));
+        Reference integerNotIndexed = table.getReference(new ColumnIdent("integerNotIndexed"));
         assertThat(integerNotIndexed.indexType()).isEqualTo(IndexType.NONE);
         assertThat(integerNotIndexed.defaultExpression()).isLiteral(1);
 
-        Reference stringNotIndexed = md.references().get(new ColumnIdent("stringNotIndexed"));
+        Reference stringNotIndexed = table.getReference(new ColumnIdent("stringNotIndexed"));
         assertThat(stringNotIndexed.indexType()).isEqualTo(IndexType.NONE);
         assertThat(stringNotIndexed.defaultExpression()).isLiteral("default");
 
-        Reference stringNotAnalyzed = md.references().get(new ColumnIdent("stringNotAnalyzed"));
+        Reference stringNotAnalyzed = table.getReference(new ColumnIdent("stringNotAnalyzed"));
         assertThat(stringNotAnalyzed.indexType()).isEqualTo(IndexType.PLAIN);
         assertThat(stringNotAnalyzed.defaultExpression()).isLiteral("default");
 
-        Reference stringAnalyzed = md.references().get(new ColumnIdent("stringAnalyzed"));
+        Reference stringAnalyzed = table.getReference(new ColumnIdent("stringAnalyzed"));
         assertThat(stringAnalyzed.indexType()).isEqualTo(IndexType.FULLTEXT);
         assertThat(stringAnalyzed.defaultExpression()).isLiteral("default");
 
-        Reference integerWithCast = md.references().get(new ColumnIdent("integerWithCast"));
+        Reference integerWithCast = table.getReference(new ColumnIdent("integerWithCast"));
         assertThat(integerWithCast.indexType()).isEqualTo(IndexType.PLAIN);
         assertThat(integerWithCast.defaultExpression().valueType()).isEqualTo(DataTypes.INTEGER);
         assertThat(integerWithCast.defaultExpression().symbolType()).isEqualTo(SymbolType.FUNCTION);
         assertThat(((Function) integerWithCast.defaultExpression()).name()).isEqualTo(ImplicitCastFunction.NAME);
 
-        assertThat(Lists2.map(md.references().values(), r -> r.column().fqn())).containsExactlyInAnyOrder(
+        List<String> allRefNames = StreamSupport.stream(table.spliterator(), false)
+            .map(r -> r.column().fqn())
+            .toList();
+        assertThat(allRefNames).containsExactlyInAnyOrder(
             "_raw", "_doc", "_seq_no", "_version", "_id", "_uid",
             "_score", "_fetchid", "_primary_term", "_docid",
             "birthday", "integerIndexed", "integerNotIndexed", "integerWithCast",
@@ -513,16 +523,16 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject();
         // @formatter:on
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
-        assertThat(md.columns()).hasSize(6);
-        assertThat(md.references()).hasSize(19);
-        assertThat(md.partitionedByColumns()).hasSize(1);
-        assertThat(md.partitionedByColumns().get(0).valueType()).isEqualTo(DataTypes.TIMESTAMPZ);
-        assertThat(md.partitionedByColumns().get(0).column().fqn()).isEqualTo("datum");
+        assertThat(table.columns()).hasSize(6);
+        assertThat(table).hasSize(19);
+        assertThat(table.partitionedByColumns()).hasSize(1);
+        assertThat(table.partitionedByColumns().get(0).valueType()).isEqualTo(DataTypes.TIMESTAMPZ);
+        assertThat(table.partitionedByColumns().get(0).column().fqn()).isEqualTo("datum");
 
-        assertThat(md.partitionedBy()).hasSize(1);
-        assertThat(md.partitionedBy().get(0)).isEqualTo(ColumnIdent.fromPath("datum"));
+        assertThat(table.partitionedBy()).hasSize(1);
+        assertThat(table.partitionedBy().get(0)).isEqualTo(ColumnIdent.fromPath("datum"));
     }
 
     @Test
@@ -548,12 +558,12 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
         // partitioned by column is not added twice
-        assertThat(md.columns()).hasSize(2);
-        assertThat(md.references()).hasSize(12);
-        assertThat(md.partitionedByColumns()).hasSize(1);
+        assertThat(table.columns()).hasSize(2);
+        assertThat(table).hasSize(12);
+        assertThat(table.partitionedByColumns()).hasSize(1);
     }
 
     @Test
@@ -585,12 +595,12 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
         // partitioned by column is not added twice
-        assertThat(md.columns()).hasSize(2);
-        assertThat(md.references()).hasSize(13);
-        assertThat(md.partitionedByColumns()).hasSize(1);
+        assertThat(table.columns()).hasSize(2);
+        assertThat(table).hasSize(13);
+        assertThat(table.partitionedByColumns()).hasSize(1);
     }
 
     private Map<String, Object> sortProperties(Map<String, Object> mappingSource) {
@@ -638,8 +648,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test2", builder);
-        DocIndexMetadata md = newMeta(metadata, "test2");
-        assertThat(md.columns()).isEmpty();
+        DocTableInfo table = newTable(metadata, "test2");
+        assertThat(table.columns()).isEmpty();
     }
 
     @Test
@@ -656,18 +666,17 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
 
-        DocIndexMetadata metadata = newMeta(getIndexMetadata("test", builder), "test");
-        Map<ColumnIdent, Reference> references = metadata.references();
-        Reference id = references.get(new ColumnIdent("_id"));
+        DocTableInfo table = newTable(getIndexMetadata("test", builder), "test");
+        Reference id = table.getReference(new ColumnIdent("_id"));
         assertThat(id).isNotNull();
 
-        Reference version = references.get(new ColumnIdent("_version"));
+        Reference version = table.getReference(new ColumnIdent("_version"));
         assertThat(version).isNotNull();
 
-        Reference score = references.get(new ColumnIdent("_score"));
+        Reference score = table.getReference(new ColumnIdent("_score"));
         assertThat(score).isNotNull();
 
-        Reference docId = references.get(new ColumnIdent("_docid"));
+        Reference docId = table.getReference(new ColumnIdent("_docid"));
         assertThat(docId).isNotNull();
     }
 
@@ -704,10 +713,10 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test3", builder);
-        DocIndexMetadata md = newMeta(metadata, "test3");
+        DocTableInfo table = newTable(metadata, "test3");
 
 
-        assertThat(md.primaryKey()).containsExactly(new ColumnIdent("id"));
+        assertThat(table.primaryKey()).containsExactly(new ColumnIdent("id"));
 
         builder = JsonXContent.builder()
             .startObject()
@@ -721,16 +730,16 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
 
-        md = newMeta(getIndexMetadata("test4", builder), "test4");
-        assertThat(md.primaryKey()).hasSize(1); // _id is always the fallback primary key
+        table = newTable(getIndexMetadata("test4", builder), "test4");
+        assertThat(table.primaryKey()).hasSize(1); // _id is always the fallback primary key
 
         builder = JsonXContent.builder()
             .startObject()
             .startObject(Constants.DEFAULT_MAPPING_TYPE)
             .endObject()
             .endObject();
-        md = newMeta(getIndexMetadata("test5", builder), "test5");
-        assertThat(md.primaryKey()).hasSize(1);
+        table = newTable(getIndexMetadata("test5", builder), "test5");
+        assertThat(table.primaryKey()).hasSize(1);
     }
 
     @Test
@@ -755,8 +764,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test_multi_pk", builder);
-        DocIndexMetadata md = newMeta(metadata, "test_multi_pk");
-        assertThat(md.primaryKey()).containsExactly(ColumnIdent.fromPath("id"), ColumnIdent.fromPath("title"));
+        DocTableInfo table = newTable(metadata, "test_multi_pk");
+        assertThat(table.primaryKey()).containsExactly(ColumnIdent.fromPath("id"), ColumnIdent.fromPath("title"));
     }
 
     @Test
@@ -779,9 +788,9 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test3", builder);
-        DocIndexMetadata md = newMeta(metadata, "test3");
-        assertThat(md.checkConstraints()).hasSize(2);
-        assertThat(md.checkConstraints()
+        DocTableInfo table = newTable(metadata, "test3");
+        assertThat(table.checkConstraints()).hasSize(2);
+        assertThat(table.checkConstraints()
                        .stream()
                        .map(CheckConstraint::expressionStr)
                        .collect(Collectors.toList()))
@@ -809,8 +818,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test_no_pk", builder);
-        DocIndexMetadata md = newMeta(metadata, "test_no_pk");
-        assertThat(md.primaryKey()).containsExactly(ColumnIdent.fromPath("_id"));
+        DocTableInfo table = newTable(metadata, "test_no_pk");
+        assertThat(table.primaryKey()).containsExactly(ColumnIdent.fromPath("_id"));
 
         builder = JsonXContent.builder()
             .startObject()
@@ -832,8 +841,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         metadata = getIndexMetadata("test_no_pk2", builder);
-        md = newMeta(metadata, "test_no_pk2");
-        assertThat(md.primaryKey()).containsExactly(ColumnIdent.fromPath("_id"));
+        table = newTable(metadata, "test_no_pk2");
+        assertThat(table.primaryKey()).containsExactly(ColumnIdent.fromPath("_id"));
     }
 
     @Test
@@ -860,9 +869,9 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test_notnull_columns", builder);
-        DocIndexMetadata md = newMeta(metadata, "test_notnull_columns");
+        DocTableInfo table = newTable(metadata, "test_notnull_columns");
 
-        assertThat(md.columns().stream().map(Reference::isNullable).collect(Collectors.toList())).containsExactly(
+        assertThat(table.columns().stream().map(Reference::isNullable).collect(Collectors.toList())).containsExactly(
             false, false
         );
     }
@@ -898,13 +907,13 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                 .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test_notnull_columns", builder);
-        DocIndexMetadata md = newMeta(metadata, "test_notnull_columns");
+        DocTableInfo table = newTable(metadata, "test_notnull_columns");
 
         ColumnIdent level1 = new ColumnIdent("nested", "level1");
         ColumnIdent level2 = new ColumnIdent("nested", Arrays.asList("level1", "level2"));
-        assertThat(md.notNullColumns()).containsExactlyInAnyOrder(level1, level2);
-        assertThat(md.references().get(level1).isNullable()).isFalse();
-        assertThat(md.references().get(level2).isNullable()).isFalse();
+        assertThat(table.notNullColumns()).containsExactlyInAnyOrder(level1, level2);
+        assertThat(table.getReference(level1).isNullable()).isFalse();
+        assertThat(table.getReference(level2).isNullable()).isFalse();
     }
 
     @Test
@@ -930,10 +939,10 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject();
 
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
-        assertThat(md.columns()).hasSize(2);
-        Reference week = md.references().get(new ColumnIdent("week"));
+        assertThat(table.columns()).hasSize(2);
+        Reference week = table.getReference(new ColumnIdent("week"));
         assertThat(week)
             .isNotNull()
             .isExactlyInstanceOf(GeneratedReference.class);
@@ -967,8 +976,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
 
-        DocIndexMetadata md = newMeta(getIndexMetadata("test8", builder), "test8");
-        assertThat(md.routingCol()).isEqualTo(new ColumnIdent("id"));
+        DocTableInfo table = newTable(getIndexMetadata("test8", builder), "test8");
+        assertThat(table.clusteredBy()).isEqualTo(new ColumnIdent("id"));
 
         builder = JsonXContent.builder()
             .startObject()
@@ -982,8 +991,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
 
-        md = newMeta(getIndexMetadata("test9", builder), "test8");
-        assertThat(md.routingCol()).isEqualTo(new ColumnIdent("_id"));
+        table = newTable(getIndexMetadata("test9", builder), "test9");
+        assertThat(table.clusteredBy()).isEqualTo(new ColumnIdent("_id"));
 
         builder = JsonXContent.builder()
             .startObject()
@@ -1010,8 +1019,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
 
-        md = newMeta(getIndexMetadata("test10", builder), "test10");
-        assertThat(md.routingCol()).isEqualTo(new ColumnIdent("num"));
+        table = newTable(getIndexMetadata("test10", builder), "test10");
+        assertThat(table.clusteredBy()).isEqualTo(new ColumnIdent("num"));
     }
 
     @Test
@@ -1021,8 +1030,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .startObject(Constants.DEFAULT_MAPPING_TYPE)
             .endObject()
             .endObject();
-        DocIndexMetadata md = newMeta(getIndexMetadata("test11", builder), "test11");
-        assertThat(md.routingCol()).isEqualTo(new ColumnIdent("_id"));
+        DocTableInfo table = newTable(getIndexMetadata("test11", builder), "test11");
+        assertThat(table.clusteredBy()).isEqualTo(new ColumnIdent("_id"));
     }
 
     @Test
@@ -1032,10 +1041,10 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .startObject(Constants.DEFAULT_MAPPING_TYPE)
             .endObject()
             .endObject();
-        DocIndexMetadata md = newMeta(getIndexMetadata("test11", builder), "test11");
-        assertThat(md.primaryKey()).hasSize(1);
-        assertThat(md.primaryKey().get(0)).isEqualTo(new ColumnIdent("_id"));
-        assertThat(md.hasAutoGeneratedPrimaryKey()).isTrue();
+        DocTableInfo table = newTable(getIndexMetadata("test11", builder), "test11");
+        assertThat(table.primaryKey()).hasSize(1);
+        assertThat(table.primaryKey().get(0)).isEqualTo(new ColumnIdent("_id"));
+        assertThat(table.hasAutoGeneratedPrimaryKey()).isTrue();
     }
 
     @Test
@@ -1054,10 +1063,10 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                     .endObject()
                 .endObject()
             .endObject();
-        DocIndexMetadata md = newMeta(getIndexMetadata("test11", builder), "test11");
-        assertThat(md.primaryKey()).hasSize(1);
-        assertThat(md.primaryKey().get(0)).isEqualTo(new ColumnIdent("id"));
-        assertThat(md.hasAutoGeneratedPrimaryKey()).isFalse();
+        DocTableInfo table = newTable(getIndexMetadata("test11", builder), "test11");
+        assertThat(table.primaryKey()).hasSize(1);
+        assertThat(table.primaryKey().get(0)).isEqualTo(new ColumnIdent("id"));
+        assertThat(table.hasAutoGeneratedPrimaryKey()).isFalse();
     }
 
     @Test
@@ -1080,8 +1089,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                     .endObject()
                 .endObject()
             .endObject();
-        DocIndexMetadata md = newMeta(getIndexMetadata("test_analyzer", builder), "test_analyzer");
-        List<Reference> columns = new ArrayList<>(md.columns());
+        DocTableInfo table = newTable(getIndexMetadata("test_analyzer", builder), "test_analyzer");
+        List<Reference> columns = new ArrayList<>(table.columns());
         assertThat(columns).hasSize(2);
         assertThat(columns.get(0).indexType()).isEqualTo(IndexType.FULLTEXT);
         assertThat(columns.get(0).column().fqn()).isEqualTo("content_de");
@@ -1091,15 +1100,15 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
 
     @Test
     public void testGeoPointType() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table foo (p geo_point)");
-        assertThat(md.columns()).hasSize(1);
-        Reference reference = md.columns().iterator().next();
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table foo (p geo_point)");
+        assertThat(table.columns()).hasSize(1);
+        Reference reference = table.columns().iterator().next();
         assertThat(reference.valueType()).isEqualTo(DataTypes.GEO_POINT);
     }
 
     @Test
     public void testCreateTableMappingGenerationAndParsingCompat() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table foo (" +
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table foo (" +
                                                                "id int primary key," +
                                                                "tags array(string)," +
                                                                "o object as (" +
@@ -1109,35 +1118,32 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                                                                "date timestamp with time zone primary key" +
                                                                ") partitioned by (date)");
 
-        assertThat(md.columns()).hasSize(4);
-        assertThat(md.primaryKey()).containsExactly(new ColumnIdent("id"), new ColumnIdent("date"));
-        assertThat(md.references().get(new ColumnIdent("tags")).valueType()).isEqualTo(
+        assertThat(table.columns()).hasSize(4);
+        assertThat(table.primaryKey()).containsExactly(new ColumnIdent("id"), new ColumnIdent("date"));
+        assertThat(table.getReference(new ColumnIdent("tags")).valueType()).isEqualTo(
             new ArrayType<>(DataTypes.STRING));
     }
 
     @Test
     public void testCreateTableMappingGenerationAndParsingArrayInsideObject() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement(
+        DocTableInfo table = getDocIndexMetadataFromStatement(
             "create table t1 (" +
             "id int primary key," +
             "details object as (names array(string))" +
             ") with (number_of_replicas=0)");
-        DataType<?> type = md.references().get(new ColumnIdent("details", "names")).valueType();
+        DataType<?> type = table.getReference(new ColumnIdent("details", "names")).valueType();
         assertThat(type).isEqualTo(new ArrayType<>(DataTypes.STRING));
     }
 
     @Test
     public void testCreateTableMappingGenerationAndParsingCompatNoMeta() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table foo (id int, name string)");
-        assertThat(md.columns()).hasSize(2);
-        assertThat(md.hasAutoGeneratedPrimaryKey()).isTrue();
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table foo (id int, name string)");
+        assertThat(table.columns()).hasSize(2);
+        assertThat(table.hasAutoGeneratedPrimaryKey()).isTrue();
     }
 
-    private DocIndexMetadata getDocIndexMetadataFromStatement(String stmt) throws IOException {
+    private DocTableInfo getDocIndexMetadataFromStatement(String stmt) throws IOException {
         Statement statement = SqlParser.createStatement(stmt);
-
-        DocTableInfoFactory docTableInfoFactory = new DocTableInfoFactory(nodeCtx);
-        ViewInfoFactory viewInfoFactory = new ViewInfoFactory(() -> null);
         Path homeDir = createTempDir();
         FulltextAnalyzerResolver fulltextAnalyzerResolver = new FulltextAnalyzerResolver(
             clusterService,
@@ -1191,28 +1197,28 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .putMapping(new MappingMetadata(TestingHelpers.toMapping(boundCreateTable)))
             .build();
 
-        return newMeta(indexMetadata, boundCreateTable.tableName().name());
+        return newTable(indexMetadata, boundCreateTable.tableName().name());
     }
 
     @Test
     public void testCompoundIndexColumn() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table t (" +
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t (" +
                                                                "  id integer primary key," +
                                                                "  name string," +
                                                                "  fun string index off," +
                                                                "  INDEX fun_name_ft using fulltext(name, fun)" +
                                                                ")");
-        assertThat(md.indices()).hasSize(1);
-        assertThat(md.columns()).hasSize(3);
-        assertThat(md.indices().get(ColumnIdent.fromPath("fun_name_ft"))).isExactlyInstanceOf(IndexReference.class);
-        IndexReference indexInfo = md.indices().get(ColumnIdent.fromPath("fun_name_ft"));
+        assertThat(table.indexColumns()).hasSize(1);
+        assertThat(table.columns()).hasSize(3);
+        assertThat(table.indexColumn(ColumnIdent.fromPath("fun_name_ft"))).isExactlyInstanceOf(IndexReference.class);
+        IndexReference indexInfo = table.indexColumn(ColumnIdent.fromPath("fun_name_ft"));
         assertThat(indexInfo.indexType()).isEqualTo(IndexType.FULLTEXT);
         assertThat(indexInfo.column().fqn()).isEqualTo("fun_name_ft");
     }
 
     @Test
     public void testCompoundIndexColumnNested() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table t (" +
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t (" +
                                                                "  id integer primary key," +
                                                                "  name string," +
                                                                "  o object as (" +
@@ -1220,10 +1226,10 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                                                                "  )," +
                                                                "  INDEX fun_name_ft using fulltext(name, o['fun'])" +
                                                                ")");
-        assertThat(md.indices()).hasSize(1);
-        assertThat(md.columns()).hasSize(3);
-        assertThat(md.indices().get(ColumnIdent.fromPath("fun_name_ft"))).isExactlyInstanceOf(IndexReference.class);
-        IndexReference indexInfo = md.indices().get(ColumnIdent.fromPath("fun_name_ft"));
+        assertThat(table.indexColumns()).hasSize(1);
+        assertThat(table.columns()).hasSize(3);
+        assertThat(table.indexColumn(ColumnIdent.fromPath("fun_name_ft"))).isExactlyInstanceOf(IndexReference.class);
+        IndexReference indexInfo = table.indexColumn(ColumnIdent.fromPath("fun_name_ft"));
         assertThat(indexInfo.indexType()).isEqualTo(IndexType.FULLTEXT);
         assertThat(indexInfo.column().fqn()).isEqualTo("fun_name_ft");
     }
@@ -1247,8 +1253,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject()
             .endObject();
-        DocIndexMetadata mdIgnored = newMeta(getIndexMetadata("test_ignored", ignoredBuilder), "test_ignored");
-        assertThat(mdIgnored.columnPolicy()).isEqualTo(ColumnPolicy.IGNORED);
+        DocTableInfo tableIgnored = newTable(getIndexMetadata("test_ignored", ignoredBuilder), "test_ignored");
+        assertThat(tableIgnored.columnPolicy()).isEqualTo(ColumnPolicy.IGNORED);
 
         XContentBuilder strictBuilder = JsonXContent.builder()
             .startObject()
@@ -1267,8 +1273,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject()
             .endObject();
-        DocIndexMetadata mdStrict = newMeta(getIndexMetadata("test_strict", strictBuilder), "test_strict");
-        assertThat(mdStrict.columnPolicy()).isEqualTo(ColumnPolicy.STRICT);
+        DocTableInfo tableStrict = newTable(getIndexMetadata("test_strict", strictBuilder), "test_strict");
+        assertThat(tableStrict.columnPolicy()).isEqualTo(ColumnPolicy.STRICT);
 
         XContentBuilder dynamicBuilder = JsonXContent.builder()
             .startObject()
@@ -1287,8 +1293,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject()
             .endObject();
-        DocIndexMetadata mdDynamic = newMeta(getIndexMetadata("test_dynamic", dynamicBuilder), "test_dynamic");
-        assertThat(mdDynamic.columnPolicy()).isEqualTo(ColumnPolicy.DYNAMIC);
+        DocTableInfo tableDynamic = newTable(getIndexMetadata("test_dynamic", dynamicBuilder), "test_dynamic");
+        assertThat(tableDynamic.columnPolicy()).isEqualTo(ColumnPolicy.DYNAMIC);
 
         XContentBuilder missingBuilder = JsonXContent.builder()
             .startObject()
@@ -1306,8 +1312,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject()
             .endObject();
-        DocIndexMetadata mdMissing = newMeta(getIndexMetadata("test_missing", missingBuilder), "test_missing");
-        assertThat(mdMissing.columnPolicy()).isEqualTo(ColumnPolicy.DYNAMIC);
+        DocTableInfo tableMissing = newTable(getIndexMetadata("test_missing", missingBuilder), "test_missing");
+        assertThat(tableMissing.columnPolicy()).isEqualTo(ColumnPolicy.DYNAMIC);
 
         XContentBuilder wrongBuilder = JsonXContent.builder()
             .startObject()
@@ -1325,27 +1331,27 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
 
-        assertThatThrownBy(() -> newMeta(getIndexMetadata("test_wrong", wrongBuilder), "test_wrong"))
+        assertThatThrownBy(() -> newTable(getIndexMetadata("test_wrong", wrongBuilder), "test_wrong"))
             .isExactlyInstanceOf(IllegalArgumentException.class)
             .hasMessage("Invalid column policy: wrong");
     }
 
     @Test
     public void testCreateArrayMapping() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table t (" +
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t (" +
                                                                "  id integer primary key," +
                                                                "  tags array(string)," +
                                                                "  scores array(short)" +
                                                                ")");
-        assertThat(md.references().get(ColumnIdent.fromPath("tags")).valueType()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("tags")).valueType()).isEqualTo(
             new ArrayType<>(DataTypes.STRING));
-        assertThat(md.references().get(ColumnIdent.fromPath("scores")).valueType()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("scores")).valueType()).isEqualTo(
             new ArrayType<>(DataTypes.SHORT));
     }
 
     @Test
     public void testCreateObjectArrayMapping() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table t (" +
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t (" +
                                                                "  id integer primary key," +
                                                                "  tags array(object(strict) as (" +
                                                                "    size double index off," +
@@ -1354,24 +1360,24 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                                                                "  ))" +
                                                                ")");
         assertThat(
-            md.references().get(ColumnIdent.fromPath("tags")).valueType()).isEqualTo(
+            table.getReference(ColumnIdent.fromPath("tags")).valueType()).isEqualTo(
                 new ArrayType<>(
                     ObjectType.builder()
                         .setInnerType("size", DataTypes.DOUBLE)
                         .setInnerType("numbers", DataTypes.INTEGER_ARRAY)
                         .setInnerType("quote", DataTypes.STRING)
                         .build()));
-        assertThat(md.references().get(ColumnIdent.fromPath("tags")).columnPolicy()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("tags")).columnPolicy()).isEqualTo(
             ColumnPolicy.STRICT);
-        assertThat(md.references().get(ColumnIdent.fromPath("tags.size")).valueType()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("tags.size")).valueType()).isEqualTo(
             DataTypes.DOUBLE);
-        assertThat(md.references().get(ColumnIdent.fromPath("tags.size")).indexType()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("tags.size")).indexType()).isEqualTo(
             IndexType.NONE);
-        assertThat(md.references().get(ColumnIdent.fromPath("tags.numbers")).valueType()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("tags.numbers")).valueType()).isEqualTo(
             new ArrayType<>(DataTypes.INTEGER));
-        assertThat(md.references().get(ColumnIdent.fromPath("tags.quote")).valueType()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("tags.quote")).valueType()).isEqualTo(
             DataTypes.STRING);
-        assertThat(md.references().get(ColumnIdent.fromPath("tags.quote")).indexType()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("tags.quote")).indexType()).isEqualTo(
             IndexType.FULLTEXT);
     }
 
@@ -1421,12 +1427,12 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata indexMetadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata docIndexMetadata = newMeta(indexMetadata, "test1");
+        DocTableInfo docIndexMetadata = newTable(indexMetadata, "test1");
 
         // ARRAY TYPES NOT DETECTED
-        assertThat(docIndexMetadata.references().get(ColumnIdent.fromPath("array_col")).valueType()).isEqualTo(
+        assertThat(docIndexMetadata.getReference(ColumnIdent.fromPath("array_col")).valueType()).isEqualTo(
             DataTypes.IP);
-        assertThat(docIndexMetadata.references().get(ColumnIdent.fromPath("nested.inner_nested")).valueType()).isEqualTo(
+        assertThat(docIndexMetadata.getReference(ColumnIdent.fromPath("nested.inner_nested")).valueType()).isEqualTo(
             DataTypes.TIMESTAMPZ);
     }
 
@@ -1471,29 +1477,29 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject()
             .endObject();
         IndexMetadata indexMetadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata docIndexMetadata = newMeta(indexMetadata, "test1");
-        assertThat(docIndexMetadata.references().get(ColumnIdent.fromPath("array_col")).valueType()).isEqualTo(
+        DocTableInfo table = newTable(indexMetadata, "test1");
+        assertThat(table.getReference(ColumnIdent.fromPath("array_col")).valueType()).isEqualTo(
             new ArrayType<>(DataTypes.IP));
-        assertThat(docIndexMetadata.references().get(ColumnIdent.fromPath("nested.inner_nested")).valueType()).isEqualTo(
+        assertThat(table.getReference(ColumnIdent.fromPath("nested.inner_nested")).valueType()).isEqualTo(
             new ArrayType<>(DataTypes.TIMESTAMPZ));
     }
 
     @Test
     public void testStringArrayWithFulltextIndex() throws Exception {
-        DocIndexMetadata metadata = getDocIndexMetadataFromStatement(
+        DocTableInfo table = getDocIndexMetadataFromStatement(
             "create table t (tags array(string) index using fulltext)");
 
-        Reference reference = metadata.columns().iterator().next();
+        Reference reference = table.columns().iterator().next();
         assertThat(reference.valueType()).isEqualTo(new ArrayType<>(DataTypes.STRING));
     }
 
     @Test
     public void testCreateTableWithNestedPrimaryKey() throws Exception {
-        DocIndexMetadata metadata = getDocIndexMetadataFromStatement("create table t (o object as (x int primary key))");
-        assertThat(metadata.primaryKey()).containsExactly(new ColumnIdent("o", "x"));
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t (o object as (x int primary key))");
+        assertThat(table.primaryKey()).containsExactly(new ColumnIdent("o", "x"));
 
-        metadata = getDocIndexMetadataFromStatement("create table t (x object as (y object as (z int primary key)))");
-        assertThat(metadata.primaryKey()).containsExactly(new ColumnIdent("x", Arrays.asList("y", "z")));
+        table = getDocIndexMetadataFromStatement("create table t (x object as (y object as (z int primary key)))");
+        assertThat(table.primaryKey()).containsExactly(new ColumnIdent("x", Arrays.asList("y", "z")));
     }
 
     @Test
@@ -1518,10 +1524,10 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject();
 
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
-        assertThat(md.columns()).hasSize(2);
-        Reference week = md.references().get(new ColumnIdent("week"));
+        assertThat(table.columns()).hasSize(2);
+        Reference week = table.getReference(new ColumnIdent("week"));
         assertThat(week)
             .isNotNull()
             .isExactlyInstanceOf(GeneratedReference.class);
@@ -1536,16 +1542,16 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
 
     @Test
     public void testArrayAsGeneratedColumn() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table t1 (x as ([10, 20]))");
-        GeneratedReference generatedReference = md.generatedColumnReferences().get(0);
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t1 (x as ([10, 20]))");
+        GeneratedReference generatedReference = table.generatedColumns().get(0);
         assertThat(generatedReference.valueType()).isEqualTo(new ArrayType<>(DataTypes.INTEGER));
     }
 
     @Test
     public void testColumnWithDefaultExpression() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table t1 (" +
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t1 (" +
                                                                " ts timestamp with time zone default current_timestamp)");
-        Reference reference = md.references().get(new ColumnIdent("ts"));
+        Reference reference = table.getReference(new ColumnIdent("ts"));
         assertThat(reference.valueType()).isEqualTo(DataTypes.TIMESTAMPZ);
         assertThat(reference.defaultExpression()).isFunction("current_timestamp");
     }
@@ -1568,18 +1574,18 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                     .endObject()
                 .endObject()
             .endObject();
-        DocIndexMetadata md = newMeta(getIndexMetadata("test", builder), "test");
+        DocTableInfo table = newTable(getIndexMetadata("test", builder), "test");
 
-        assertThat(md.columns()).hasSize(2);
-        assertThat(md.references().get(new ColumnIdent("tz")).valueType()).isEqualTo(DataTypes.TIMESTAMPZ);
-        assertThat(md.references().get(new ColumnIdent("t")).valueType()).isEqualTo(DataTypes.TIMESTAMP);
+        assertThat(table.columns()).hasSize(2);
+        assertThat(table.getReference(new ColumnIdent("tz")).valueType()).isEqualTo(DataTypes.TIMESTAMPZ);
+        assertThat(table.getReference(new ColumnIdent("t")).valueType()).isEqualTo(DataTypes.TIMESTAMP);
     }
 
     @Test
     public void testColumnStoreBooleanIsParsedCorrectly() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement(
+        DocTableInfo table = getDocIndexMetadataFromStatement(
                 "create table t1 (x string STORAGE WITH (columnstore = false))");
-        assertThat(md.columns().iterator().next().hasDocValues()).isFalse();
+        assertThat(table.columns().iterator().next().hasDocValues()).isFalse();
     }
 
     @Test
@@ -1612,9 +1618,9 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                 .endObject()
             .endObject();
         IndexMetadata metadata = getIndexMetadata("test", builder);
-        DocIndexMetadata md = newMeta(metadata, "test");
+        DocTableInfo table = newTable(metadata, "test");
 
-        ObjectType objectType = (ObjectType) md.references().get(new ColumnIdent("object")).valueType();
+        ObjectType objectType = (ObjectType) table.getReference(new ColumnIdent("object")).valueType();
         assertThat(objectType.resolveInnerType(List.of("nestedString"))).isEqualTo(DataTypes.STRING);
         assertThat(objectType.resolveInnerType(List.of("nestedObject")).id()).isEqualTo(ObjectType.ID);
         assertThat(objectType.resolveInnerType(List.of("nestedObject", "nestedNestedString"))).isEqualTo(DataTypes.STRING);
@@ -1622,10 +1628,10 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
 
     @Test
     public void test_nested_geo_shape_column_is_not_added_as_top_level_column() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement(
+        DocTableInfo table = getDocIndexMetadataFromStatement(
             "create table tbl (x int, y object as (z geo_shape))");
-        assertThat(md.columns()).satisfiesExactlyInAnyOrder(isReference("x"), isReference("y"));
-        assertThat(md.references()).containsKey(new ColumnIdent("y", "z"));
+        assertThat(table.columns()).satisfiesExactlyInAnyOrder(isReference("x"), isReference("y"));
+        assertThat(table.getReference(new ColumnIdent("y", "z"))).isNotNull();
     }
 
     @Test
@@ -1643,17 +1649,17 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
                     .endObject()
                 .endObject()
             .endObject();
-        var docIndexMetadata = newMeta(getIndexMetadata("test", builder), "test");
+        var docIndexMetadata = newTable(getIndexMetadata("test", builder), "test");
 
-        var column = docIndexMetadata.references().get(new ColumnIdent("col"));
+        var column = docIndexMetadata.getReference(new ColumnIdent("col"));
         assertThat(column).isNotNull();
         assertThat(column.valueType()).isEqualTo(StringType.of(10));
     }
 
     @Test
     public void test_geo_shape_column_has_generated_expression() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table t (g geo_shape generated always as 'POLYGON (( 5 5, 30 5, 30 30, 5 30, 5 5 ))')");
-        Reference reference = md.references().get(new ColumnIdent("g"));
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t (g geo_shape generated always as 'POLYGON (( 5 5, 30 5, 30 30, 5 30, 5 5 ))')");
+        Reference reference = table.getReference(new ColumnIdent("g"));
         assertThat(reference.valueType()).isEqualTo(DataTypes.GEO_SHAPE);
         GeneratedReference genRef = (GeneratedReference) reference;
         assertThat(genRef.formattedGeneratedExpression()).isEqualTo("'POLYGON (( 5 5, 30 5, 30 30, 5 30, 5 5 ))'");
@@ -1661,8 +1667,8 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
 
     @Test
     public void test_geo_shape_column_has_default_expression() throws Exception {
-        DocIndexMetadata md = getDocIndexMetadataFromStatement("create table t (g geo_shape default 'POLYGON (( 5 5, 30 5, 30 30, 5 30, 5 5 ))')");
-        Reference reference = md.references().get(new ColumnIdent("g"));
+        DocTableInfo table = getDocIndexMetadataFromStatement("create table t (g geo_shape default 'POLYGON (( 5 5, 30 5, 30 30, 5 30, 5 5 ))')");
+        Reference reference = table.getReference(new ColumnIdent("g"));
         assertThat(reference.valueType()).isEqualTo(DataTypes.GEO_SHAPE);
         assertThat(reference.defaultExpression().toString(Style.UNQUALIFIED))
             .isEqualTo("'POLYGON (( 5 5, 30 5, 30 30, 5 30, 5 5 ))'");
@@ -1670,14 +1676,14 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
 
     @Test
     public void test_column_of_index_has_nullable_from_real_column() throws Exception {
-        var md = getDocIndexMetadataFromStatement(
+        var table = getDocIndexMetadataFromStatement(
             "create table tbl (x string, index ft using fulltext (x))");
-        var indexReference = md.indices().get(new ColumnIdent("ft"));
+        var indexReference = table.indexColumn(new ColumnIdent("ft"));
         assertThat(indexReference.columns().get(0).isNullable()).isTrue();
 
-        md = getDocIndexMetadataFromStatement(
+        table = getDocIndexMetadataFromStatement(
             "create table tbl (x string not null, index ft using fulltext (x))");
-        indexReference = md.indices().get(new ColumnIdent("ft"));
+        indexReference = table.indexColumn(new ColumnIdent("ft"));
         assertThat(indexReference.columns().get(0).isNullable()).isFalse();
     }
 
@@ -1699,10 +1705,10 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             .endObject();
 
         IndexMetadata metadata = getIndexMetadata("test1", builder);
-        DocIndexMetadata md = newMeta(metadata, "test1");
+        DocTableInfo table = newTable(metadata, "test1");
 
-        assertThat(md.indices()).hasSize(1);
-        IndexReference ref = md.indices().values().iterator().next();
+        assertThat(table.indexColumns()).hasSize(1);
+        IndexReference ref = table.indexColumns().iterator().next();
         assertThat(ref.columns()).satisfiesExactly(
             x -> assertThat(x).isReference().hasName("description")
         );
@@ -1710,7 +1716,7 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
 
     @Test
     public void test_generated_columns_expression_has_specified_type() throws Exception {
-        var md = getDocIndexMetadataFromStatement("""
+        var table = getDocIndexMetadataFromStatement("""
             create table tbl (
                 x int,
                 y int,
@@ -1718,7 +1724,7 @@ public class DocIndexMetadataTest extends CrateDummyClusterServiceUnitTest {
             )
             """
         );
-        assertThat(md.generatedColumnReferences()).satisfiesExactly(
+        assertThat(table.generatedColumns()).satisfiesExactly(
             sum -> {
                 assertThat(sum.generatedExpression().valueType()).isEqualTo(DataTypes.LONG);
                 assertThat(sum.valueType()).isEqualTo(DataTypes.LONG);
diff --git a/server/src/test/java/io/crate/metadata/doc/DocSchemaInfoTest.java b/server/src/test/java/io/crate/metadata/doc/DocSchemaInfoTest.java
index 8ed427cf81..77923c4df6 100644
--- a/server/src/test/java/io/crate/metadata/doc/DocSchemaInfoTest.java
+++ b/server/src/test/java/io/crate/metadata/doc/DocSchemaInfoTest.java
@@ -23,13 +23,12 @@ package io.crate.metadata.doc;
 
 import static io.crate.metadata.SearchPath.pathWithPGCatalogAndDoc;
 import static io.crate.metadata.doc.DocSchemaInfo.getTablesAffectedByPublicationsChange;
-import static io.crate.testing.Asserts.assertThat;
 import static io.crate.testing.TestingHelpers.createNodeContext;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 import javax.script.ScriptException;
 
@@ -247,12 +246,8 @@ public class DocSchemaInfoTest extends CrateDummyClusterServiceUnitTest {
     private DocTableInfo docTableInfo(String name) {
         return new DocTableInfo(
             new RelationName(Schemas.DOC_SCHEMA_NAME, name),
-            List.of(),
-            Set.of(),
-            List.of(),
-            List.of(),
-            List.of(),
             Map.of(),
+            List.of(),
             Map.of(),
             Map.of(),
             null,
diff --git a/server/src/test/java/io/crate/metadata/doc/DocTableInfoTest.java b/server/src/test/java/io/crate/metadata/doc/DocTableInfoTest.java
index 7bd4bc4c6e..0d37031c2b 100644
--- a/server/src/test/java/io/crate/metadata/doc/DocTableInfoTest.java
+++ b/server/src/test/java/io/crate/metadata/doc/DocTableInfoTest.java
@@ -28,7 +28,6 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 import org.assertj.core.api.Assertions;
 import org.elasticsearch.Version;
@@ -60,22 +59,20 @@ public class DocTableInfoTest extends CrateDummyClusterServiceUnitTest {
     public void testGetColumnInfo() throws Exception {
         RelationName relationName = new RelationName(Schemas.DOC_SCHEMA_NAME, "dummy");
 
+        ColumnIdent columnIdent = new ColumnIdent("o", List.of());
         DocTableInfo info = new DocTableInfo(
             relationName,
-            List.of(
+            Map.of(
+                columnIdent,
                 new SimpleReference(
-                    new ReferenceIdent(relationName, new ColumnIdent("o", List.of())),
+                    new ReferenceIdent(relationName, columnIdent),
                     RowGranularity.DOC,
                     DataTypes.UNTYPED_OBJECT,
                     1,
                     null
                 )
             ),
-            Set.of(),
             List.of(),
-            List.of(),
-            List.of(),
-            Map.of(),
             Map.of(),
             Map.of(),
             null,
@@ -124,7 +121,8 @@ public class DocTableInfoTest extends CrateDummyClusterServiceUnitTest {
     @Test
     public void testGetColumnInfoStrictParent() throws Exception {
         RelationName dummy = new RelationName(Schemas.DOC_SCHEMA_NAME, "dummy");
-        ReferenceIdent foobarIdent = new ReferenceIdent(dummy, new ColumnIdent("foobar"));
+        ColumnIdent column = new ColumnIdent("foobar");
+        ReferenceIdent foobarIdent = new ReferenceIdent(dummy, column);
         SimpleReference strictParent = new SimpleReference(
             foobarIdent,
             RowGranularity.DOC,
@@ -139,17 +137,13 @@ public class DocTableInfoTest extends CrateDummyClusterServiceUnitTest {
             null
         );
 
-        Map<ColumnIdent, Reference> references = Map.of(new ColumnIdent("foobar"), strictParent);
+        Map<ColumnIdent, Reference> references = Map.of(column, strictParent);
 
         DocTableInfo info = new DocTableInfo(
             dummy,
-            List.of(strictParent),
-            Set.of(),
-            List.of(),
-            List.of(),
+            references,
             List.of(),
             Map.of(),
-            references,
             Map.of(),
             null,
             List.of(),
@@ -208,7 +202,7 @@ public class DocTableInfoTest extends CrateDummyClusterServiceUnitTest {
             .isExactlyInstanceOf(ColumnUnknownException.class)
             .hasMessageContaining("Column foobar['foo'] unknown");
 
-        Reference colInfo = info.getReference(new ColumnIdent("foobar"));
+        Reference colInfo = info.getReference(column);
         assertThat(colInfo).isNotNull();
     }
 
@@ -255,42 +249,41 @@ public class DocTableInfoTest extends CrateDummyClusterServiceUnitTest {
     public void test_dropped_columns_are_included_in_oid_to_column_map() throws Exception {
         RelationName relationName = new RelationName(Schemas.DOC_SCHEMA_NAME, "dummy");
 
+        ColumnIdent a = new ColumnIdent("a", List.of());
+        ColumnIdent b = new ColumnIdent("b", List.of());
         DocTableInfo info = new DocTableInfo(
                 relationName,
-                List.of(
-                        new SimpleReference(
-                                new ReferenceIdent(relationName, new ColumnIdent("a", List.of())),
-                                RowGranularity.DOC,
-                                DataTypes.INTEGER,
-                                ColumnPolicy.DYNAMIC,
-                                IndexType.PLAIN,
-                                true,
-                                false,
-                                1,
-                                1,
-                                false,
-                                null
-                        )
-                ),
-                Set.of(
-                        new SimpleReference(
-                                new ReferenceIdent(relationName, new ColumnIdent("b", List.of())),
-                                RowGranularity.DOC,
-                                DataTypes.INTEGER,
-                                ColumnPolicy.DYNAMIC,
-                                IndexType.PLAIN,
-                                true,
-                                false,
-                                2,
-                                2,
-                                true,
-                                null
-                        )
+                Map.of(
+                    a,
+                    new SimpleReference(
+                            new ReferenceIdent(relationName, a),
+                            RowGranularity.DOC,
+                            DataTypes.INTEGER,
+                            ColumnPolicy.DYNAMIC,
+                            IndexType.PLAIN,
+                            true,
+                            false,
+                            1,
+                            1,
+                            false,
+                            null
+                    ),
+                    b,
+                    new SimpleReference(
+                            new ReferenceIdent(relationName, b),
+                            RowGranularity.DOC,
+                            DataTypes.INTEGER,
+                            ColumnPolicy.DYNAMIC,
+                            IndexType.PLAIN,
+                            true,
+                            false,
+                            2,
+                            2,
+                            true,
+                            null
+                    )
                 ),
                 List.of(),
-                List.of(),
-                List.of(),
-                Map.of(),
                 Map.of(),
                 Map.of(),
                 null,
diff --git a/server/src/test/java/io/crate/planner/node/dql/JoinPhaseTest.java b/server/src/test/java/io/crate/planner/node/dql/JoinPhaseTest.java
index 091a5959ab..2b61773669 100644
--- a/server/src/test/java/io/crate/planner/node/dql/JoinPhaseTest.java
+++ b/server/src/test/java/io/crate/planner/node/dql/JoinPhaseTest.java
@@ -149,8 +149,7 @@ public class JoinPhaseTest extends ESTestCase {
             List.of(Literal.of("testLeft"), Literal.of(10)),
             List.of(Literal.of("testRight"), Literal.of(20)),
             List.of(DataTypes.STRING, DataTypes.INTEGER),
-            111,
-            222);
+            111);
 
         BytesStreamOutput output = new BytesStreamOutput();
         node.writeTo(output);
@@ -174,6 +173,5 @@ public class JoinPhaseTest extends ESTestCase {
         assertThat(node.numRightOutputs(), is(node2.numRightOutputs()));
         assertThat(node.leftOutputTypes(), is(node2.leftOutputTypes()));
         assertThat(node.estimatedRowSizeForLeft(), is(node2.estimatedRowSizeForLeft()));
-        assertThat(node.numberOfRowsForLeft(), is(node2.numberOfRowsForLeft()));
     }
 }
diff --git a/server/src/testFixtures/java/io/crate/operation/aggregation/AggregationTestCase.java b/server/src/testFixtures/java/io/crate/operation/aggregation/AggregationTestCase.java
index a466913bd0..2b2f283e6f 100644
--- a/server/src/testFixtures/java/io/crate/operation/aggregation/AggregationTestCase.java
+++ b/server/src/testFixtures/java/io/crate/operation/aggregation/AggregationTestCase.java
@@ -383,12 +383,8 @@ public abstract class AggregationTestCase extends ESTestCase {
 
         DocTableInfo table = new DocTableInfo(
             new RelationName("doc", shard.shardId().getIndexName()),
-            targetColumns,
-            Set.of(),
-            List.of(),
+            targetColumns.stream().collect(Collectors.toMap(Reference::column, r -> r)),
             List.of(),
-            List.of(),
-            Map.of(),
             Map.of(),
             Map.of(),
             null,
