diff --git a/coverage/debug.py b/coverage/debug.py
index 4fe3b36d..d7804398 100644
--- a/coverage/debug.py
+++ b/coverage/debug.py
@@ -53,14 +53,17 @@ class DebugControl:
         self.suppress_callers = False
 
         filters = []
+        if self.should("process"):
+            filters.append(CwdTracker().filter)
+            filters.append(ProcessTracker().filter)
         if self.should("pytest"):
             filters.append(PytestTracker().filter)
         if self.should("pid"):
             filters.append(add_pid_and_tid)
+
         self.output = DebugOutputFile.get_one(
             output,
             file_name=file_name,
-            show_process=self.should("process"),
             filters=filters,
         )
         self.raw_output = self.output.outfile
@@ -407,24 +410,17 @@ class DebugOutputFile:
     def __init__(
         self,
         outfile: Optional[IO[str]],
-        show_process: bool,
         filters: Iterable[Callable[[str], str]],
     ):
         self.outfile = outfile
-        self.show_process = show_process
         self.filters = list(filters)
         self.pid = os.getpid()
 
-        if self.show_process:
-            self.filters.insert(0, ProcessTracker().filter)
-            self.filters.insert(0, CwdTracker().filter)
-
     @classmethod
     def get_one(
         cls,
         fileobj: Optional[IO[str]] = None,
         file_name: Optional[str] = None,
-        show_process: bool = True,
         filters: Iterable[Callable[[str], str]] = (),
         interim: bool = False,
     ) -> DebugOutputFile:
@@ -436,9 +432,6 @@ class DebugOutputFile:
         provided, or COVERAGE_DEBUG_FILE, or stderr), and a process-wide
         singleton DebugOutputFile is made.
 
-        `show_process` controls whether the debug file adds process-level
-        information, and filters is a list of other message filters to apply.
-
         `filters` are the text filters to apply to the stream to annotate with
         pids, etc.
 
@@ -447,7 +440,7 @@ class DebugOutputFile:
         """
         if fileobj is not None:
             # Make DebugOutputFile around the fileobj passed.
-            return cls(fileobj, show_process, filters)
+            return cls(fileobj, filters)
 
         the_one, is_interim = cls._get_singleton_data()
         if the_one is None or is_interim:
@@ -461,8 +454,11 @@ class DebugOutputFile:
                     fileobj = open(file_name, "a", encoding="utf-8")
                 else:
                     fileobj = sys.stderr
-            the_one = cls(fileobj, show_process, filters)
+            the_one = cls(fileobj, filters)
             cls._set_singleton_data(the_one, interim)
+
+        if not(the_one.filters):
+            the_one.filters = list(filters)
         return the_one
 
     # Because of the way igor.py deletes and re-imports modules,
diff --git a/tests/test_process.py b/tests/test_process.py
index f2bc5011..90487328 100644
--- a/tests/test_process.py
+++ b/tests/test_process.py
@@ -364,17 +364,15 @@ class ProcessTest(CoverageTest):
         self.make_file("fork.py", """\
             import os
 
-            def main():
-                print(f"parent={os.getpid()}", flush=True)
-                ret = os.fork()
+            print(f"parent={os.getpid()}", flush=True)
+            ret = os.fork()
 
-                if ret == 0:
-                    print(f"child={os.getpid()}", flush=True)
-                else:
-                    os.waitpid(ret, 0)
-
-            main()
+            if ret == 0:
+                print(f"child={os.getpid()}", flush=True)
+            else:
+                os.waitpid(ret, 0)
             """)
+        total_lines = 6
 
         self.set_environ("COVERAGE_DEBUG_FILE", "debug.out")
         out = self.run_command("coverage run --debug=pid,process,trace -p fork.py")
@@ -393,16 +391,21 @@ class ProcessTest(CoverageTest):
         suffixes = {name.split(".")[-1] for name in data_files}
         assert len(suffixes) == 2, f"Same random suffix: {data_files}"
 
-        # Combine the parallel coverage data files into .coverage .
-        self.run_command("coverage combine")
-        self.assert_exists(".coverage")
+        # Each data file should have a subset of the lines.
+        for data_file in data_files:
+            data = coverage.CoverageData(data_file)
+            data.read()
+            assert line_counts(data)["fork.py"] < total_lines
 
+        # Combine the parallel coverage data files into a .coverage file.
         # After combining, there should be only the .coverage file.
+        self.run_command("coverage combine")
+        self.assert_exists(".coverage")
         self.assert_file_count(".coverage.*", 0)
 
         data = coverage.CoverageData()
         data.read()
-        assert line_counts(data)["fork.py"] == 8
+        assert line_counts(data)["fork.py"] == total_lines
 
         debug_text = open("debug.out").read()
         ppid = pids["parent"]
