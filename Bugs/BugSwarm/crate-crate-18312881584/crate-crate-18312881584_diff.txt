diff --git a/libs/sql-parser/src/main/antlr/io/crate/sql/parser/antlr/SqlBaseParser.g4 b/libs/sql-parser/src/main/antlr/io/crate/sql/parser/antlr/SqlBaseParser.g4
index 06e9d7723d..f57a6e57ff 100644
--- a/libs/sql-parser/src/main/antlr/io/crate/sql/parser/antlr/SqlBaseParser.g4
+++ b/libs/sql-parser/src/main/antlr/io/crate/sql/parser/antlr/SqlBaseParser.g4
@@ -126,7 +126,7 @@ alterStmt
         (SET OPEN_ROUND_BRACKET genericProperties CLOSE_ROUND_BRACKET
         | RESET (OPEN_ROUND_BRACKET ident (COMMA ident)* CLOSE_ROUND_BRACKET)?)      #alterBlobTableProperties
     | ALTER (BLOB)? TABLE alterTableDefinition (OPEN | CLOSE)                        #alterTableOpenClose
-    | ALTER (BLOB)? TABLE alterTableDefinition RENAME TO qname                       #alterTableRenameTable
+    | ALTER (BLOB)? TABLE alterTableDefinition RENAME TO qname                       #alterTableRename
     | ALTER (BLOB)? TABLE alterTableDefinition REROUTE rerouteOption                 #alterTableReroute
     | ALTER CLUSTER REROUTE RETRY FAILED                                             #alterClusterRerouteRetryFailed
     | ALTER CLUSTER SWAP TABLE source=qname TO target=qname withProperties?          #alterClusterSwapTable
diff --git a/libs/sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java b/libs/sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java
index 246efeb227..2250ea1e2e 100644
--- a/libs/sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java
+++ b/libs/sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java
@@ -71,7 +71,7 @@ import io.crate.sql.tree.AlterTable;
 import io.crate.sql.tree.AlterTableAddColumn;
 import io.crate.sql.tree.AlterTableDropColumn;
 import io.crate.sql.tree.AlterTableOpenClose;
-import io.crate.sql.tree.AlterTableRenameTable;
+import io.crate.sql.tree.AlterTableRename;
 import io.crate.sql.tree.AlterTableReroute;
 import io.crate.sql.tree.AlterUser;
 import io.crate.sql.tree.AnalyzeStatement;
@@ -1339,7 +1339,7 @@ class AstBuilder extends SqlBaseParserBaseVisitor<Node> {
 
     @Override
     public Node visitAlterTableRename(SqlBaseParser.AlterTableRenameContext context) {
-        return new AlterTableRenameTable<>(
+        return new AlterTableRename<>(
             (Table<?>) visit(context.alterTableDefinition()),
             context.BLOB() != null,
             getQualifiedName(context.qname())
diff --git a/libs/sql-parser/src/main/java/io/crate/sql/tree/AlterTableRename.java b/libs/sql-parser/src/main/java/io/crate/sql/tree/AlterTableRename.java
new file mode 100644
index 0000000000..a8c92986d6
--- /dev/null
+++ b/libs/sql-parser/src/main/java/io/crate/sql/tree/AlterTableRename.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to Crate.io GmbH ("Crate") under one or more contributor
+ * license agreements.  See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.  Crate licenses
+ * this file to you under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ * However, if you have executed another commercial license agreement
+ * with Crate these terms will supersede the license and you may use the
+ * software solely pursuant to the terms of the relevant commercial agreement.
+ */
+
+package io.crate.sql.tree;
+
+import java.util.Objects;
+
+public class AlterTableRename<T> extends Statement {
+
+    private final Table<T> table;
+    private final boolean blob;
+    private final QualifiedName newName;
+
+    public AlterTableRename(Table<T> table, boolean blob, QualifiedName newName) {
+        this.table = table;
+        this.blob = blob;
+        this.newName = newName;
+    }
+
+    @Override
+    public <R, C> R accept(AstVisitor<R, C> visitor, C context) {
+        return visitor.visitAlterTableRename(this, context);
+    }
+
+    public Table<T> table() {
+        return table;
+    }
+
+    public boolean blob() {
+        return blob;
+    }
+
+    public QualifiedName newName() {
+        return newName;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        AlterTableRename<?> that = (AlterTableRename<?>) o;
+        return blob == that.blob &&
+               Objects.equals(table, that.table) &&
+               Objects.equals(newName, that.newName);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(table, blob, newName);
+    }
+
+    @Override
+    public String toString() {
+        return "AlterTableRename{" +
+               "table=" + table +
+               ", blob=" + blob +
+               ", new name=" + newName +
+               '}';
+    }
+}
diff --git a/libs/sql-parser/src/main/java/io/crate/sql/tree/AstVisitor.java b/libs/sql-parser/src/main/java/io/crate/sql/tree/AstVisitor.java
index a74c50c6f4..459dca168a 100644
--- a/libs/sql-parser/src/main/java/io/crate/sql/tree/AstVisitor.java
+++ b/libs/sql-parser/src/main/java/io/crate/sql/tree/AstVisitor.java
@@ -355,11 +355,11 @@ public abstract class AstVisitor<R, C> {
     public R visitNotNullColumnConstraint(NotNullColumnConstraint<?> node, C context) {
         return visitNode(node, context);
     }
-
+    
     public R visitNullColumnConstraint(NullColumnConstraint<?> node, C context) {
         return visitNode(node, context);
     }
-
+    
     public R visitIndexColumnConstraint(IndexColumnConstraint<?> node, C context) {
         return visitNode(node, context);
     }
@@ -448,7 +448,7 @@ public abstract class AstVisitor<R, C> {
         return visitStatement(node, context);
     }
 
-    public R visitAlterTableRenameTable(AlterTableRenameTable<?> node, C context) {
+    public R visitAlterTableRename(AlterTableRename<?> node, C context) {
         return visitStatement(node, context);
     }
 
diff --git a/libs/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java b/libs/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java
index b2f17ff83a..0ea24a3bae 100644
--- a/libs/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java
+++ b/libs/sql-parser/src/test/java/io/crate/sql/parser/TestStatementBuilder.java
@@ -1791,7 +1791,7 @@ public class TestStatementBuilder {
     }
 
     @Test
-    public void testAlterTableRenameTable() {
+    public void testAlterTableRename() {
         printStatement("alter table t rename to t2");
     }
 
diff --git a/server/src/main/java/io/crate/analyze/AlterTableAnalyzer.java b/server/src/main/java/io/crate/analyze/AlterTableAnalyzer.java
index 05a72297f5..c848fddfd6 100644
--- a/server/src/main/java/io/crate/analyze/AlterTableAnalyzer.java
+++ b/server/src/main/java/io/crate/analyze/AlterTableAnalyzer.java
@@ -40,7 +40,7 @@ import io.crate.metadata.table.Operation;
 import io.crate.sql.tree.AlterBlobTable;
 import io.crate.sql.tree.AlterTable;
 import io.crate.sql.tree.AlterTableOpenClose;
-import io.crate.sql.tree.AlterTableRenameTable;
+import io.crate.sql.tree.AlterTableRename;
 import io.crate.sql.tree.Expression;
 import io.crate.sql.tree.Table;
 
@@ -90,7 +90,7 @@ class AlterTableAnalyzer {
     }
 
 
-    AnalyzedAlterTableRenameTable analyze(AlterTableRenameTable<Expression> node, SessionSettings sessionSettings) {
+    AnalyzedAlterTableRename analyze(AlterTableRename<Expression> node, SessionSettings sessionSettings) {
         if (!node.table().partitionProperties().isEmpty()) {
             throw new UnsupportedOperationException("Renaming a single partition is not supported");
         }
@@ -118,7 +118,7 @@ class AlterTableAnalyzer {
         } catch (RelationUnknown e) {
             schemas.resolveView(node.table().getName(), sessionSettings.searchPath());
         }
-        return new AnalyzedAlterTableRenameTable(sourceName, targetName, isPartitioned);
+        return new AnalyzedAlterTableRename(sourceName, targetName, isPartitioned);
     }
 
     public AnalyzedAlterTableOpenClose analyze(AlterTableOpenClose<Expression> node,
diff --git a/server/src/main/java/io/crate/analyze/AnalyzedAlterTableRename.java b/server/src/main/java/io/crate/analyze/AnalyzedAlterTableRename.java
new file mode 100644
index 0000000000..a7df1db943
--- /dev/null
+++ b/server/src/main/java/io/crate/analyze/AnalyzedAlterTableRename.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to Crate.io GmbH ("Crate") under one or more contributor
+ * license agreements.  See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.  Crate licenses
+ * this file to you under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ * However, if you have executed another commercial license agreement
+ * with Crate these terms will supersede the license and you may use the
+ * software solely pursuant to the terms of the relevant commercial agreement.
+ */
+
+package io.crate.analyze;
+
+import java.util.function.Consumer;
+
+import io.crate.expression.symbol.Symbol;
+import io.crate.metadata.RelationName;
+
+public class AnalyzedAlterTableRename implements DDLStatement {
+
+    private final RelationName sourceName;
+    private final RelationName targetName;
+    private final boolean isPartitioned;
+
+    AnalyzedAlterTableRename(RelationName sourceName, RelationName targetName, boolean isPartitioned) {
+        this.sourceName = sourceName;
+        this.targetName = targetName;
+        this.isPartitioned = isPartitioned;
+    }
+
+    public RelationName sourceName() {
+        return sourceName;
+    }
+
+    public RelationName targetName() {
+        return targetName;
+    }
+
+    public boolean isPartitioned() {
+        return isPartitioned;
+    }
+
+    @Override
+    public <C, R> R accept(AnalyzedStatementVisitor<C, R> analyzedStatementVisitor, C context) {
+        return analyzedStatementVisitor.visitAnalyzedAlterTableRename(this, context);
+    }
+
+    @Override
+    public void visitSymbols(Consumer<? super Symbol> consumer) {
+    }
+}
diff --git a/server/src/main/java/io/crate/analyze/AnalyzedStatementVisitor.java b/server/src/main/java/io/crate/analyze/AnalyzedStatementVisitor.java
index 54dd51f1c6..23bdd4a98e 100644
--- a/server/src/main/java/io/crate/analyze/AnalyzedStatementVisitor.java
+++ b/server/src/main/java/io/crate/analyze/AnalyzedStatementVisitor.java
@@ -95,7 +95,7 @@ public class AnalyzedStatementVisitor<C, R> {
         return visitDDLStatement(analysis, context);
     }
 
-    public R visitAnalyzedAlterTableRenameTable(AnalyzedAlterTableRenameTable analysis, C context) {
+    public R visitAnalyzedAlterTableRename(AnalyzedAlterTableRename analysis, C context) {
         return visitDDLStatement(analysis, context);
     }
 
diff --git a/server/src/main/java/io/crate/analyze/Analyzer.java b/server/src/main/java/io/crate/analyze/Analyzer.java
index 37b7f8d151..e5a63ea0bd 100644
--- a/server/src/main/java/io/crate/analyze/Analyzer.java
+++ b/server/src/main/java/io/crate/analyze/Analyzer.java
@@ -46,7 +46,7 @@ import io.crate.sql.tree.AlterTable;
 import io.crate.sql.tree.AlterTableAddColumn;
 import io.crate.sql.tree.AlterTableDropColumn;
 import io.crate.sql.tree.AlterTableOpenClose;
-import io.crate.sql.tree.AlterTableRenameTable;
+import io.crate.sql.tree.AlterTableRename;
 import io.crate.sql.tree.AlterTableReroute;
 import io.crate.sql.tree.AlterUser;
 import io.crate.sql.tree.AnalyzeStatement;
@@ -303,9 +303,9 @@ public class Analyzer {
         }
 
         @Override
-        public AnalyzedStatement visitAlterTableRenameTable(AlterTableRenameTable<?> node, Analysis context) {
+        public AnalyzedStatement visitAlterTableRename(AlterTableRename<?> node, Analysis context) {
             return alterTableAnalyzer.analyze(
-                (AlterTableRenameTable<Expression>) node,
+                (AlterTableRename<Expression>) node,
                 context.sessionSettings());
         }
 
diff --git a/server/src/main/java/io/crate/auth/AccessControlImpl.java b/server/src/main/java/io/crate/auth/AccessControlImpl.java
index bff0038430..ec72b79a6f 100644
--- a/server/src/main/java/io/crate/auth/AccessControlImpl.java
+++ b/server/src/main/java/io/crate/auth/AccessControlImpl.java
@@ -31,7 +31,7 @@ import io.crate.analyze.AnalyzedAlterTableAddColumn;
 import io.crate.analyze.AnalyzedAlterTableDropCheckConstraint;
 import io.crate.analyze.AnalyzedAlterTableDropColumn;
 import io.crate.analyze.AnalyzedAlterTableOpenClose;
-import io.crate.analyze.AnalyzedAlterTableRenameTable;
+import io.crate.analyze.AnalyzedAlterTableRename;
 import io.crate.analyze.AnalyzedAlterUser;
 import io.crate.analyze.AnalyzedAnalyze;
 import io.crate.analyze.AnalyzedBegin;
@@ -518,7 +518,7 @@ public final class AccessControlImpl implements AccessControl {
         }
 
         @Override
-        public Void visitAnalyzedAlterTableRenameTable(AnalyzedAlterTableRenameTable analysis, User user) {
+        public Void visitAnalyzedAlterTableRename(AnalyzedAlterTableRename analysis, User user) {
             Privileges.ensureUserHasPrivilege(
                 Privilege.Type.DDL,
                 Privilege.Clazz.TABLE,
diff --git a/server/src/main/java/io/crate/execution/ddl/tables/AlterTableOperation.java b/server/src/main/java/io/crate/execution/ddl/tables/AlterTableOperation.java
index 4d010ae4ea..4167e49695 100644
--- a/server/src/main/java/io/crate/execution/ddl/tables/AlterTableOperation.java
+++ b/server/src/main/java/io/crate/execution/ddl/tables/AlterTableOperation.java
@@ -54,7 +54,7 @@ import org.jetbrains.annotations.Nullable;
 import io.crate.action.FutureActionListener;
 import io.crate.action.sql.CollectingResultReceiver;
 import io.crate.action.sql.Sessions;
-import io.crate.analyze.AnalyzedAlterTableRenameTable;
+import io.crate.analyze.AnalyzedAlterTableRename;
 import io.crate.analyze.BoundAlterTable;
 import io.crate.common.annotations.VisibleForTesting;
 import io.crate.data.Row;
@@ -383,7 +383,7 @@ public class AlterTableOperation {
         });
     }
 
-    public CompletableFuture<Long> executeAlterTableRenameTable(AnalyzedAlterTableRenameTable renameTable) {
+    public CompletableFuture<Long> executeAlterTableRenameTable(AnalyzedAlterTableRename renameTable) {
         var request = new RenameTableRequest(renameTable.sourceName(), renameTable.targetName(), renameTable.isPartitioned());
         return transportRenameTableAction.execute(request, r -> -1L);
     }
diff --git a/server/src/main/java/io/crate/planner/Planner.java b/server/src/main/java/io/crate/planner/Planner.java
index 5a543daa1e..541885f28a 100644
--- a/server/src/main/java/io/crate/planner/Planner.java
+++ b/server/src/main/java/io/crate/planner/Planner.java
@@ -39,7 +39,7 @@ import io.crate.analyze.AnalyzedAlterTableAddColumn;
 import io.crate.analyze.AnalyzedAlterTableDropCheckConstraint;
 import io.crate.analyze.AnalyzedAlterTableDropColumn;
 import io.crate.analyze.AnalyzedAlterTableOpenClose;
-import io.crate.analyze.AnalyzedAlterTableRenameTable;
+import io.crate.analyze.AnalyzedAlterTableRename;
 import io.crate.analyze.AnalyzedAlterUser;
 import io.crate.analyze.AnalyzedAnalyze;
 import io.crate.analyze.AnalyzedBegin;
@@ -360,8 +360,8 @@ public class Planner extends AnalyzedStatementVisitor<PlannerContext, Plan> {
     }
 
     @Override
-    public Plan visitAnalyzedAlterTableRenameTable(AnalyzedAlterTableRenameTable analysis,
-                                                   PlannerContext context) {
+    public Plan visitAnalyzedAlterTableRename(AnalyzedAlterTableRename analysis,
+                                              PlannerContext context) {
         return new AlterTableRenameTablePlan(analysis);
     }
 
diff --git a/server/src/main/java/io/crate/planner/node/ddl/AlterTableRenameTablePlan.java b/server/src/main/java/io/crate/planner/node/ddl/AlterTableRenameTablePlan.java
index ab9fd924cb..2bf7d24ee8 100644
--- a/server/src/main/java/io/crate/planner/node/ddl/AlterTableRenameTablePlan.java
+++ b/server/src/main/java/io/crate/planner/node/ddl/AlterTableRenameTablePlan.java
@@ -21,7 +21,7 @@
 
 package io.crate.planner.node.ddl;
 
-import io.crate.analyze.AnalyzedAlterTableRenameTable;
+import io.crate.analyze.AnalyzedAlterTableRename;
 import io.crate.data.Row;
 import io.crate.data.Row1;
 import io.crate.data.RowConsumer;
@@ -33,10 +33,10 @@ import io.crate.planner.operators.SubQueryResults;
 
 public class AlterTableRenameTablePlan implements Plan {
 
-    private final AnalyzedAlterTableRenameTable analyzedAlterTableRenameTable;
+    private final AnalyzedAlterTableRename analyzedAlterTableRename;
 
-    public AlterTableRenameTablePlan(AnalyzedAlterTableRenameTable analyzedAlterTableRenameTable) {
-        this.analyzedAlterTableRenameTable = analyzedAlterTableRenameTable;
+    public AlterTableRenameTablePlan(AnalyzedAlterTableRename analyzedAlterTableRename) {
+        this.analyzedAlterTableRename = analyzedAlterTableRename;
     }
 
     @Override
@@ -49,7 +49,7 @@ public class AlterTableRenameTablePlan implements Plan {
                               PlannerContext plannerContext,
                               RowConsumer consumer,
                               Row params, SubQueryResults subQueryResults) throws Exception {
-        dependencies.alterTableOperation().executeAlterTableRenameTable(analyzedAlterTableRenameTable)
+        dependencies.alterTableOperation().executeAlterTableRenameTable(analyzedAlterTableRename)
             .whenComplete(new OneRowActionListener<>(consumer, rCount -> new Row1(rCount == null ? -1 : rCount)));
     }
 }
diff --git a/server/src/test/java/io/crate/analyze/AlterTableRenameAnalyzerTest.java b/server/src/test/java/io/crate/analyze/AlterTableRenameAnalyzerTest.java
new file mode 100644
index 0000000000..1a6a44998c
--- /dev/null
+++ b/server/src/test/java/io/crate/analyze/AlterTableRenameAnalyzerTest.java
@@ -0,0 +1,99 @@
+/*
+ * Licensed to Crate.io GmbH ("Crate") under one or more contributor
+ * license agreements.  See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.  Crate licenses
+ * this file to you under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ * However, if you have executed another commercial license agreement
+ * with Crate these terms will supersede the license and you may use the
+ * software solely pursuant to the terms of the relevant commercial agreement.
+ */
+
+package io.crate.analyze;
+
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+import java.util.Arrays;
+import java.util.Map;
+
+import org.elasticsearch.Version;
+import org.elasticsearch.cluster.metadata.Metadata;
+import org.elasticsearch.cluster.service.ClusterService;
+import org.junit.Test;
+
+import io.crate.exceptions.InvalidRelationName;
+import io.crate.exceptions.OperationOnInaccessibleRelationException;
+import io.crate.metadata.RelationName;
+import io.crate.replication.logical.metadata.Publication;
+import io.crate.replication.logical.metadata.PublicationsMetadata;
+import io.crate.test.integration.CrateDummyClusterServiceUnitTest;
+import io.crate.testing.SQLExecutor;
+import io.crate.testing.T3;
+
+public class AlterTableRenameAnalyzerTest extends CrateDummyClusterServiceUnitTest {
+
+    @Test
+    public void testRenamePartitionThrowsException() throws Exception {
+        var e = SQLExecutor.builder(clusterService).addTable(T3.T1_DEFINITION).build();
+
+        assertThatThrownBy(() -> e.analyze("alter table t1 partition (i=1) rename to t2"))
+            .isExactlyInstanceOf(UnsupportedOperationException.class)
+            .hasMessage("Renaming a single partition is not supported");
+    }
+
+    @Test
+    public void testRenameToUsingSchemaThrowsException() throws Exception {
+        var e = SQLExecutor.builder(clusterService).addTable(T3.T1_DEFINITION).build();
+
+        assertThatThrownBy(() -> e.analyze("alter table t1 rename to my_schema.t1"))
+            .isExactlyInstanceOf(IllegalArgumentException.class)
+            .hasMessage("Target table name must not include a schema");
+    }
+
+    @Test
+    public void testRenameToInvalidName() throws Exception {
+        var e = SQLExecutor.builder(clusterService).addTable(T3.T1_DEFINITION).build();
+        assertThatThrownBy(() -> e.analyze("alter table t1 rename to \"foo.bar\""))
+            .isExactlyInstanceOf(InvalidRelationName.class)
+            .hasMessageContaining("Relation name \"doc.foo.bar\" is invalid.");
+    }
+
+    @Test
+    public void test_rename_is_not_allowed_when_table_is_published() throws Exception {
+        var clusterService = clusterServiceWithPublicationMetadata(false, new RelationName("doc", "t1"));
+        var executor = SQLExecutor.builder(clusterService).addTable(T3.T1_DEFINITION).build();
+        assertThatThrownBy(() -> executor.analyze("ALTER TABLE t1 rename to t1_renamed"))
+            .isExactlyInstanceOf(OperationOnInaccessibleRelationException.class)
+            .hasMessageContaining(
+                    "The relation \"doc.t1\" doesn't allow ALTER RENAME operations, because it is included in a logical replication publication.");
+        clusterService.close();
+    }
+
+    @Test
+    public void test_rename_is_not_allowed_when_all_tables_are_published() throws Exception {
+        var clusterService = clusterServiceWithPublicationMetadata(true);
+        var executor = SQLExecutor.builder(clusterService).addTable(T3.T1_DEFINITION).build();
+        assertThatThrownBy(() -> executor.analyze("ALTER TABLE t1 rename to t1_renamed"))
+            .isExactlyInstanceOf(OperationOnInaccessibleRelationException.class)
+            .hasMessageContaining(
+                    "The relation \"doc.t1\" doesn't allow ALTER RENAME operations, because it is included in a logical replication publication.");
+        clusterService.close();
+    }
+
+    private ClusterService clusterServiceWithPublicationMetadata(boolean allTablesPublished, RelationName... tables) {
+        var publications = Map.of("pub1", new Publication("user1", allTablesPublished, Arrays.asList(tables)));
+        var publicationsMetadata = new PublicationsMetadata(publications);
+        var metadata = new Metadata.Builder().putCustom(PublicationsMetadata.TYPE, publicationsMetadata).build();
+        return createClusterService(additionalClusterSettings(), metadata, Version.CURRENT);
+    }
+}
diff --git a/server/src/test/java/io/crate/analyze/BlobTableAnalyzerTest.java b/server/src/test/java/io/crate/analyze/BlobTableAnalyzerTest.java
index 298b28cadb..bc1cf3d466 100644
--- a/server/src/test/java/io/crate/analyze/BlobTableAnalyzerTest.java
+++ b/server/src/test/java/io/crate/analyze/BlobTableAnalyzerTest.java
@@ -265,14 +265,14 @@ public class BlobTableAnalyzerTest extends CrateDummyClusterServiceUnitTest {
     }
 
     @Test
-    public void testAlterBlobTableRenameTable() {
+    public void testAlterBlobTableRename() {
         assertThatThrownBy(() -> e.analyze("alter blob table blobs rename to blobbier"))
             .isExactlyInstanceOf(OperationOnInaccessibleRelationException.class)
             .hasMessage("The relation \"blob.blobs\" doesn't support or allow ALTER RENAME operations.");
     }
 
     @Test
-    public void testAlterBlobTableRenameTableWithExplicitSchema() {
+    public void testAlterBlobTableRenameWithExplicitSchema() {
         assertThatThrownBy(() -> e.analyze("alter blob table schema.blobs rename to blobbier"))
             .isExactlyInstanceOf(IllegalArgumentException.class)
             .hasMessage("The Schema \"schema\" isn't valid in a [CREATE | ALTER] BLOB TABLE clause");
diff --git a/server/src/test/java/io/crate/analyze/IsWriteOperationTest.java b/server/src/test/java/io/crate/analyze/IsWriteOperationTest.java
index e4d0bee07a..cf62faa453 100644
--- a/server/src/test/java/io/crate/analyze/IsWriteOperationTest.java
+++ b/server/src/test/java/io/crate/analyze/IsWriteOperationTest.java
@@ -134,7 +134,7 @@ public class IsWriteOperationTest extends CrateDummyClusterServiceUnitTest {
     }
 
     @Test
-    public void testAlterTableRenameTableIsAWriteOperation() {
+    public void testAlterTableRenameIsAWriteOperation() {
         assertWriteOperation("alter table t1 rename to t2");
     }
 
