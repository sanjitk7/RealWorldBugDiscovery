diff --git a/.asf.yaml b/.asf.yaml
index fbda8bf1f18..171dae08921 100644
--- a/.asf.yaml
+++ b/.asf.yaml
@@ -54,3 +54,4 @@ github:
         required_approving_review_count: 1
   collaborators:
     - zhujunxxxxx
+    - wbcfwbe
diff --git a/.github/workflows/nightly-check.yml b/.github/workflows/nightly-check.yml
index 8597fac137f..a4a5e726e21 100644
--- a/.github/workflows/nightly-check.yml
+++ b/.github/workflows/nightly-check.yml
@@ -139,7 +139,7 @@ jobs:
     if: (github.repository == 'apache/shardingsphere')
     name: Check - Dead Links
     runs-on: ubuntu-latest
-    timeout-minutes: 20
+    timeout-minutes: 10
     steps:
       - uses: actions/checkout@v3
       - run: sudo npm install -g markdown-link-check@3.10.0
@@ -149,5 +149,5 @@ jobs:
               if [ -d "$file" ]; then
                 continue
               fi
-            markdown-link-check -c .github/workflows/resources/linkcheck/.dlc.json -q "$file"
+            markdown-link-check -c .github/workflows/resources/linkcheck/markdown-link-check.json -q "$file"
           done
diff --git a/.github/workflows/resources/linkcheck/markdown-link-check.json b/.github/workflows/resources/linkcheck/markdown-link-check.json
new file mode 100644
index 00000000000..7005db9cda4
--- /dev/null
+++ b/.github/workflows/resources/linkcheck/markdown-link-check.json
@@ -0,0 +1,31 @@
+{
+  "ignorePatterns": [
+    {
+      "pattern": "^http://localhost"
+    },
+    {
+      "pattern": "^https://dist.apache.org/repos/dist/release/incubator/shardingsphere/*"
+    },
+    {
+      "pattern": "^https://github.com/apache/incubator-shardingsphere/*"
+    },
+    {
+      "pattern": "^/en/*"
+    },
+    {
+      "pattern": "^/cn/*"
+    },
+    {
+      "pattern": "^https://twitter.com*"
+    }
+  ],
+  "timeout": "10s",
+  "retryOn429": true,
+  "retryCount": 10,
+  "fallbackRetryDelay": "1000s",
+  "aliveStatusCodes": [
+    200,
+    401,
+    403
+  ]
+}
diff --git a/docs/document/content/features/encrypt/limitations.cn.md b/docs/document/content/features/encrypt/limitations.cn.md
index 801db7197b8..ee6baf4ad74 100644
--- a/docs/document/content/features/encrypt/limitations.cn.md
+++ b/docs/document/content/features/encrypt/limitations.cn.md
@@ -7,4 +7,5 @@ weight = 2
 - 模糊查询支持 %、_，暂不支持 escape；
 - 加密字段无法支持查询不区分大小写功能；
 - 加密字段无法支持比较操作，如：大于、小于、ORDER BY、BETWEEN 等；
-- 加密字段无法支持计算操作，如：AVG、SUM 以及计算表达式。
+- 加密字段无法支持计算操作，如：AVG、SUM 以及计算表达式；
+- 当投影子查询中包含加密字段时，必须使用别名。
diff --git a/docs/document/content/features/encrypt/limitations.en.md b/docs/document/content/features/encrypt/limitations.en.md
index e0b3fc36062..635f5e76664 100644
--- a/docs/document/content/features/encrypt/limitations.en.md
+++ b/docs/document/content/features/encrypt/limitations.en.md
@@ -4,7 +4,8 @@ weight = 2
 +++
 
 - You need to process the original data on stocks in the database by yourself.
-- the `like` query supports %, _, but currently does not support escape.
+- The `like` query supports %, _, but currently does not support escape.
 - Case insensitive queries are not supported for the encrypted fields.
 - Comparison operations are not supported for encrypted fields, such as `GREATER THAN`, `LESS THAN`, `ORDER BY`, `BETWEEN`.
 - Calculation operations are not supported for encrypted fields, such as `AVG`, `SUM`, and computation expressions.
+- When projection subquery contains encrypt column, you must use alias.
diff --git a/docs/document/content/user-manual/common-config/props.cn.md b/docs/document/content/user-manual/common-config/props.cn.md
index b4867ff6c09..913cf4648eb 100644
--- a/docs/document/content/user-manual/common-config/props.cn.md
+++ b/docs/document/content/user-manual/common-config/props.cn.md
@@ -17,7 +17,6 @@ Apache ShardingSphere 提供属性配置的方式配置系统级配置。
 | kernel-executor-size (?)           | int     | 用于设置任务处理线程池的大小<br />每个 ShardingSphereDataSource 使用一个独立的线程池，同一个 JVM 的不同数据源不共享线程池                                                     | infinite |
 | max-connections-size-per-query (?) | int     | 一次查询请求在每个数据库实例中所能使用的最大连接数                                                                                                           | 1        |
 | check-table-metadata-enabled (?)   | boolean | 在程序启动和更新时，是否检查分片元数据的结构一致性                                                                                                           | false    |
-| sql-federation-type (?)            | String  | 联邦查询执行器类型，包括：NONE，ORIGINAL，ADVANCED                                                                                                 | NONE     |
 
 ## 操作步骤
 
diff --git a/docs/document/content/user-manual/common-config/props.en.md b/docs/document/content/user-manual/common-config/props.en.md
index 6c9dd092684..7d290d5179f 100644
--- a/docs/document/content/user-manual/common-config/props.en.md
+++ b/docs/document/content/user-manual/common-config/props.en.md
@@ -17,7 +17,6 @@ Apache ShardingSphere provides the way of property configuration to configure sy
 | kernel-executor-size (?)           | int         | The max thread size of worker group to execute SQL. One ShardingSphereDataSource will use a independent thread pool, it does not share thread pool even different data source in same JVM                                                                   | infinite        |
 | max-connections-size-per-query (?) | int         | Max opened connection size for each query                                                                                                                                                                                                                   | 1               |
 | check-table-metadata-enabled (?)   | boolean     | Whether validate table meta data consistency when application startup or updated                                                                                                                                                                            | false           |
-| sql-federation-type (?)            | String      | SQL federation executor type, including: NONE, ORIGINAL, ADVANCED                                                                                                                                                                                           | NONE            | 
 
 ## Procedure
 
diff --git a/docs/document/content/user-manual/shardingsphere-jdbc/java-api/rules/readwrite-splitting.cn.md b/docs/document/content/user-manual/shardingsphere-jdbc/java-api/rules/readwrite-splitting.cn.md
index 4cf082e092d..afd7600c41f 100644
--- a/docs/document/content/user-manual/shardingsphere-jdbc/java-api/rules/readwrite-splitting.cn.md
+++ b/docs/document/content/user-manual/shardingsphere-jdbc/java-api/rules/readwrite-splitting.cn.md
@@ -30,7 +30,7 @@ Java API 形式配置的读写分离可以方便的适用于各种场景，不
 |------------------------------------|--------------------------------|-----------------------------------------------------------------------------|----------|
 | name                               | String                         | 读写分离数据源名称                                                                   | -        |
 | writeDataSourceName                | String                         | 写库数据源名称                                                                     | -        |
-| readDataSourceNames                | List\<String\>                 | 写库数据源名称                                                                     | -        |
+| readDataSourceNames                | List\<String\>                 | 读库数据源名称                                                                     | -        |
 | transactionalReadQueryStrategy (?) | TransactionalReadQueryStrategy | 事务内读请求的路由策略，可选值：PRIMARY（路由至主库）、FIXED（同一事务内路由至固定数据源）、DYNAMIC（同一事务内路由至非固定数据源） | DYNAMIC  |
 | loadBalancerName (?)               | String                         | 读库负载均衡算法名称                                                                  | 轮询负载均衡算法 |
 
diff --git a/docs/document/content/user-manual/shardingsphere-jdbc/yaml-config/jdbc-driver/_index.cn.md b/docs/document/content/user-manual/shardingsphere-jdbc/yaml-config/jdbc-driver/_index.cn.md
index bb6edac2efc..642176d19c1 100644
--- a/docs/document/content/user-manual/shardingsphere-jdbc/yaml-config/jdbc-driver/_index.cn.md
+++ b/docs/document/content/user-manual/shardingsphere-jdbc/yaml-config/jdbc-driver/_index.cn.md
@@ -90,5 +90,5 @@ jdbc:shardingsphere:classpath:config.yaml
 
 加载绝对路径中 config.yaml 配置文件的 JDBC URL：
 ```
-jdbc:shardingsphere:absolutepath/path/to/config.yaml
+jdbc:shardingsphere:absolutepath:/path/to/config.yaml
 ```
diff --git a/docs/document/content/user-manual/shardingsphere-jdbc/yaml-config/jdbc-driver/_index.en.md b/docs/document/content/user-manual/shardingsphere-jdbc/yaml-config/jdbc-driver/_index.en.md
index 8f9b91da000..292f2650156 100644
--- a/docs/document/content/user-manual/shardingsphere-jdbc/yaml-config/jdbc-driver/_index.en.md
+++ b/docs/document/content/user-manual/shardingsphere-jdbc/yaml-config/jdbc-driver/_index.en.md
@@ -90,5 +90,5 @@ jdbc:shardingsphere:classpath:config.yaml
 
 Load JDBC URL of config.yaml profile in absolute path
 ```
-jdbc:shardingsphere:absolutepath/path/to/config.yaml
+jdbc:shardingsphere:absolutepath:/path/to/config.yaml
 ```
diff --git a/docs/document/content/user-manual/shardingsphere-proxy/yaml-config/props.cn.md b/docs/document/content/user-manual/shardingsphere-proxy/yaml-config/props.cn.md
index f755b1e27b0..adc42f33939 100644
--- a/docs/document/content/user-manual/shardingsphere-proxy/yaml-config/props.cn.md
+++ b/docs/document/content/user-manual/shardingsphere-proxy/yaml-config/props.cn.md
@@ -22,7 +22,6 @@ Apache ShardingSphere 提供了丰富的系统配置属性，用户可通过 `se
 | proxy-backend-query-fetch-size (?)        | int       | Proxy 后端与数据库交互的每次获取数据行数（使用游标的情况下）。数值增大可能会增加 ShardingSphere Proxy 的内存使用。默认值为 -1，代表设置为 JDBC 驱动的最小值。                                      | -1       | 是      |
 | proxy-frontend-executor-size (?)          | int       | Proxy 前端 Netty 线程池线程数量，默认值 0 代表使用 Netty 默认值。                                                                                           | 0        | 否      |
 | proxy-frontend-max-connections (?)        | int       | 允许连接 Proxy 的最大客户端数量，默认值 0 代表不限制。                                                                                                       | 0        | 是      |
-| sql-federation-type (?)                   | String    | 联邦查询执行器类型，包括：NONE，ORIGINAL，ADVANCED。                                                                                                   | NONE     | 是      |
 | proxy-default-port (?)                    | String    | Proxy 通过配置文件指定默认端口。                                                                                                                    | 3307     | 否      |
 | proxy-netty-backlog (?)                   | int       | Proxy 通过配置文件指定默认netty back_log参数。                                                                                                      | 1024     | 否      |
 | proxy-frontend-database-protocol-type (?) | String    | Proxy 前端协议类型，支持 MySQL，PostgreSQL 和 openGauss                                                                                           | \"\"     | 否      |
diff --git a/docs/document/content/user-manual/shardingsphere-proxy/yaml-config/props.en.md b/docs/document/content/user-manual/shardingsphere-proxy/yaml-config/props.en.md
index cfb3e281698..82adecd658d 100644
--- a/docs/document/content/user-manual/shardingsphere-proxy/yaml-config/props.en.md
+++ b/docs/document/content/user-manual/shardingsphere-proxy/yaml-config/props.en.md
@@ -22,7 +22,6 @@ Apache ShardingSphere provides a wealth of system configuration properties, whic
 | proxy-backend-query-fetch-size (?)        | int         | The number of rows of data obtained when the backend Proxy interacts with databases (using a cursor). A larger number may increase the occupied memory of ShardingSphere-Proxy. The default value of -1 indicates the minimum value for JDBC driver.                                               | -1              | True             |
 | proxy-frontend-executor-size (?)          | int         | The number of threads in the Netty thread pool of front-end Proxy.                                                                                                                                                                                                                                 | 0               | False            |
 | proxy-frontend-max-connections (?)        | int         | The maximum number of clients that can be connected to Proxy. The default value of 0 indicates that there's no limit.                                                                                                                                                                              | 0               | True             |
-| sql-federation-type (?)                   | String      | SQL federation executor type, including: NONE, ORIGINAL, ADVANCED.                                                                                                                                                                                                                                 | NONE            | True             |
 | proxy-default-port (?)                    | String      | Proxy specifies the default window through configuration files.                                                                                                                                                                                                                                    | 3307            | False            |
 | proxy-netty-backlog (?)                   | int         | Proxy specifies the default netty back_log parameter through configuration files.                                                                                                                                                                                                                  | 1024            | False            |
 | proxy-frontend-database-protocol-type (?) | String      | Proxy front-end protocol type, supports MySQL, PostgreSQL, openGauss                                                                                                                                                                                                                               | \"\"            | False            |
diff --git a/examples/shardingsphere-example-generator/src/main/resources/template/jdbc/java/config/Configuration.ftl b/examples/shardingsphere-example-generator/src/main/resources/template/jdbc/java/config/Configuration.ftl
index f187c08ca58..94ddf5c34cf 100644
--- a/examples/shardingsphere-example-generator/src/main/resources/template/jdbc/java/config/Configuration.ftl
+++ b/examples/shardingsphere-example-generator/src/main/resources/template/jdbc/java/config/Configuration.ftl
@@ -43,6 +43,7 @@ import org.apache.shardingsphere.readwritesplitting.api.rule.ReadwriteSplittingD
 <#if feature?contains("encrypt")>
 import org.apache.shardingsphere.infra.config.algorithm.AlgorithmConfiguration;
 import org.apache.shardingsphere.encrypt.api.config.EncryptRuleConfiguration;
+import org.apache.shardingsphere.encrypt.api.config.rule.EncryptColumnItemRuleConfiguration;
 import org.apache.shardingsphere.encrypt.api.config.rule.EncryptColumnRuleConfiguration;
 import org.apache.shardingsphere.encrypt.api.config.rule.EncryptTableRuleConfiguration;
 </#if>
diff --git a/examples/shardingsphere-example-generator/src/main/resources/template/jdbc/java/config/encrypt.ftl b/examples/shardingsphere-example-generator/src/main/resources/template/jdbc/java/config/encrypt.ftl
index 22d5b8e330b..71ed2c3bcf5 100644
--- a/examples/shardingsphere-example-generator/src/main/resources/template/jdbc/java/config/encrypt.ftl
+++ b/examples/shardingsphere-example-generator/src/main/resources/template/jdbc/java/config/encrypt.ftl
@@ -18,12 +18,14 @@
     private EncryptRuleConfiguration createEncryptRuleConfiguration() {
         Properties props = new Properties();
         props.setProperty("aes-key-value", "123456");
-        EncryptColumnRuleConfiguration columnConfigAes = new EncryptColumnRuleConfiguration("phone", "phone", "", "", "phone_plain", "phone_encryptor", null);
-        EncryptColumnRuleConfiguration columnConfigTest = new EncryptColumnRuleConfiguration("status", "status", "assisted_query_status", "", "", "string_encryptor", "string_encryptor", null, null);
-        EncryptTableRuleConfiguration orderItemRule = new EncryptTableRuleConfiguration("t_order_item", Collections.singleton(columnConfigAes), true);
-        EncryptTableRuleConfiguration orderRule = new EncryptTableRuleConfiguration("t_order", Collections.singleton(columnConfigTest), true);
+        EncryptColumnRuleConfiguration columnConfigAes = new EncryptColumnRuleConfiguration("phone", new EncryptColumnItemRuleConfiguration("phone", "standard_encryptor"));
+        EncryptTableRuleConfiguration orderItemRule = new EncryptTableRuleConfiguration("t_order_item", Collections.singleton(columnConfigAes));
+        EncryptColumnRuleConfiguration statusColumnConfig =
+            new EncryptColumnRuleConfiguration("status", new EncryptColumnItemRuleConfiguration("status", "standard_encryptor"));
+        statusColumnConfig.setAssistedQuery(new EncryptColumnItemRuleConfiguration("status_assisted", "assisted_encryptor"));
+        EncryptTableRuleConfiguration orderRule = new EncryptTableRuleConfiguration("t_order", Collections.singleton(statusColumnConfig)); 
         Map<String, AlgorithmConfiguration> encryptAlgorithmConfigs = new LinkedHashMap<>();
-        encryptAlgorithmConfigs.put("phone_encryptor", new AlgorithmConfiguration("AES", props));
-        encryptAlgorithmConfigs.put("string_encryptor", new AlgorithmConfiguration("assistedTest", props));
+        encryptAlgorithmConfigs.put("standard_encryptor", new AlgorithmConfiguration("AES", props));
+        encryptAlgorithmConfigs.put("assisted_encryptor", new AlgorithmConfiguration("assistedTest", props));
         return new EncryptRuleConfiguration(Arrays.asList(orderRule, orderItemRule), encryptAlgorithmConfigs);
     }
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dal/show/EncryptShowColumnsMergedResult.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dal/show/EncryptShowColumnsMergedResult.java
index a49054fece7..1ff7ac08fef 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dal/show/EncryptShowColumnsMergedResult.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dal/show/EncryptShowColumnsMergedResult.java
@@ -26,6 +26,7 @@ import org.apache.shardingsphere.infra.merge.result.MergedResult;
 import org.apache.shardingsphere.infra.util.exception.ShardingSpherePreconditions;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.sql.SQLFeatureNotSupportedException;
 import java.util.Calendar;
@@ -94,6 +95,11 @@ public abstract class EncryptShowColumnsMergedResult implements MergedResult {
         throw new SQLFeatureNotSupportedException("");
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        throw new SQLFeatureNotSupportedException("");
+    }
+    
     protected abstract boolean nextValue() throws SQLException;
     
     protected abstract Object getOriginalValue(int columnIndex, Class<?> type) throws SQLException;
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dal/show/EncryptShowCreateTableMergedResult.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dal/show/EncryptShowCreateTableMergedResult.java
index d8c4d210527..f80cc9c703d 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dal/show/EncryptShowCreateTableMergedResult.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dal/show/EncryptShowCreateTableMergedResult.java
@@ -27,6 +27,7 @@ import org.apache.shardingsphere.infra.merge.result.MergedResult;
 import org.apache.shardingsphere.infra.util.exception.ShardingSpherePreconditions;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.sql.SQLFeatureNotSupportedException;
 import java.util.Calendar;
@@ -105,6 +106,11 @@ public abstract class EncryptShowCreateTableMergedResult implements MergedResult
         throw new SQLFeatureNotSupportedException("");
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        throw new SQLFeatureNotSupportedException("");
+    }
+    
     protected abstract boolean nextValue() throws SQLException;
     
     protected abstract Object getOriginalValue(int columnIndex, Class<?> type) throws SQLException;
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptAlgorithmMetaData.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptAlgorithmMetaData.java
index b44fd039987..293a5784eaf 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptAlgorithmMetaData.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptAlgorithmMetaData.java
@@ -18,12 +18,13 @@
 package org.apache.shardingsphere.encrypt.merge.dql;
 
 import lombok.RequiredArgsConstructor;
+import org.apache.shardingsphere.encrypt.api.context.EncryptContext;
 import org.apache.shardingsphere.encrypt.api.encrypt.standard.StandardEncryptAlgorithm;
 import org.apache.shardingsphere.encrypt.context.EncryptContextBuilder;
 import org.apache.shardingsphere.encrypt.rule.EncryptRule;
-import org.apache.shardingsphere.encrypt.api.context.EncryptContext;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.SubqueryProjection;
 import org.apache.shardingsphere.infra.binder.segment.table.TablesContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
 import org.apache.shardingsphere.infra.database.type.DatabaseTypeEngine;
@@ -83,7 +84,13 @@ public final class EncryptAlgorithmMetaData {
             return Optional.empty();
         }
         Projection projection = expandProjections.get(columnIndex - 1);
-        return projection instanceof ColumnProjection ? Optional.of((ColumnProjection) projection) : Optional.empty();
+        if (projection instanceof ColumnProjection) {
+            return Optional.of((ColumnProjection) projection);
+        }
+        if (projection instanceof SubqueryProjection && ((SubqueryProjection) projection).getProjection() instanceof ColumnProjection) {
+            return Optional.of((ColumnProjection) ((SubqueryProjection) projection).getProjection());
+        }
+        return Optional.empty();
     }
     
     private Optional<String> findTableName(final ColumnProjection columnProjection, final Map<String, String> columnTableNames) {
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptMergedResult.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptMergedResult.java
index 6bc4ce2d890..1f59aba4349 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptMergedResult.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptMergedResult.java
@@ -23,6 +23,7 @@ import org.apache.shardingsphere.encrypt.api.context.EncryptContext;
 import org.apache.shardingsphere.infra.merge.result.MergedResult;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 import java.util.Optional;
@@ -67,6 +68,11 @@ public final class EncryptMergedResult implements MergedResult {
         return mergedResult.getInputStream(columnIndex, type);
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        return mergedResult.getCharacterStream(columnIndex);
+    }
+    
     @Override
     public boolean wasNull() throws SQLException {
         return mergedResult.wasNull();
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptCreateTableTokenGenerator.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptCreateTableTokenGenerator.java
index 34c146ccc4d..8799a76a153 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptCreateTableTokenGenerator.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptCreateTableTokenGenerator.java
@@ -21,6 +21,7 @@ import lombok.Setter;
 import org.apache.shardingsphere.encrypt.api.encrypt.standard.StandardEncryptAlgorithm;
 import org.apache.shardingsphere.encrypt.rewrite.aware.EncryptRuleAware;
 import org.apache.shardingsphere.encrypt.rule.EncryptRule;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.ddl.CreateTableStatementContext;
@@ -99,7 +100,7 @@ public final class EncryptCreateTableTokenGenerator implements CollectionSQLToke
                 getColumnProjections(new IdentifierValue(optional, column.getColumnName().getIdentifier().getQuoteCharacter())), lastColumn));
     }
     
-    private Collection<ColumnProjection> getColumnProjections(final IdentifierValue columnIdentifier) {
+    private Collection<Projection> getColumnProjections(final IdentifierValue columnIdentifier) {
         return Collections.singletonList(new ColumnProjection(null, columnIdentifier, null));
     }
 }
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptIndexColumnTokenGenerator.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptIndexColumnTokenGenerator.java
index 6846c421df4..f2048c64f6d 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptIndexColumnTokenGenerator.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptIndexColumnTokenGenerator.java
@@ -21,6 +21,7 @@ import com.google.common.base.Preconditions;
 import lombok.Setter;
 import org.apache.shardingsphere.encrypt.rewrite.aware.EncryptRuleAware;
 import org.apache.shardingsphere.encrypt.rule.EncryptRule;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.type.IndexAvailable;
@@ -73,17 +74,17 @@ public final class EncryptIndexColumnTokenGenerator implements CollectionSQLToke
     }
     
     private Optional<SQLToken> getAssistedQueryColumnToken(final int startIndex, final int stopIndex, final String columnName, final QuoteCharacter quoteCharacter) {
-        Collection<ColumnProjection> columnProjections = getColumnProjections(columnName, quoteCharacter);
-        return Optional.of(new SubstitutableColumnNameToken(startIndex, stopIndex, columnProjections, quoteCharacter, Collections.emptyList()));
+        Collection<Projection> columnProjections = getColumnProjections(columnName, quoteCharacter);
+        return Optional.of(new SubstitutableColumnNameToken(startIndex, stopIndex, columnProjections, quoteCharacter));
     }
     
     private Optional<SQLToken> getCipherColumnToken(final String tableName, final int startIndex, final int stopIndex, final String columnName, final QuoteCharacter quoteCharacter) {
         String cipherColumn = encryptRule.getCipherColumn(tableName, columnName);
-        Collection<ColumnProjection> columnProjections = getColumnProjections(cipherColumn, quoteCharacter);
-        return Optional.of(new SubstitutableColumnNameToken(startIndex, stopIndex, columnProjections, quoteCharacter, Collections.emptyList()));
+        Collection<Projection> columnProjections = getColumnProjections(cipherColumn, quoteCharacter);
+        return Optional.of(new SubstitutableColumnNameToken(startIndex, stopIndex, columnProjections, quoteCharacter));
     }
     
-    private Collection<ColumnProjection> getColumnProjections(final String columnName, final QuoteCharacter quoteCharacter) {
+    private Collection<Projection> getColumnProjections(final String columnName, final QuoteCharacter quoteCharacter) {
         return Collections.singletonList(new ColumnProjection(null, new IdentifierValue(columnName, quoteCharacter), null));
     }
 }
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptOrderByItemTokenGenerator.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptOrderByItemTokenGenerator.java
index 8aaf70eb0c5..0a3d51b2f2d 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptOrderByItemTokenGenerator.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptOrderByItemTokenGenerator.java
@@ -22,6 +22,7 @@ import org.apache.shardingsphere.encrypt.rewrite.aware.EncryptRuleAware;
 import org.apache.shardingsphere.encrypt.rule.EncryptRule;
 import org.apache.shardingsphere.encrypt.rule.EncryptTable;
 import org.apache.shardingsphere.infra.binder.segment.select.orderby.OrderByItem;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
@@ -124,7 +125,7 @@ public final class EncryptOrderByItemTokenGenerator implements CollectionSQLToke
         return false;
     }
     
-    private Collection<ColumnProjection> createColumnProjections(final String columnName, final QuoteCharacter quoteCharacter) {
+    private Collection<Projection> createColumnProjections(final String columnName, final QuoteCharacter quoteCharacter) {
         return Collections.singletonList(new ColumnProjection(null, new IdentifierValue(columnName, quoteCharacter), null));
     }
 }
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptPredicateColumnTokenGenerator.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptPredicateColumnTokenGenerator.java
index ff99bafa75d..b024e90f38f 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptPredicateColumnTokenGenerator.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptPredicateColumnTokenGenerator.java
@@ -22,6 +22,7 @@ import org.apache.shardingsphere.encrypt.exception.syntax.UnsupportedEncryptSQLE
 import org.apache.shardingsphere.encrypt.rewrite.aware.EncryptRuleAware;
 import org.apache.shardingsphere.encrypt.rule.EncryptRule;
 import org.apache.shardingsphere.encrypt.rule.EncryptTable;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.type.WhereAvailable;
@@ -102,7 +103,7 @@ public final class EncryptPredicateColumnTokenGenerator implements CollectionSQL
             ShardingSpherePreconditions.checkState(likeQueryColumn.isPresent(), () -> new UnsupportedEncryptSQLException("LIKE"));
             return new SubstitutableColumnNameToken(startIndex, stopIndex, createColumnProjections(likeQueryColumn.get(), columnSegment.getIdentifier().getQuoteCharacter()));
         }
-        Collection<ColumnProjection> columnProjections =
+        Collection<Projection> columnProjections =
                 encryptTable.findAssistedQueryColumn(logicColumn).map(optional -> createColumnProjections(optional, columnSegment.getIdentifier().getQuoteCharacter()))
                         .orElseGet(() -> createColumnProjections(encryptTable.getCipherColumn(logicColumn),
                                 columnSegment.getIdentifier().getQuoteCharacter()));
@@ -135,7 +136,7 @@ public final class EncryptPredicateColumnTokenGenerator implements CollectionSQL
         return columnSegment instanceof ColumnSegment && columnSegment.getStartIndex() == targetColumnSegment.getStartIndex() && columnSegment.getStopIndex() == targetColumnSegment.getStopIndex();
     }
     
-    private Collection<ColumnProjection> createColumnProjections(final String columnName, final QuoteCharacter quoteCharacter) {
+    private Collection<Projection> createColumnProjections(final String columnName, final QuoteCharacter quoteCharacter) {
         return Collections.singletonList(new ColumnProjection(null, new IdentifierValue(columnName, quoteCharacter), null));
     }
 }
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptProjectionTokenGenerator.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptProjectionTokenGenerator.java
index 19904b6c759..915ba0aa714 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptProjectionTokenGenerator.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/EncryptProjectionTokenGenerator.java
@@ -82,49 +82,52 @@ public final class EncryptProjectionTokenGenerator implements CollectionSQLToken
     
     private void addGenerateSQLTokens(final Collection<SQLToken> result, final SelectStatementContext selectStatementContext) {
         Map<String, String> columnTableNames = getColumnTableNames(selectStatementContext);
-        for (ProjectionSegment projection : selectStatementContext.getSqlStatement().getProjections().getProjections()) {
+        for (ProjectionSegment each : selectStatementContext.getSqlStatement().getProjections().getProjections()) {
             SubqueryType subqueryType = selectStatementContext.getSubqueryType();
-            if (projection instanceof ColumnProjectionSegment) {
-                ColumnProjectionSegment columnSegment = (ColumnProjectionSegment) projection;
+            if (each instanceof ColumnProjectionSegment) {
+                ColumnProjectionSegment columnSegment = (ColumnProjectionSegment) each;
                 ColumnProjection columnProjection = buildColumnProjection(columnSegment);
                 String tableName = columnTableNames.get(columnProjection.getExpression());
-                if (null != tableName && encryptRule.findEncryptColumn(tableName, columnProjection.getName()).isPresent()) {
+                if (isEncryptColumn(tableName, columnProjection.getName())) {
                     result.add(generateSQLToken(tableName, columnSegment, columnProjection, subqueryType));
                 }
             }
-            if (projection instanceof ShorthandProjectionSegment) {
-                ShorthandProjectionSegment shorthandSegment = (ShorthandProjectionSegment) projection;
-                Collection<ColumnProjection> columnProjections = getShorthandProjection(shorthandSegment, selectStatementContext.getProjectionsContext()).getColumnProjections();
-                if (!columnProjections.isEmpty()) {
-                    result.add(generateSQLToken(shorthandSegment, columnProjections, selectStatementContext, subqueryType, columnTableNames));
+            if (each instanceof ShorthandProjectionSegment) {
+                ShorthandProjectionSegment shorthandSegment = (ShorthandProjectionSegment) each;
+                Collection<Projection> actualColumns = getShorthandProjection(shorthandSegment, selectStatementContext.getProjectionsContext()).getActualColumns();
+                if (!actualColumns.isEmpty()) {
+                    result.add(generateSQLToken(shorthandSegment, actualColumns, selectStatementContext, subqueryType, columnTableNames));
                 }
             }
         }
     }
     
+    private boolean isEncryptColumn(final String tableName, final String columnName) {
+        return null != tableName && encryptRule.findEncryptColumn(tableName, columnName).isPresent();
+    }
+    
     private SubstitutableColumnNameToken generateSQLToken(final String tableName, final ColumnProjectionSegment columnSegment,
                                                           final ColumnProjection columnProjection, final SubqueryType subqueryType) {
-        Collection<ColumnProjection> projections = generateProjections(tableName, columnProjection, subqueryType, false, null);
+        Collection<Projection> projections = generateProjections(tableName, columnProjection, subqueryType, false, null);
         int startIndex = columnSegment.getColumn().getOwner().isPresent() ? columnSegment.getColumn().getOwner().get().getStopIndex() + 2 : columnSegment.getColumn().getStartIndex();
         int stopIndex = columnSegment.getStopIndex();
         return new SubstitutableColumnNameToken(startIndex, stopIndex, projections);
     }
     
-    private SubstitutableColumnNameToken generateSQLToken(final ShorthandProjectionSegment segment, final Collection<ColumnProjection> columnProjections,
+    private SubstitutableColumnNameToken generateSQLToken(final ShorthandProjectionSegment segment, final Collection<Projection> actualColumns,
                                                           final SelectStatementContext selectStatementContext, final SubqueryType subqueryType, final Map<String, String> columnTableNames) {
-        List<ColumnProjection> projections = new LinkedList<>();
-        for (ColumnProjection each : columnProjections) {
+        List<Projection> projections = new LinkedList<>();
+        for (Projection each : actualColumns) {
             String tableName = columnTableNames.get(each.getExpression());
-            if (null == tableName || !encryptRule.findStandardEncryptor(tableName, each.getName()).isPresent()) {
-                projections.add(new ColumnProjection(each.getOwnerIdentifier(), each.getNameIdentifier(), each.getAlias().isPresent() ? each.getAliasIdentifier() : null));
-            } else {
-                projections.addAll(generateProjections(tableName, each, subqueryType, true, segment));
+            if (!isEncryptColumn(tableName, each.getColumnLabel())) {
+                projections.add(each.getAlias().map(optional -> (Projection) new ColumnProjection(null, optional, null)).orElse(each));
+            } else if (each instanceof ColumnProjection) {
+                projections.addAll(generateProjections(tableName, (ColumnProjection) each, subqueryType, true, segment));
             }
         }
         int startIndex = segment.getOwner().isPresent() ? segment.getOwner().get().getStartIndex() : segment.getStartIndex();
         previousSQLTokens.removeIf(each -> each.getStartIndex() == startIndex);
-        return new SubstitutableColumnNameToken(startIndex, segment.getStopIndex(), projections, selectStatementContext.getDatabaseType().getQuoteCharacter(),
-                selectStatementContext.getTablesContext().getTableSegments());
+        return new SubstitutableColumnNameToken(startIndex, segment.getStopIndex(), projections, selectStatementContext.getDatabaseType().getQuoteCharacter());
     }
     
     private ColumnProjection buildColumnProjection(final ColumnProjectionSegment segment) {
@@ -147,9 +150,9 @@ public final class EncryptProjectionTokenGenerator implements CollectionSQLToken
         return selectStatementContext.getTablesContext().findTableNamesByColumnProjection(columns, schema);
     }
     
-    private Collection<ColumnProjection> generateProjections(final String tableName, final ColumnProjection column, final SubqueryType subqueryType, final boolean shorthand,
-                                                             final ShorthandProjectionSegment segment) {
-        Collection<ColumnProjection> result = new LinkedList<>();
+    private Collection<Projection> generateProjections(final String tableName, final ColumnProjection column, final SubqueryType subqueryType, final boolean shorthand,
+                                                       final ShorthandProjectionSegment segment) {
+        Collection<Projection> result = new LinkedList<>();
         if (SubqueryType.PREDICATE_SUBQUERY == subqueryType) {
             result.add(distinctOwner(generatePredicateSubqueryProjection(tableName, column), shorthand));
         } else if (SubqueryType.TABLE_SUBQUERY == subqueryType) {
diff --git a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/InsertCipherNameTokenGenerator.java b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/InsertCipherNameTokenGenerator.java
index ba458e4577a..aea76521fdd 100644
--- a/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/InsertCipherNameTokenGenerator.java
+++ b/features/encrypt/core/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/InsertCipherNameTokenGenerator.java
@@ -19,8 +19,9 @@ package org.apache.shardingsphere.encrypt.rewrite.token.generator;
 
 import com.google.common.base.Preconditions;
 import lombok.Setter;
-import org.apache.shardingsphere.encrypt.rule.EncryptRule;
 import org.apache.shardingsphere.encrypt.rewrite.aware.EncryptRuleAware;
+import org.apache.shardingsphere.encrypt.rule.EncryptRule;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.InsertStatementContext;
@@ -29,7 +30,6 @@ import org.apache.shardingsphere.infra.rewrite.sql.token.pojo.SQLToken;
 import org.apache.shardingsphere.infra.rewrite.sql.token.pojo.generic.SubstitutableColumnNameToken;
 import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.column.ColumnSegment;
 import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.column.InsertColumnsSegment;
-import org.apache.shardingsphere.sql.parser.sql.common.value.identifier.IdentifierValue;
 
 import java.util.Collection;
 import java.util.Collections;
@@ -62,8 +62,7 @@ public final class InsertCipherNameTokenGenerator implements CollectionSQLTokenG
         Collection<SQLToken> result = new LinkedList<>();
         for (ColumnSegment each : sqlSegment.get().getColumns()) {
             if (logicAndCipherColumns.containsKey(each.getIdentifier().getValue())) {
-                Collection<ColumnProjection> projections = Collections.singletonList(new ColumnProjection(null, new IdentifierValue(logicAndCipherColumns.get(each.getIdentifier().getValue()),
-                        each.getIdentifier().getQuoteCharacter()), null));
+                Collection<Projection> projections = Collections.singletonList(new ColumnProjection(null, logicAndCipherColumns.get(each.getIdentifier().getValue()), null));
                 result.add(new SubstitutableColumnNameToken(each.getStartIndex(), each.getStopIndex(), projections));
             }
         }
diff --git a/features/encrypt/core/src/test/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptAlgorithmMetaDataTest.java b/features/encrypt/core/src/test/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptAlgorithmMetaDataTest.java
index f6edd85e328..873ae5b50cd 100644
--- a/features/encrypt/core/src/test/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptAlgorithmMetaDataTest.java
+++ b/features/encrypt/core/src/test/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptAlgorithmMetaDataTest.java
@@ -24,6 +24,7 @@ import org.apache.shardingsphere.encrypt.spi.EncryptAlgorithm;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.ProjectionsContext;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.DerivedProjection;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.SubqueryProjection;
 import org.apache.shardingsphere.infra.binder.segment.table.TablesContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
 import org.apache.shardingsphere.infra.database.DefaultDatabase;
@@ -108,6 +109,22 @@ class EncryptAlgorithmMetaDataTest {
         assertThat(actual.get().getColumnName(), is("id"));
     }
     
+    @Test
+    void assertFindEncryptContextWhenSubqueryContainsEncryptColumn() {
+        ColumnProjection columnProjection = new ColumnProjection(null, "user_name", null);
+        Map<String, String> columnTableNames = new HashMap<>();
+        columnTableNames.put(columnProjection.getExpression(), "t_user");
+        when(projectionsContext.getExpandProjections())
+                .thenReturn(Collections.singletonList(new SubqueryProjection("(SELECT user_name FROM t_user)", columnProjection, null, new MySQLDatabaseType())));
+        when(tablesContext.findTableNamesByColumnProjection(Collections.singletonList(columnProjection), schema)).thenReturn(columnTableNames);
+        EncryptAlgorithmMetaData encryptAlgorithmMetaData = new EncryptAlgorithmMetaData(database, encryptRule, selectStatementContext);
+        Optional<EncryptContext> actual = encryptAlgorithmMetaData.findEncryptContext(1);
+        assertTrue(actual.isPresent());
+        assertThat(actual.get().getDatabaseName(), is(DefaultDatabase.LOGIC_NAME));
+        assertThat(actual.get().getTableName(), is("t_user"));
+        assertThat(actual.get().getColumnName(), is("user_name"));
+    }
+    
     @Test
     void assertFindEncryptContextByStatementContext() {
         when(tablesContext.findTableNamesByColumnProjection(Collections.singletonList(columnProjection), schema)).thenReturn(Collections.emptyMap());
diff --git a/features/encrypt/core/src/test/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptMergedResultTest.java b/features/encrypt/core/src/test/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptMergedResultTest.java
index 047d903db5c..34124e20248 100644
--- a/features/encrypt/core/src/test/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptMergedResultTest.java
+++ b/features/encrypt/core/src/test/java/org/apache/shardingsphere/encrypt/merge/dql/EncryptMergedResultTest.java
@@ -24,6 +24,7 @@ import org.mockito.Mock;
 import org.mockito.junit.jupiter.MockitoExtension;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 import java.util.Date;
@@ -70,6 +71,13 @@ class EncryptMergedResultTest {
         assertThat(new EncryptMergedResult(metaData, mergedResult).getInputStream(1, "asc"), is(inputStream));
     }
     
+    @Test
+    void assertGetCharacterStream() throws SQLException {
+        Reader reader = mock(Reader.class);
+        when(mergedResult.getCharacterStream(1)).thenReturn(reader);
+        assertThat(new EncryptMergedResult(metaData, mergedResult).getCharacterStream(1), is(reader));
+    }
+    
     @Test
     void assertWasNull() throws SQLException {
         assertFalse(new EncryptMergedResult(metaData, mergedResult).wasNull());
diff --git a/features/encrypt/distsql/parser/src/main/java/org/apache/shardingsphere/encrypt/distsql/parser/core/EncryptDistSQLStatementVisitor.java b/features/encrypt/distsql/parser/src/main/java/org/apache/shardingsphere/encrypt/distsql/parser/core/EncryptDistSQLStatementVisitor.java
index 855018df646..54fbe703b00 100644
--- a/features/encrypt/distsql/parser/src/main/java/org/apache/shardingsphere/encrypt/distsql/parser/core/EncryptDistSQLStatementVisitor.java
+++ b/features/encrypt/distsql/parser/src/main/java/org/apache/shardingsphere/encrypt/distsql/parser/core/EncryptDistSQLStatementVisitor.java
@@ -87,11 +87,16 @@ public final class EncryptDistSQLStatementVisitor extends EncryptDistSQLStatemen
         return new EncryptColumnSegment(getIdentifierValue(ctx.columnDefinition().columnName()),
                 new EncryptColumnItemSegment(getIdentifierValue(ctx.cipherColumnDefinition().cipherColumnName()), (AlgorithmSegment) visit(ctx.encryptAlgorithm().algorithmDefinition())),
                 null == ctx.assistedQueryColumnDefinition() ? null
-                        : new EncryptColumnItemSegment(getIdentifierValue(ctx.assistedQueryColumnDefinition().assistedQueryColumnName()),
-                                null == ctx.assistedQueryAlgorithm() ? null : (AlgorithmSegment) visit(ctx.assistedQueryAlgorithm().algorithmDefinition())),
-                null == ctx.likeQueryColumnDefinition() ? null
-                        : new EncryptColumnItemSegment(getIdentifierValue(ctx.likeQueryColumnDefinition().likeQueryColumnName()),
-                                null == ctx.likeQueryAlgorithm() ? null : (AlgorithmSegment) visit(ctx.likeQueryAlgorithm().algorithmDefinition())));
+                        : new EncryptColumnItemSegment(getIdentifierValue(ctx.assistedQueryColumnDefinition().assistedQueryColumnName()), getAssistedEncryptor(ctx)),
+                null == ctx.likeQueryColumnDefinition() ? null : new EncryptColumnItemSegment(getIdentifierValue(ctx.likeQueryColumnDefinition().likeQueryColumnName()), getLikeEncryptor(ctx)));
+    }
+    
+    private AlgorithmSegment getAssistedEncryptor(final EncryptColumnDefinitionContext ctx) {
+        return null == ctx.assistedQueryAlgorithm() ? null : (AlgorithmSegment) visit(ctx.assistedQueryAlgorithm().algorithmDefinition());
+    }
+    
+    private AlgorithmSegment getLikeEncryptor(final EncryptColumnDefinitionContext ctx) {
+        return null == ctx.likeQueryAlgorithm() ? null : (AlgorithmSegment) visit(ctx.likeQueryAlgorithm().algorithmDefinition());
     }
     
     @Override
diff --git a/features/mask/core/src/main/java/org/apache/shardingsphere/mask/merge/dql/MaskMergedResult.java b/features/mask/core/src/main/java/org/apache/shardingsphere/mask/merge/dql/MaskMergedResult.java
index 04b4ca8a9cf..8912bd3be34 100644
--- a/features/mask/core/src/main/java/org/apache/shardingsphere/mask/merge/dql/MaskMergedResult.java
+++ b/features/mask/core/src/main/java/org/apache/shardingsphere/mask/merge/dql/MaskMergedResult.java
@@ -22,6 +22,7 @@ import org.apache.shardingsphere.infra.merge.result.MergedResult;
 import org.apache.shardingsphere.mask.spi.MaskAlgorithm;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 import java.util.Optional;
@@ -62,6 +63,11 @@ public final class MaskMergedResult implements MergedResult {
         return mergedResult.getInputStream(columnIndex, type);
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        return mergedResult.getCharacterStream(columnIndex);
+    }
+    
     @Override
     public boolean wasNull() throws SQLException {
         return mergedResult.wasNull();
diff --git a/features/mask/core/src/main/java/org/apache/shardingsphere/mask/metadata/converter/MaskNodeConverter.java b/features/mask/core/src/main/java/org/apache/shardingsphere/mask/metadata/converter/MaskNodeConverter.java
index aee2eaac42f..1f42eec981f 100644
--- a/features/mask/core/src/main/java/org/apache/shardingsphere/mask/metadata/converter/MaskNodeConverter.java
+++ b/features/mask/core/src/main/java/org/apache/shardingsphere/mask/metadata/converter/MaskNodeConverter.java
@@ -20,15 +20,25 @@ package org.apache.shardingsphere.mask.metadata.converter;
 import lombok.AccessLevel;
 import lombok.NoArgsConstructor;
 
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 /**
  * Mask node converter.
  */
 @NoArgsConstructor(access = AccessLevel.PRIVATE)
 public final class MaskNodeConverter {
     
-    private static final String TABLES = "tables";
+    private static final String ROOT_NODE = "mask";
+    
+    private static final String TABLES_NODE = "tables";
+    
+    private static final String ALGORITHMS_NODE = "algorithms";
     
-    private static final String MASK_ALGORITHMS = "mask_algorithms";
+    private static final String RULES_NODE_PREFIX = "/([\\w\\-]+)/([\\w\\-]+)/rules/";
+    
+    private static final String RULE_NAME_PATTERN = "/([\\w\\-]+)?";
     
     /**
      * Get table name path.
@@ -37,7 +47,7 @@ public final class MaskNodeConverter {
      * @return table name path
      */
     public static String getTableNamePath(final String tableName) {
-        return String.join("/", TABLES, tableName);
+        return String.join("/", TABLES_NODE, tableName);
     }
     
     /**
@@ -46,7 +56,67 @@ public final class MaskNodeConverter {
      * @param maskAlgorithmName mask algorithm name
      * @return mask algorithm path
      */
-    public static String getMaskAlgorithmNamePath(final String maskAlgorithmName) {
-        return String.join("/", MASK_ALGORITHMS, maskAlgorithmName);
+    public static String getMaskAlgorithmPath(final String maskAlgorithmName) {
+        return String.join("/", ALGORITHMS_NODE, maskAlgorithmName);
+    }
+    
+    /**
+     * Is mask path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isMaskPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is mask table path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isTablePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + TABLES_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is mask algorithm path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isAlgorithmPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + ALGORITHMS_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Get table name.
+     *
+     * @param rulePath rule path
+     * @return table name
+     */
+    public static Optional<String> getTableName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + TABLES_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     *  Get algorithm name.
+     *
+     * @param rulePath rule path
+     * @return algorithm name
+     */
+    public static Optional<String> getAlgorithmName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + ALGORITHMS_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
     }
 }
diff --git a/features/mask/core/src/main/java/org/apache/shardingsphere/mask/yaml/swapper/NewYamlMaskRuleConfigurationSwapper.java b/features/mask/core/src/main/java/org/apache/shardingsphere/mask/yaml/swapper/NewYamlMaskRuleConfigurationSwapper.java
index 272048b5310..ca2dd407de0 100644
--- a/features/mask/core/src/main/java/org/apache/shardingsphere/mask/yaml/swapper/NewYamlMaskRuleConfigurationSwapper.java
+++ b/features/mask/core/src/main/java/org/apache/shardingsphere/mask/yaml/swapper/NewYamlMaskRuleConfigurationSwapper.java
@@ -20,17 +20,21 @@ package org.apache.shardingsphere.mask.yaml.swapper;
 import org.apache.shardingsphere.infra.config.algorithm.AlgorithmConfiguration;
 import org.apache.shardingsphere.infra.util.yaml.YamlEngine;
 import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
+import org.apache.shardingsphere.infra.yaml.config.pojo.algorithm.YamlAlgorithmConfiguration;
 import org.apache.shardingsphere.infra.yaml.config.swapper.algorithm.YamlAlgorithmConfigurationSwapper;
 import org.apache.shardingsphere.infra.yaml.config.swapper.rule.NewYamlRuleConfigurationSwapper;
 import org.apache.shardingsphere.mask.api.config.MaskRuleConfiguration;
 import org.apache.shardingsphere.mask.api.config.rule.MaskTableRuleConfiguration;
 import org.apache.shardingsphere.mask.constant.MaskOrder;
-import org.apache.shardingsphere.mask.yaml.swapper.rule.YamlMaskTableRuleConfigurationSwapper;
 import org.apache.shardingsphere.mask.metadata.converter.MaskNodeConverter;
+import org.apache.shardingsphere.mask.yaml.config.rule.YamlMaskTableRuleConfiguration;
+import org.apache.shardingsphere.mask.yaml.swapper.rule.YamlMaskTableRuleConfigurationSwapper;
 
 import java.util.Collection;
-import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.Map;
 import java.util.Map.Entry;
 
 /**
@@ -50,15 +54,25 @@ public final class NewYamlMaskRuleConfigurationSwapper implements NewYamlRuleCon
             result.add(new YamlDataNode(MaskNodeConverter.getTableNamePath(each.getName()), YamlEngine.marshal(tableSwapper.swapToYamlConfiguration(each))));
         }
         for (Entry<String, AlgorithmConfiguration> entry : data.getMaskAlgorithms().entrySet()) {
-            result.add(new YamlDataNode(MaskNodeConverter.getMaskAlgorithmNamePath(entry.getKey()), YamlEngine.marshal(algorithmSwapper.swapToYamlConfiguration(entry.getValue()))));
+            result.add(new YamlDataNode(MaskNodeConverter.getMaskAlgorithmPath(entry.getKey()), YamlEngine.marshal(algorithmSwapper.swapToYamlConfiguration(entry.getValue()))));
         }
         return result;
     }
     
     @Override
     public MaskRuleConfiguration swapToObject(final Collection<YamlDataNode> dataNodes) {
-        // TODO to be completed.
-        return new MaskRuleConfiguration(Collections.emptyList(), Collections.emptyMap());
+        Collection<MaskTableRuleConfiguration> tables = new LinkedList<>();
+        Map<String, AlgorithmConfiguration> algorithms = new LinkedHashMap<>();
+        for (YamlDataNode each : dataNodes) {
+            if (MaskNodeConverter.isTablePath(each.getKey())) {
+                MaskNodeConverter.getTableName(each.getKey())
+                        .ifPresent(tableName -> tables.add(tableSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlMaskTableRuleConfiguration.class))));
+            } else if (MaskNodeConverter.isAlgorithmPath(each.getKey())) {
+                MaskNodeConverter.getAlgorithmName(each.getKey())
+                        .ifPresent(loadBalancerName -> algorithms.put(loadBalancerName, algorithmSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlAlgorithmConfiguration.class))));
+            }
+        }
+        return new MaskRuleConfiguration(tables, algorithms);
     }
     
     @Override
diff --git a/features/mask/core/src/test/java/org/apache/shardingsphere/mask/merge/dql/MaskMergedResultTest.java b/features/mask/core/src/test/java/org/apache/shardingsphere/mask/merge/dql/MaskMergedResultTest.java
index 0deac1219d9..0af3e0ed0e7 100644
--- a/features/mask/core/src/test/java/org/apache/shardingsphere/mask/merge/dql/MaskMergedResultTest.java
+++ b/features/mask/core/src/test/java/org/apache/shardingsphere/mask/merge/dql/MaskMergedResultTest.java
@@ -25,6 +25,7 @@ import org.mockito.Mock;
 import org.mockito.junit.jupiter.MockitoExtension;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 import java.util.Date;
@@ -73,6 +74,13 @@ class MaskMergedResultTest {
         assertThat(new MaskMergedResult(metaData, mergedResult).getInputStream(1, "asc"), is(inputStream));
     }
     
+    @Test
+    void assertGetCharacterStream() throws SQLException {
+        Reader reader = mock(Reader.class);
+        when(mergedResult.getCharacterStream(1)).thenReturn(reader);
+        assertThat(new MaskMergedResult(metaData, mergedResult).getCharacterStream(1), is(reader));
+    }
+    
     @Test
     void assertWasNull() throws SQLException {
         assertFalse(new MaskMergedResult(metaData, mergedResult).wasNull());
diff --git a/features/mask/core/src/test/java/org/apache/shardingsphere/mask/metadata/converter/MaskNodeConverterTest.java b/features/mask/core/src/test/java/org/apache/shardingsphere/mask/metadata/converter/MaskNodeConverterTest.java
new file mode 100644
index 00000000000..5ea8603207e
--- /dev/null
+++ b/features/mask/core/src/test/java/org/apache/shardingsphere/mask/metadata/converter/MaskNodeConverterTest.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.mask.metadata.converter;
+
+import org.junit.jupiter.api.Test;
+
+import java.util.Optional;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+class MaskNodeConverterTest {
+    
+    @Test
+    void assertGetTableNamePath() {
+        assertThat(MaskNodeConverter.getTableNamePath("foo_table"), is("tables/foo_table"));
+    }
+    
+    @Test
+    void assertGetAlgorithmPath() {
+        assertThat(MaskNodeConverter.getMaskAlgorithmPath("MD5"), is("algorithms/MD5"));
+    }
+    
+    @Test
+    void assertCheckIsTargetRuleByRulePath() {
+        assertTrue(MaskNodeConverter.isMaskPath("/metadata/foo_db/rules/mask/tables/foo_table"));
+        assertFalse(MaskNodeConverter.isMaskPath("/metadata/foo_db/rules/foo/tables/foo_table"));
+        assertTrue(MaskNodeConverter.isTablePath("/metadata/foo_db/rules/mask/tables/foo_table"));
+        assertFalse(MaskNodeConverter.isTablePath("/metadata/foo_db/rules/mask/algorithms/MD5"));
+        assertTrue(MaskNodeConverter.isAlgorithmPath("/metadata/foo_db/rules/mask/algorithms/MD5"));
+        assertFalse(MaskNodeConverter.isAlgorithmPath("/metadata/foo_db/rules/mask/tables/foo_table"));
+    }
+    
+    @Test
+    void assertGetTableNameByRulePath() {
+        Optional<String> actual = MaskNodeConverter.getTableName("/metadata/foo_db/rules/mask/tables/foo_table");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo_table"));
+    }
+    
+    @Test
+    void assertGetAlgorithmNameByRulePath() {
+        Optional<String> actual = MaskNodeConverter.getAlgorithmName("/metadata/foo_db/rules/mask/algorithms/MD5");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("MD5"));
+    }
+}
diff --git a/features/mask/core/src/test/java/org/apache/shardingsphere/mask/yaml/swapper/NewYamlMaskRuleConfigurationSwapperTest.java b/features/mask/core/src/test/java/org/apache/shardingsphere/mask/yaml/swapper/NewYamlMaskRuleConfigurationSwapperTest.java
index 90b0b9c8f2e..5e8bc20f89f 100644
--- a/features/mask/core/src/test/java/org/apache/shardingsphere/mask/yaml/swapper/NewYamlMaskRuleConfigurationSwapperTest.java
+++ b/features/mask/core/src/test/java/org/apache/shardingsphere/mask/yaml/swapper/NewYamlMaskRuleConfigurationSwapperTest.java
@@ -51,7 +51,7 @@ class NewYamlMaskRuleConfigurationSwapperTest {
         assertThat(result.size(), is(2));
         Iterator<YamlDataNode> iterator = result.iterator();
         assertThat(iterator.next().getKey(), is("tables/foo"));
-        assertThat(iterator.next().getKey(), is("mask_algorithms/FIXTURE"));
+        assertThat(iterator.next().getKey(), is("algorithms/FIXTURE"));
     }
     
     private MaskRuleConfiguration createMaximumMaskRule() {
@@ -59,4 +59,32 @@ class NewYamlMaskRuleConfigurationSwapperTest {
         tables.add(new MaskTableRuleConfiguration("foo", Collections.singleton(new MaskColumnRuleConfiguration("foo_column", "FIXTURE"))));
         return new MaskRuleConfiguration(tables, Collections.singletonMap("FIXTURE", new AlgorithmConfiguration("FIXTURE", new Properties())));
     }
+    
+    @Test
+    void assertSwapToObjectEmpty() {
+        Collection<YamlDataNode> config = new LinkedList<>();
+        MaskRuleConfiguration result = swapper.swapToObject(config);
+        assertThat(result.getTables().size(), is(0));
+        assertThat(result.getMaskAlgorithms().size(), is(0));
+    }
+    
+    @Test
+    void assertSwapToObject() {
+        Collection<YamlDataNode> config = new LinkedList<>();
+        config.add(new YamlDataNode("/metadata/foo_db/rules/mask/tables/foo", "columns:\n"
+                + "  foo_column:\n"
+                + "    logicColumn: foo_column\n"
+                + "    maskAlgorithm: FIXTURE\n"
+                + "name: foo\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/mask/algorithms/FIXTURE", "type: FIXTURE\n"));
+        MaskRuleConfiguration result = swapper.swapToObject(config);
+        assertThat(result.getTables().size(), is(1));
+        assertThat(result.getTables().iterator().next().getName(), is("foo"));
+        assertThat(result.getTables().iterator().next().getColumns().size(), is(1));
+        assertThat(result.getTables().iterator().next().getColumns().iterator().next().getLogicColumn(), is("foo_column"));
+        assertThat(result.getTables().iterator().next().getColumns().iterator().next().getMaskAlgorithm(), is("FIXTURE"));
+        assertThat(result.getMaskAlgorithms().size(), is(1));
+        assertThat(result.getMaskAlgorithms().get("FIXTURE").getType(), is("FIXTURE"));
+        assertThat(result.getMaskAlgorithms().get("FIXTURE").getProps().size(), is(0));
+    }
 }
diff --git a/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/event/ReadwriteSplittingRuleConfigurationEventBuilder.java b/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/event/ReadwriteSplittingRuleConfigurationEventBuilder.java
index 7585731ef55..df689860622 100644
--- a/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/event/ReadwriteSplittingRuleConfigurationEventBuilder.java
+++ b/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/event/ReadwriteSplittingRuleConfigurationEventBuilder.java
@@ -49,9 +49,9 @@ public final class ReadwriteSplittingRuleConfigurationEventBuilder implements Ru
         if (groupName.isPresent() && !Strings.isNullOrEmpty(event.getValue())) {
             return createReadwriteSplittingConfigEvent(databaseName, groupName.get(), event);
         }
-        Optional<String> loadBalanceName = ReadwriteSplittingNodeConverter.getLoadBalanceName(event.getKey());
-        if (loadBalanceName.isPresent() && !Strings.isNullOrEmpty(event.getValue())) {
-            return createLoadBalanceEvent(databaseName, loadBalanceName.get(), event);
+        Optional<String> loadBalancerName = ReadwriteSplittingNodeConverter.getLoadBalancerName(event.getKey());
+        if (loadBalancerName.isPresent() && !Strings.isNullOrEmpty(event.getValue())) {
+            return createLoadBalanceEvent(databaseName, loadBalancerName.get(), event);
         }
         return Optional.empty();
     }
diff --git a/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverter.java b/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverter.java
index 874f44c70cc..01676f84688 100644
--- a/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverter.java
+++ b/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverter.java
@@ -38,6 +38,8 @@ public final class ReadwriteSplittingNodeConverter {
     
     private static final String RULES_NODE_PREFIX = "/([\\w\\-]+)/([\\w\\-]+)/rules/";
     
+    private static final String RULE_NAME_PATTERN = "/([\\w\\-]+)?";
+    
     /**
      * Get group name path.
      *
@@ -70,6 +72,30 @@ public final class ReadwriteSplittingNodeConverter {
         return matcher.find();
     }
     
+    /**
+     * Is readwrite-splitting data sources path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isDataSourcePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DATA_SOURCES_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is readwrite-splitting load balancer path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isLoadBalancerPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + LOAD_BALANCER_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
     /**
      * Get group name.
      *
@@ -77,19 +103,19 @@ public final class ReadwriteSplittingNodeConverter {
      * @return group name
      */
     public static Optional<String> getGroupName(final String rulePath) {
-        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DATA_SOURCES_NODE + "/([\\w\\-]+)?", Pattern.CASE_INSENSITIVE);
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DATA_SOURCES_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
         Matcher matcher = pattern.matcher(rulePath);
         return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
     }
     
     /**
-     *  Get group name.
+     * Get load balancer name.
      *
      * @param rulePath rule path
-     * @return group name
+     * @return load balancer name
      */
-    public static Optional<String> getLoadBalanceName(final String rulePath) {
-        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + LOAD_BALANCER_NODE + "/([\\w\\-]+)?", Pattern.CASE_INSENSITIVE);
+    public static Optional<String> getLoadBalancerName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + LOAD_BALANCER_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
         Matcher matcher = pattern.matcher(rulePath);
         return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
     }
diff --git a/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapper.java b/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapper.java
index e46f319e026..7947ac50e8f 100644
--- a/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapper.java
+++ b/features/readwrite-splitting/core/src/main/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapper.java
@@ -21,6 +21,7 @@ import com.google.common.base.Strings;
 import org.apache.shardingsphere.infra.config.algorithm.AlgorithmConfiguration;
 import org.apache.shardingsphere.infra.util.yaml.YamlEngine;
 import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
+import org.apache.shardingsphere.infra.yaml.config.pojo.algorithm.YamlAlgorithmConfiguration;
 import org.apache.shardingsphere.infra.yaml.config.swapper.algorithm.YamlAlgorithmConfigurationSwapper;
 import org.apache.shardingsphere.infra.yaml.config.swapper.rule.NewYamlRuleConfigurationSwapper;
 import org.apache.shardingsphere.readwritesplitting.api.ReadwriteSplittingRuleConfiguration;
@@ -30,9 +31,11 @@ import org.apache.shardingsphere.readwritesplitting.constant.ReadwriteSplittingO
 import org.apache.shardingsphere.readwritesplitting.metadata.converter.ReadwriteSplittingNodeConverter;
 import org.apache.shardingsphere.readwritesplitting.yaml.config.rule.YamlReadwriteSplittingDataSourceRuleConfiguration;
 
-import java.util.Collections;
 import java.util.Collection;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.Map;
 import java.util.Map.Entry;
 
 /**
@@ -66,11 +69,22 @@ public final class NewYamlReadwriteSplittingRuleConfigurationSwapper implements
     
     @Override
     public ReadwriteSplittingRuleConfiguration swapToObject(final Collection<YamlDataNode> dataNodes) {
-        // TODO
-        return new ReadwriteSplittingRuleConfiguration(Collections.emptyList(), Collections.emptyMap());
+        Collection<ReadwriteSplittingDataSourceRuleConfiguration> dataSources = new LinkedList<>();
+        Map<String, AlgorithmConfiguration> loadBalancerMap = new LinkedHashMap<>();
+        for (YamlDataNode each : dataNodes) {
+            if (ReadwriteSplittingNodeConverter.isDataSourcePath(each.getKey())) {
+                ReadwriteSplittingNodeConverter.getGroupName(each.getKey())
+                        .ifPresent(groupName -> dataSources.add(swapDataSource(groupName, YamlEngine.unmarshal(each.getValue(), YamlReadwriteSplittingDataSourceRuleConfiguration.class))));
+            } else if (ReadwriteSplittingNodeConverter.isLoadBalancerPath(each.getKey())) {
+                ReadwriteSplittingNodeConverter.getLoadBalancerName(each.getKey())
+                        .ifPresent(
+                                loadBalancerName -> loadBalancerMap.put(loadBalancerName, algorithmSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlAlgorithmConfiguration.class))));
+            }
+        }
+        return new ReadwriteSplittingRuleConfiguration(dataSources, loadBalancerMap);
     }
     
-    private ReadwriteSplittingDataSourceRuleConfiguration swapToObject(final String name, final YamlReadwriteSplittingDataSourceRuleConfiguration yamlDataSourceRuleConfig) {
+    private ReadwriteSplittingDataSourceRuleConfiguration swapDataSource(final String name, final YamlReadwriteSplittingDataSourceRuleConfiguration yamlDataSourceRuleConfig) {
         return new ReadwriteSplittingDataSourceRuleConfiguration(name, yamlDataSourceRuleConfig.getWriteDataSourceName(), yamlDataSourceRuleConfig.getReadDataSourceNames(),
                 getTransactionalReadQueryStrategy(yamlDataSourceRuleConfig), yamlDataSourceRuleConfig.getLoadBalancerName());
     }
diff --git a/features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverterTest.java b/features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverterTest.java
index 2f07f6a48f1..6de042f87e7 100644
--- a/features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverterTest.java
+++ b/features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/metadata/converter/ReadwriteSplittingNodeConverterTest.java
@@ -23,6 +23,7 @@ import java.util.Optional;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 class ReadwriteSplittingNodeConverterTest {
@@ -38,8 +39,13 @@ class ReadwriteSplittingNodeConverterTest {
     }
     
     @Test
-    void assertGetRuleTagNameByRulePath() {
-        assertTrue(ReadwriteSplittingNodeConverter.isReadwriteSplittingPath("/metadata/foo_db/rules/readwrite_splitting/group_0"));
+    void assertCheckIsTargetRuleByRulePath() {
+        assertTrue(ReadwriteSplittingNodeConverter.isReadwriteSplittingPath("/metadata/foo_db/rules/readwrite_splitting/data_sources/group_0"));
+        assertFalse(ReadwriteSplittingNodeConverter.isReadwriteSplittingPath("/metadata/foo_db/rules/foo/data_sources/group_0"));
+        assertTrue(ReadwriteSplittingNodeConverter.isDataSourcePath("/metadata/foo_db/rules/readwrite_splitting/data_sources/group_0"));
+        assertFalse(ReadwriteSplittingNodeConverter.isDataSourcePath("/metadata/foo_db/rules/readwrite_splitting/load_balancers/random"));
+        assertTrue(ReadwriteSplittingNodeConverter.isLoadBalancerPath("/metadata/foo_db/rules/readwrite_splitting/load_balancers/random"));
+        assertFalse(ReadwriteSplittingNodeConverter.isLoadBalancerPath("/metadata/foo_db/rules/readwrite_splitting/data_sources/group_0"));
     }
     
     @Test
@@ -50,8 +56,8 @@ class ReadwriteSplittingNodeConverterTest {
     }
     
     @Test
-    void assertGetLoadBalanceNameByRulePath() {
-        Optional<String> actual = ReadwriteSplittingNodeConverter.getLoadBalanceName("/metadata/foo_db/rules/readwrite_splitting/load_balancers/random");
+    void assertGetLoadBalancerNameByRulePath() {
+        Optional<String> actual = ReadwriteSplittingNodeConverter.getLoadBalancerName("/metadata/foo_db/rules/readwrite_splitting/load_balancers/random");
         assertTrue(actual.isPresent());
         assertThat(actual.get(), is("random"));
     }
diff --git a/features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapperTest.java b/features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapperTest.java
index 72aceb7eff5..add7dcdae55 100644
--- a/features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapperTest.java
+++ b/features/readwrite-splitting/core/src/test/java/org/apache/shardingsphere/readwritesplitting/yaml/swapper/NewYamlReadwriteSplittingRuleConfigurationSwapperTest.java
@@ -21,16 +21,18 @@ import org.apache.shardingsphere.infra.config.algorithm.AlgorithmConfiguration;
 import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
 import org.apache.shardingsphere.readwritesplitting.api.ReadwriteSplittingRuleConfiguration;
 import org.apache.shardingsphere.readwritesplitting.api.rule.ReadwriteSplittingDataSourceRuleConfiguration;
+import org.apache.shardingsphere.readwritesplitting.api.transaction.TransactionalReadQueryStrategy;
 import org.junit.jupiter.api.Test;
 
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.Arrays;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.Properties;
 
-import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 class NewYamlReadwriteSplittingRuleConfigurationSwapperTest {
     
@@ -55,4 +57,34 @@ class NewYamlReadwriteSplittingRuleConfigurationSwapperTest {
         assertThat(iterator.next().getKey(), is("data_sources/group_0"));
         assertThat(iterator.next().getKey(), is("load_balancers/random"));
     }
+    
+    @Test
+    void assertSwapToObjectEmpty() {
+        Collection<YamlDataNode> config = new LinkedList<>();
+        ReadwriteSplittingRuleConfiguration result = swapper.swapToObject(config);
+        assertThat(result.getDataSources().size(), is(0));
+        assertThat(result.getLoadBalancers().size(), is(0));
+    }
+    
+    @Test
+    void assertSwapToObject() {
+        Collection<YamlDataNode> config = new LinkedList<>();
+        config.add(new YamlDataNode("/metadata/foo_db/rules/readwrite_splitting/data_sources/group_0", "loadBalancerName: random\n"
+                + "readDataSourceNames:\n"
+                + "- read_ds_0\n"
+                + "- read_ds_1\n"
+                + "transactionalReadQueryStrategy: DYNAMIC\n"
+                + "writeDataSourceName: write_ds\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/readwrite_splitting/load_balancers/random", "type: random\n"));
+        ReadwriteSplittingRuleConfiguration result = swapper.swapToObject(config);
+        assertThat(result.getDataSources().size(), is(1));
+        assertThat(result.getDataSources().iterator().next().getName(), is("group_0"));
+        assertThat(result.getDataSources().iterator().next().getWriteDataSourceName(), is("write_ds"));
+        assertThat(result.getDataSources().iterator().next().getReadDataSourceNames().size(), is(2));
+        assertThat(result.getDataSources().iterator().next().getLoadBalancerName(), is("random"));
+        assertThat(result.getDataSources().iterator().next().getTransactionalReadQueryStrategy(), is(TransactionalReadQueryStrategy.DYNAMIC));
+        assertThat(result.getLoadBalancers().size(), is(1));
+        assertThat(result.getLoadBalancers().get("random").getType(), is("random"));
+        assertThat(result.getLoadBalancers().get("random").getProps().size(), is(0));
+    }
 }
diff --git a/features/shadow/core/src/main/java/org/apache/shardingsphere/shadow/metadata/converter/ShadowNodeConverter.java b/features/shadow/core/src/main/java/org/apache/shardingsphere/shadow/metadata/converter/ShadowNodeConverter.java
index e7f3f8e3f36..6d835268a08 100644
--- a/features/shadow/core/src/main/java/org/apache/shardingsphere/shadow/metadata/converter/ShadowNodeConverter.java
+++ b/features/shadow/core/src/main/java/org/apache/shardingsphere/shadow/metadata/converter/ShadowNodeConverter.java
@@ -20,56 +20,162 @@ package org.apache.shardingsphere.shadow.metadata.converter;
 import lombok.AccessLevel;
 import lombok.NoArgsConstructor;
 
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 /**
  * Shadow node converter.
  */
 @NoArgsConstructor(access = AccessLevel.PRIVATE)
 public final class ShadowNodeConverter {
     
-    private static final String DATA_SOURCES = "data_sources";
+    private static final String ROOT_NODE = "shadow";
+    
+    private static final String DATA_SOURCES_NODE = "data_sources";
+    
+    private static final String TABLES_NODE = "tables";
     
-    private static final String TABLES = "tables";
+    private static final String ALGORITHMS_NODE = "algorithms";
     
-    private static final String SHADOW_ALGORITHMS = "shadow_algorithms";
+    private static final String DEFAULT_ALGORITHM_NAME = "default_algorithm_name";
     
-    private static final String DEFAULT_SHADOW_ALGORITHM_NAME = "default_shadow_algorithm_name";
+    private static final String RULES_NODE_PREFIX = "/([\\w\\-]+)/([\\w\\-]+)/rules/";
+    
+    private static final String RULE_NAME_PATTERN = "/([\\w\\-]+)?";
     
     /**
      * Get data source path.
-     * 
+     *
      * @param dataSourceName data source name
      * @return data source path
      */
     public static String getDataSourcePath(final String dataSourceName) {
-        return String.join("/", DATA_SOURCES, dataSourceName);
+        return String.join("/", DATA_SOURCES_NODE, dataSourceName);
     }
     
     /**
      * Get table name path.
-     * 
+     *
      * @param tableName table name
      * @return table name path
      */
     public static String getTableNamePath(final String tableName) {
-        return String.join("/", TABLES, tableName);
+        return String.join("/", TABLES_NODE, tableName);
     }
     
     /**
      * Get shadow algorithm path.
-     * 
+     *
      * @param shadowAlgorithmName shadow algorithm name
      * @return shadow algorithm path
      */
     public static String getShadowAlgorithmPath(final String shadowAlgorithmName) {
-        return String.join("/", SHADOW_ALGORITHMS, shadowAlgorithmName);
+        return String.join("/", ALGORITHMS_NODE, shadowAlgorithmName);
     }
     
     /**
      * Get default shadow algorithm path.
-     * 
+     *
      * @return default shadow algorithm path
      */
     public static String getDefaultShadowAlgorithmPath() {
-        return String.join("/", DEFAULT_SHADOW_ALGORITHM_NAME);
+        return String.join("/", DEFAULT_ALGORITHM_NAME);
+    }
+    
+    /**
+     * Is shadow path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isShadowPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is shadow data sources path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isDataSourcePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DATA_SOURCES_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is shadow table path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isTablePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + TABLES_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is shadow algorithm path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isAlgorithmPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + ALGORITHMS_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is default algorithm name path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isDefaultAlgorithmNamePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DEFAULT_ALGORITHM_NAME + "$", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Get data source name.
+     *
+     * @param rulePath rule path
+     * @return data source name
+     */
+    public static Optional<String> getDataSourceName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DATA_SOURCES_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     * Get table name.
+     *
+     * @param rulePath rule path
+     * @return table name
+     */
+    public static Optional<String> getTableName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + TABLES_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     * Get algorithm name.
+     *
+     * @param rulePath rule path
+     * @return algorithm name
+     */
+    public static Optional<String> getAlgorithmName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + ALGORITHMS_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
     }
 }
diff --git a/features/shadow/core/src/main/java/org/apache/shardingsphere/shadow/yaml/swapper/NewYamlShadowRuleConfigurationSwapper.java b/features/shadow/core/src/main/java/org/apache/shardingsphere/shadow/yaml/swapper/NewYamlShadowRuleConfigurationSwapper.java
index 633612f2a32..b6556725393 100644
--- a/features/shadow/core/src/main/java/org/apache/shardingsphere/shadow/yaml/swapper/NewYamlShadowRuleConfigurationSwapper.java
+++ b/features/shadow/core/src/main/java/org/apache/shardingsphere/shadow/yaml/swapper/NewYamlShadowRuleConfigurationSwapper.java
@@ -21,6 +21,7 @@ import com.google.common.base.Strings;
 import org.apache.shardingsphere.infra.config.algorithm.AlgorithmConfiguration;
 import org.apache.shardingsphere.infra.util.yaml.YamlEngine;
 import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
+import org.apache.shardingsphere.infra.yaml.config.pojo.algorithm.YamlAlgorithmConfiguration;
 import org.apache.shardingsphere.infra.yaml.config.swapper.algorithm.YamlAlgorithmConfigurationSwapper;
 import org.apache.shardingsphere.infra.yaml.config.swapper.rule.NewYamlRuleConfigurationSwapper;
 import org.apache.shardingsphere.shadow.api.config.ShadowRuleConfiguration;
@@ -29,6 +30,7 @@ import org.apache.shardingsphere.shadow.api.config.table.ShadowTableConfiguratio
 import org.apache.shardingsphere.shadow.constant.ShadowOrder;
 import org.apache.shardingsphere.shadow.metadata.converter.ShadowNodeConverter;
 import org.apache.shardingsphere.shadow.yaml.config.datasource.YamlShadowDataSourceConfiguration;
+import org.apache.shardingsphere.shadow.yaml.config.table.YamlShadowTableConfiguration;
 import org.apache.shardingsphere.shadow.yaml.swapper.table.YamlShadowTableConfigurationSwapper;
 
 import java.util.Collection;
@@ -41,7 +43,7 @@ import java.util.Map.Entry;
  */
 public final class NewYamlShadowRuleConfigurationSwapper implements NewYamlRuleConfigurationSwapper<ShadowRuleConfiguration> {
     
-    private final YamlShadowTableConfigurationSwapper tableConfigurationSwapper = new YamlShadowTableConfigurationSwapper();
+    private final YamlShadowTableConfigurationSwapper tableSwapper = new YamlShadowTableConfigurationSwapper();
     
     private final YamlAlgorithmConfigurationSwapper algorithmSwapper = new YamlAlgorithmConfigurationSwapper();
     
@@ -52,7 +54,7 @@ public final class NewYamlShadowRuleConfigurationSwapper implements NewYamlRuleC
             result.add(new YamlDataNode(ShadowNodeConverter.getDataSourcePath(each.getName()), YamlEngine.marshal(swapToDataSourceYamlConfiguration(each))));
         }
         for (Entry<String, ShadowTableConfiguration> entry : data.getTables().entrySet()) {
-            result.add(new YamlDataNode(ShadowNodeConverter.getTableNamePath(entry.getKey()), YamlEngine.marshal(tableConfigurationSwapper.swapToYamlConfiguration(entry.getValue()))));
+            result.add(new YamlDataNode(ShadowNodeConverter.getTableNamePath(entry.getKey()), YamlEngine.marshal(tableSwapper.swapToYamlConfiguration(entry.getValue()))));
         }
         for (Entry<String, AlgorithmConfiguration> entry : data.getShadowAlgorithms().entrySet()) {
             result.add(new YamlDataNode(ShadowNodeConverter.getShadowAlgorithmPath(entry.getKey()), YamlEngine.marshal(algorithmSwapper.swapToYamlConfiguration(entry.getValue()))));
@@ -72,8 +74,27 @@ public final class NewYamlShadowRuleConfigurationSwapper implements NewYamlRuleC
     
     @Override
     public ShadowRuleConfiguration swapToObject(final Collection<YamlDataNode> dataNodes) {
-        // TODO to be completed
-        return new ShadowRuleConfiguration();
+        ShadowRuleConfiguration result = new ShadowRuleConfiguration();
+        for (YamlDataNode each : dataNodes) {
+            if (ShadowNodeConverter.isDataSourcePath(each.getKey())) {
+                ShadowNodeConverter.getDataSourceName(each.getKey())
+                        .ifPresent(dataSourceName -> result.getDataSources().add(swapDataSource(dataSourceName, YamlEngine.unmarshal(each.getValue(), YamlShadowDataSourceConfiguration.class))));
+            } else if (ShadowNodeConverter.isTablePath(each.getKey())) {
+                ShadowNodeConverter.getTableName(each.getKey())
+                        .ifPresent(tableName -> result.getTables().put(tableName, tableSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlShadowTableConfiguration.class))));
+            } else if (ShadowNodeConverter.isAlgorithmPath(each.getKey())) {
+                ShadowNodeConverter.getAlgorithmName(each.getKey())
+                        .ifPresent(algorithmName -> result.getShadowAlgorithms().put(algorithmName,
+                                algorithmSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlAlgorithmConfiguration.class))));
+            } else if (ShadowNodeConverter.isDefaultAlgorithmNamePath(each.getKey())) {
+                result.setDefaultShadowAlgorithmName(each.getValue());
+            }
+        }
+        return result;
+    }
+    
+    private ShadowDataSourceConfiguration swapDataSource(final String name, final YamlShadowDataSourceConfiguration yamlConfig) {
+        return new ShadowDataSourceConfiguration(name, yamlConfig.getProductionDataSourceName(), yamlConfig.getShadowDataSourceName());
     }
     
     @Override
diff --git a/features/shadow/core/src/test/java/org/apache/shardingsphere/shadow/metadata/converter/ShadowNodeConverterTest.java b/features/shadow/core/src/test/java/org/apache/shardingsphere/shadow/metadata/converter/ShadowNodeConverterTest.java
new file mode 100644
index 00000000000..2f8eadc0751
--- /dev/null
+++ b/features/shadow/core/src/test/java/org/apache/shardingsphere/shadow/metadata/converter/ShadowNodeConverterTest.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.shadow.metadata.converter;
+
+import org.junit.jupiter.api.Test;
+
+import java.util.Optional;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+class ShadowNodeConverterTest {
+    
+    @Test
+    void assertGetDataSourcePath() {
+        assertThat(ShadowNodeConverter.getDataSourcePath("foo_db"), is("data_sources/foo_db"));
+    }
+    
+    @Test
+    void assertGetTableNamePath() {
+        assertThat(ShadowNodeConverter.getTableNamePath("foo_table"), is("tables/foo_table"));
+    }
+    
+    @Test
+    void assertGetAlgorithmPath() {
+        assertThat(ShadowNodeConverter.getShadowAlgorithmPath("SQL_HINT"), is("algorithms/SQL_HINT"));
+    }
+    
+    @Test
+    void assertGetDefaultShadowAlgorithmPath() {
+        assertThat(ShadowNodeConverter.getDefaultShadowAlgorithmPath(), is("default_algorithm_name"));
+    }
+    
+    @Test
+    void assertCheckIsTargetRuleByRulePath() {
+        assertTrue(ShadowNodeConverter.isShadowPath("/metadata/foo_db/rules/shadow/tables/foo_table"));
+        assertFalse(ShadowNodeConverter.isShadowPath("/metadata/foo_db/rules/foo/tables/foo_table"));
+        assertTrue(ShadowNodeConverter.isDataSourcePath("/metadata/foo_db/rules/shadow/data_sources/ds_shadow"));
+        assertFalse(ShadowNodeConverter.isDataSourcePath("/metadata/foo_db/rules/shadow/tables/foo_table"));
+        assertTrue(ShadowNodeConverter.isTablePath("/metadata/foo_db/rules/shadow/tables/foo_table"));
+        assertFalse(ShadowNodeConverter.isTablePath("/metadata/foo_db/rules/shadow/algorithms/MD5"));
+        assertTrue(ShadowNodeConverter.isAlgorithmPath("/metadata/foo_db/rules/shadow/algorithms/MD5"));
+        assertFalse(ShadowNodeConverter.isAlgorithmPath("/metadata/foo_db/rules/shadow/tables/foo_table"));
+        assertTrue(ShadowNodeConverter.isDefaultAlgorithmNamePath("/metadata/foo_db/rules/shadow/default_algorithm_name"));
+        assertFalse(ShadowNodeConverter.isDefaultAlgorithmNamePath("/metadata/foo_db/rules/shadow/default_algorithm_name/s"));
+    }
+    
+    @Test
+    void assertGetDataSourceNameByRulePath() {
+        Optional<String> actual = ShadowNodeConverter.getDataSourceName("/metadata/foo_db/rules/shadow/data_sources/foo_db");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo_db"));
+    }
+    
+    @Test
+    void assertGetTableNameByRulePath() {
+        Optional<String> actual = ShadowNodeConverter.getTableName("/metadata/foo_db/rules/shadow/tables/foo_table");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo_table"));
+    }
+    
+    @Test
+    void assertGetAlgorithmNameByRulePath() {
+        Optional<String> actual = ShadowNodeConverter.getAlgorithmName("/metadata/foo_db/rules/shadow/algorithms/SQL_HINT");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("SQL_HINT"));
+    }
+}
diff --git a/features/shadow/core/src/test/java/org/apache/shardingsphere/shadow/yaml/swapper/NewYamlShadowRuleConfigurationSwapperTest.java b/features/shadow/core/src/test/java/org/apache/shardingsphere/shadow/yaml/swapper/NewYamlShadowRuleConfigurationSwapperTest.java
index c41e9798d48..cb4f3689658 100644
--- a/features/shadow/core/src/test/java/org/apache/shardingsphere/shadow/yaml/swapper/NewYamlShadowRuleConfigurationSwapperTest.java
+++ b/features/shadow/core/src/test/java/org/apache/shardingsphere/shadow/yaml/swapper/NewYamlShadowRuleConfigurationSwapperTest.java
@@ -54,8 +54,8 @@ class NewYamlShadowRuleConfigurationSwapperTest {
         Iterator<YamlDataNode> iterator = result.iterator();
         assertThat(iterator.next().getKey(), is("data_sources/foo"));
         assertThat(iterator.next().getKey(), is("tables/foo_table"));
-        assertThat(iterator.next().getKey(), is("shadow_algorithms/FIXTURE"));
-        assertThat(iterator.next().getKey(), is("default_shadow_algorithm_name"));
+        assertThat(iterator.next().getKey(), is("algorithms/FIXTURE"));
+        assertThat(iterator.next().getKey(), is("default_algorithm_name"));
     }
     
     private ShadowRuleConfiguration createMaximumShadowRule() {
@@ -72,4 +72,39 @@ class NewYamlShadowRuleConfigurationSwapperTest {
         result.setDefaultShadowAlgorithmName("FIXTURE");
         return result;
     }
+    
+    @Test
+    void assertSwapToObjectEmpty() {
+        Collection<YamlDataNode> config = new LinkedList<>();
+        ShadowRuleConfiguration result = swapper.swapToObject(config);
+        assertThat(result.getTables().size(), is(0));
+        assertThat(result.getShadowAlgorithms().size(), is(0));
+    }
+    
+    @Test
+    void assertSwapToObject() {
+        Collection<YamlDataNode> config = new LinkedList<>();
+        config.add(new YamlDataNode("/metadata/foo_db/rules/shadow/data_sources/foo_db", "productionDataSourceName: ds_0\n"
+                + "shadowDataSourceName: ds_1\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/shadow/tables/foo_table", "dataSourceNames:\n"
+                + "- ds_0\n"
+                + "shadowAlgorithmNames:\n"
+                + "- FIXTURE\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/shadow/algorithms/FIXTURE", "type: FIXTURE\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/shadow/default_algorithm_name", "FIXTURE"));
+        ShadowRuleConfiguration result = swapper.swapToObject(config);
+        assertThat(result.getDataSources().size(), is(1));
+        assertThat(result.getDataSources().iterator().next().getName(), is("foo_db"));
+        assertThat(result.getDataSources().iterator().next().getProductionDataSourceName(), is("ds_0"));
+        assertThat(result.getDataSources().iterator().next().getShadowDataSourceName(), is("ds_1"));
+        assertThat(result.getTables().size(), is(1));
+        assertThat(result.getTables().get("foo_table").getDataSourceNames().size(), is(1));
+        assertThat(result.getTables().get("foo_table").getDataSourceNames().iterator().next(), is("ds_0"));
+        assertThat(result.getTables().get("foo_table").getShadowAlgorithmNames().size(), is(1));
+        assertThat(result.getTables().get("foo_table").getShadowAlgorithmNames().iterator().next(), is("FIXTURE"));
+        assertThat(result.getShadowAlgorithms().size(), is(1));
+        assertThat(result.getShadowAlgorithms().get("FIXTURE").getType(), is("FIXTURE"));
+        assertThat(result.getShadowAlgorithms().get("FIXTURE").getProps().size(), is(0));
+        assertThat(result.getDefaultShadowAlgorithmName(), is("FIXTURE"));
+    }
 }
diff --git a/features/sharding/core/pom.xml b/features/sharding/core/pom.xml
index f5937650185..abb0bf8669a 100644
--- a/features/sharding/core/pom.xml
+++ b/features/sharding/core/pom.xml
@@ -74,6 +74,11 @@
             <artifactId>shardingsphere-system-time-service</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.shardingsphere</groupId>
+            <artifactId>shardingsphere-sql-federation-core</artifactId>
+            <version>${project.version}</version>
+        </dependency>
         <dependency>
             <groupId>org.apache.shardingsphere</groupId>
             <artifactId>shardingsphere-sharding-cosid</artifactId>
diff --git a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/decider/ShardingSQLFederationDecider.java b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/decider/ShardingSQLFederationDecider.java
index 61969da516e..0c13840cc1a 100644
--- a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/decider/ShardingSQLFederationDecider.java
+++ b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/decider/ShardingSQLFederationDecider.java
@@ -17,7 +17,6 @@
 
 package org.apache.shardingsphere.sharding.decider;
 
-import org.apache.shardingsphere.infra.binder.decider.SQLFederationDecider;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
 import org.apache.shardingsphere.infra.datanode.DataNode;
@@ -28,6 +27,7 @@ import org.apache.shardingsphere.sharding.route.engine.condition.ShardingConditi
 import org.apache.shardingsphere.sharding.route.engine.condition.ShardingConditions;
 import org.apache.shardingsphere.sharding.route.engine.condition.engine.ShardingConditionEngine;
 import org.apache.shardingsphere.sharding.rule.ShardingRule;
+import org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider;
 
 import java.util.Collection;
 import java.util.HashSet;
diff --git a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/metadata/converter/ShardingNodeConverter.java b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/metadata/converter/ShardingNodeConverter.java
index 9b4cbcd2bb8..91e3eea9bfc 100644
--- a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/metadata/converter/ShardingNodeConverter.java
+++ b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/metadata/converter/ShardingNodeConverter.java
@@ -20,166 +20,422 @@ package org.apache.shardingsphere.sharding.metadata.converter;
 import lombok.AccessLevel;
 import lombok.NoArgsConstructor;
 
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 /**
  * Sharding node converter.
  */
 @NoArgsConstructor(access = AccessLevel.PRIVATE)
 public final class ShardingNodeConverter {
     
-    private static final String TABLES = "tables";
+    private static final String ROOT_NODE = "sharding";
     
-    private static final String AUTO_TABLES = "auto_tables";
+    private static final String TABLES_NODE = "tables";
     
-    private static final String BINDING_TABLES = "binding_tables";
+    private static final String AUTO_TABLES_NODE = "auto_tables";
     
-    private static final String BROADCAST_TABLES = "broadcast_tables";
+    private static final String BINDING_TABLES_NODE = "binding_tables";
     
-    private static final String DEFAULT_STRATEGY = "default_strategy";
+    private static final String BROADCAST_TABLES_NODE = "broadcast_tables";
     
-    private static final String DEFAULT_DATABASE_STRATEGY = "default_database_strategy";
+    private static final String DEFAULT_STRATEGIES_NODE = "default_strategies";
     
-    private static final String DEFAULT_TABLE_STRATEGY = "default_table_strategy";
+    private static final String DEFAULT_DATABASE_STRATEGY_NODE = "default_database_strategy";
     
-    private static final String DEFAULT_KEY_GENERATE_STRATEGY = "default_key_generate_strategy";
+    private static final String DEFAULT_TABLE_STRATEGY_NODE = "default_table_strategy";
     
-    private static final String DEFAULT_AUDIT_STRATEGY = "default_audit_strategy";
+    private static final String DEFAULT_KEY_GENERATE_STRATEGY_NODE = "default_key_generate_strategy";
     
-    private static final String DEFAULT_SHARDING_COLUMN = "default_sharding_column";
+    private static final String DEFAULT_AUDIT_STRATEGY_NODE = "default_audit_strategy";
     
-    private static final String SHARDING_ALGORITHMS = "sharding_algorithms";
+    private static final String DEFAULT_SHARDING_COLUMN_NODE = "default_sharding_column";
     
-    private static final String KEY_GENERATORS = "key_generators";
+    private static final String SHARDING_ALGORITHMS_NODE = "algorithms";
     
-    private static final String AUDITORS = "auditors";
+    private static final String KEY_GENERATORS_NODE = "key_generators";
     
-    private static final String SHARDING_CACHE = "sharding_cache";
+    private static final String AUDITORS_NODE = "auditors";
     
-    private static final String TABLE_NAME = "table_%s";
+    private static final String SHARDING_CACHE_NODE = "sharding_cache";
     
-    private static final String AUTO_TABLE_NAME = "auto_table_%s";
+    private static final String RULES_NODE_PREFIX = "/([\\w\\-]+)/([\\w\\-]+)/rules/";
     
-    private static final String BINDING_TABLE_NAME = "binding_table_%s";
+    private static final String RULE_NAME_PATTERN = "/([\\w\\-]+)?";
     
     /**
      * Get table name path.
-     * 
+     *
      * @param tableName table name
      * @return table name path
      */
     public static String getTableNamePath(final String tableName) {
-        return String.join("/", TABLES, String.format(TABLE_NAME, tableName));
+        return String.join("/", TABLES_NODE, tableName);
     }
     
     /**
      * Get auto table name path.
-     * 
+     *
      * @param tableName table name
      * @return auto table name path
      */
     public static String getAutoTableNamePath(final String tableName) {
-        return String.join("/", AUTO_TABLES, String.format(AUTO_TABLE_NAME, tableName));
+        return String.join("/", AUTO_TABLES_NODE, tableName);
     }
     
     /**
      * Get binding table name path.
-     * 
+     *
      * @param tableName table name
      * @return binding table name path
      */
     public static String getBindingTableNamePath(final String tableName) {
-        return String.join("/", BINDING_TABLES, String.format(BINDING_TABLE_NAME, tableName));
+        return String.join("/", BINDING_TABLES_NODE, tableName);
     }
     
     /**
      * Get broadcast tables path.
-     * 
+     *
      * @return broadcast tables path
      */
     public static String getBroadcastTablesPath() {
-        return String.join("/", BROADCAST_TABLES);
+        return String.join("/", BROADCAST_TABLES_NODE);
     }
     
     /**
      * Get default database strategy path.
-     * 
+     *
      * @return default database strategy path
      */
     public static String getDefaultDatabaseStrategyPath() {
-        return String.join("/", DEFAULT_STRATEGY, DEFAULT_DATABASE_STRATEGY);
+        return String.join("/", DEFAULT_STRATEGIES_NODE, DEFAULT_DATABASE_STRATEGY_NODE);
     }
     
     /**
      * Get default table strategy path.
-     * 
+     *
      * @return default table strategy path
      */
     public static String getDefaultTableStrategyPath() {
-        return String.join("/", DEFAULT_STRATEGY, DEFAULT_TABLE_STRATEGY);
+        return String.join("/", DEFAULT_STRATEGIES_NODE, DEFAULT_TABLE_STRATEGY_NODE);
     }
     
     /**
      * Get default key generate strategy path.
-     * 
+     *
      * @return default key generate path
      */
     public static String getDefaultKeyGenerateStrategyPath() {
-        return String.join("/", DEFAULT_STRATEGY, DEFAULT_KEY_GENERATE_STRATEGY);
+        return String.join("/", DEFAULT_STRATEGIES_NODE, DEFAULT_KEY_GENERATE_STRATEGY_NODE);
     }
     
     /**
      * Get default audit strategy path.
-     * 
+     *
      * @return default audit strategy path
      */
     public static String getDefaultAuditStrategyPath() {
-        return String.join("/", DEFAULT_STRATEGY, DEFAULT_AUDIT_STRATEGY);
+        return String.join("/", DEFAULT_STRATEGIES_NODE, DEFAULT_AUDIT_STRATEGY_NODE);
     }
     
     /**
      * Get default sharding column path.
-     * 
+     *
      * @return default sharding column path
      */
     public static String getDefaultShardingColumnPath() {
-        return String.join("/", DEFAULT_STRATEGY, DEFAULT_SHARDING_COLUMN);
+        return String.join("/", DEFAULT_STRATEGIES_NODE, DEFAULT_SHARDING_COLUMN_NODE);
     }
     
     /**
      * Get sharding algorithm path.
-     * 
+     *
      * @param shardingAlgorithmName sharding algorithm name
      * @return sharding algorithm path
      */
     public static String getShardingAlgorithmPath(final String shardingAlgorithmName) {
-        return String.join("/", SHARDING_ALGORITHMS, shardingAlgorithmName);
+        return String.join("/", SHARDING_ALGORITHMS_NODE, shardingAlgorithmName);
     }
     
     /**
      * Get key generator path.
-     * 
+     *
      * @param keyGeneratorName key generator name
      * @return key generator path
      */
     public static String getKeyGeneratorPath(final String keyGeneratorName) {
-        return String.join("/", KEY_GENERATORS, keyGeneratorName);
+        return String.join("/", KEY_GENERATORS_NODE, keyGeneratorName);
     }
     
     /**
      * Get auditor path.
-     * 
+     *
      * @param auditorName auditor name
      * @return auditor path
      */
     public static String getAuditorPath(final String auditorName) {
-        return String.join("/", AUDITORS, auditorName);
+        return String.join("/", AUDITORS_NODE, auditorName);
     }
     
     /**
      * Get sharding cache path.
-     * 
+     *
      * @return sharding cache path
      */
     public static String getShardingCachePath() {
-        return String.join("/", SHARDING_CACHE);
+        return String.join("/", SHARDING_CACHE_NODE);
+    }
+    
+    /**
+     * Is sharding path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isShardingPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is sharding table path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isTablePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + TABLES_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is sharding auto table path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isAutoTablePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + AUTO_TABLES_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is binding table path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isBindingTablePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + BINDING_TABLES_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is broadcast table path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isBroadcastTablePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + BROADCAST_TABLES_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is default database strategy path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isDefaultDatabaseStrategyPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DEFAULT_STRATEGIES_NODE + "/" + DEFAULT_DATABASE_STRATEGY_NODE + "$", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is default table strategy path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isDefaultTableStrategyPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DEFAULT_STRATEGIES_NODE + "/" + DEFAULT_TABLE_STRATEGY_NODE + "$", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is default key generate strategy path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isDefaultKeyGenerateStrategyPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DEFAULT_STRATEGIES_NODE + "/" + DEFAULT_KEY_GENERATE_STRATEGY_NODE + "$", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is default audit strategy path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isDefaultAuditStrategyPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DEFAULT_STRATEGIES_NODE + "/" + DEFAULT_AUDIT_STRATEGY_NODE + "$", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is default sharding column path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isDefaultShardingColumnPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + DEFAULT_STRATEGIES_NODE + "/" + DEFAULT_SHARDING_COLUMN_NODE + "$", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is sharding algorithm path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isShardingAlgorithmPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + SHARDING_ALGORITHMS_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is key generator path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isKeyGeneratorPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + KEY_GENERATORS_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is sharding auditor path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isAuditorPath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + AUDITORS_NODE + "\\.*", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Is sharding cache path.
+     *
+     * @param rulePath rule path
+     * @return true or false
+     */
+    public static boolean isShardingCachePath(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + SHARDING_CACHE_NODE + "$", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find();
+    }
+    
+    /**
+     * Get sharding table name.
+     *
+     * @param rulePath rule path
+     * @return sharding table name
+     */
+    public static Optional<String> getTableName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + TABLES_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     * Get auto table name.
+     *
+     * @param rulePath rule path
+     * @return auto table name
+     */
+    public static Optional<String> getAutoTableName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + AUTO_TABLES_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     * Get binding table name.
+     *
+     * @param rulePath rule path
+     * @return binding table name
+     */
+    public static Optional<String> getBindingTableName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + BINDING_TABLES_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     * Get broadcast name.
+     *
+     * @param rulePath rule path
+     * @return broadcast name
+     */
+    public static Optional<String> getBroadcastTableName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + BROADCAST_TABLES_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     * Get sharding algorithm name.
+     *
+     * @param rulePath rule path
+     * @return sharding algorithm name
+     */
+    public static Optional<String> getShardingAlgorithmName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + SHARDING_ALGORITHMS_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     * Get key generator name.
+     *
+     * @param rulePath rule path
+     * @return key generator name
+     */
+    public static Optional<String> getKeyGeneratorName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + KEY_GENERATORS_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
+    }
+    
+    /**
+     * Get auditor name.
+     *
+     * @param rulePath rule path
+     * @return auditor name
+     */
+    public static Optional<String> getAuditorName(final String rulePath) {
+        Pattern pattern = Pattern.compile(RULES_NODE_PREFIX + ROOT_NODE + "/" + AUDITORS_NODE + RULE_NAME_PATTERN, Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(3)) : Optional.empty();
     }
 }
diff --git a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/ShardingSQLRouter.java b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/ShardingSQLRouter.java
index 751082ffd14..613521ef2e2 100644
--- a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/ShardingSQLRouter.java
+++ b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/ShardingSQLRouter.java
@@ -63,12 +63,12 @@ public final class ShardingSQLRouter implements SQLRouter<ShardingRule> {
                                              final ConfigurationProperties props, final ConnectionContext connectionContext) {
         SQLStatement sqlStatement = queryContext.getSqlStatementContext().getSqlStatement();
         ShardingConditions shardingConditions = createShardingConditions(queryContext, globalRuleMetaData, database, rule);
-        Optional<ShardingStatementValidator> validator = ShardingStatementValidatorFactory.newInstance(sqlStatement, shardingConditions);
+        Optional<ShardingStatementValidator> validator = ShardingStatementValidatorFactory.newInstance(sqlStatement, shardingConditions, globalRuleMetaData);
         validator.ifPresent(optional -> optional.preValidate(rule, queryContext.getSqlStatementContext(), queryContext.getParameters(), database, props));
         if (sqlStatement instanceof DMLStatement && shardingConditions.isNeedMerge()) {
             shardingConditions.merge();
         }
-        RouteContext result = ShardingRouteEngineFactory.newInstance(rule, database, queryContext, shardingConditions, props, connectionContext).route(rule);
+        RouteContext result = ShardingRouteEngineFactory.newInstance(rule, database, queryContext, shardingConditions, props, connectionContext, globalRuleMetaData).route(rule);
         validator.ifPresent(optional -> optional.postValidate(rule, queryContext.getSqlStatementContext(), queryContext.getHintValueContext(), queryContext.getParameters(), database, props, result));
         return result;
     }
diff --git a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/type/ShardingRouteEngineFactory.java b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/type/ShardingRouteEngineFactory.java
index 27e461455d8..b5ccc745e93 100644
--- a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/type/ShardingRouteEngineFactory.java
+++ b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/type/ShardingRouteEngineFactory.java
@@ -24,9 +24,9 @@ import org.apache.shardingsphere.infra.binder.statement.ddl.CloseStatementContex
 import org.apache.shardingsphere.infra.binder.type.CursorAvailable;
 import org.apache.shardingsphere.infra.binder.type.TableAvailable;
 import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
-import org.apache.shardingsphere.infra.config.props.ConfigurationPropertyKey;
 import org.apache.shardingsphere.infra.hint.HintValueContext;
 import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
 import org.apache.shardingsphere.infra.session.connection.ConnectionContext;
 import org.apache.shardingsphere.infra.session.query.QueryContext;
 import org.apache.shardingsphere.sharding.route.engine.condition.ShardingCondition;
@@ -68,6 +68,7 @@ import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dal.MySQ
 import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dal.MySQLSetResourceGroupStatement;
 import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dal.MySQLShowDatabasesStatement;
 import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dal.MySQLUseStatement;
+import org.apache.shardingsphere.sqlfederation.rule.SQLFederationRule;
 
 import java.util.Collection;
 import java.util.stream.Collectors;
@@ -87,17 +88,22 @@ public final class ShardingRouteEngineFactory {
      * @param shardingConditions shardingConditions
      * @param props ShardingSphere properties
      * @param connectionContext connection context
+     * @param globalRuleMetaData global rule meta data
      * @return created instance
      */
     public static ShardingRouteEngine newInstance(final ShardingRule shardingRule, final ShardingSphereDatabase database, final QueryContext queryContext,
-                                                  final ShardingConditions shardingConditions, final ConfigurationProperties props, final ConnectionContext connectionContext) {
+                                                  final ShardingConditions shardingConditions, final ConfigurationProperties props, final ConnectionContext connectionContext,
+                                                  final ShardingSphereRuleMetaData globalRuleMetaData) {
         SQLStatementContext sqlStatementContext = queryContext.getSqlStatementContext();
         SQLStatement sqlStatement = sqlStatementContext.getSqlStatement();
         if (sqlStatement instanceof TCLStatement) {
             return new ShardingDatabaseBroadcastRoutingEngine();
         }
         if (sqlStatement instanceof DDLStatement) {
-            return getDDLRoutingEngine(shardingRule, database, sqlStatementContext, queryContext.getHintValueContext(), shardingConditions, props, connectionContext);
+            if (sqlStatementContext instanceof CursorAvailable) {
+                return getCursorRouteEngine(shardingRule, database, sqlStatementContext, queryContext.getHintValueContext(), shardingConditions, props, connectionContext);
+            }
+            return getDDLRoutingEngine(shardingRule, database, sqlStatementContext, connectionContext, globalRuleMetaData);
         }
         if (sqlStatement instanceof DALStatement) {
             return getDALRoutingEngine(shardingRule, database, sqlStatementContext, connectionContext);
@@ -109,8 +115,7 @@ public final class ShardingRouteEngineFactory {
     }
     
     private static ShardingRouteEngine getDDLRoutingEngine(final ShardingRule shardingRule, final ShardingSphereDatabase database, final SQLStatementContext sqlStatementContext,
-                                                           final HintValueContext hintValueContext, final ShardingConditions shardingConditions, final ConfigurationProperties props,
-                                                           final ConnectionContext connectionContext) {
+                                                           final ConnectionContext connectionContext, final ShardingSphereRuleMetaData globalRuleMetaData) {
         SQLStatement sqlStatement = sqlStatementContext.getSqlStatement();
         boolean functionStatement = sqlStatement instanceof CreateFunctionStatement || sqlStatement instanceof AlterFunctionStatement || sqlStatement instanceof DropFunctionStatement;
         boolean procedureStatement = sqlStatement instanceof CreateProcedureStatement || sqlStatement instanceof AlterProcedureStatement || sqlStatement instanceof DropProcedureStatement;
@@ -124,17 +129,14 @@ public final class ShardingRouteEngineFactory {
                 ? ((TableAvailable) sqlStatementContext).getAllTables().stream().map(each -> each.getTableName().getIdentifier().getValue()).collect(Collectors.toSet())
                 : sqlStatementContext.getTablesContext().getTableNames();
         Collection<String> shardingRuleTableNames = shardingRule.getShardingRuleTableNames(tableNames);
-        String sqlFederationType = props.getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE);
         // TODO remove this logic when jdbc adapter can support executing create logic view
-        if (!"NONE".equals(sqlFederationType) && (sqlStatement instanceof CreateViewStatement || sqlStatement instanceof AlterViewStatement || sqlStatement instanceof DropViewStatement)) {
+        boolean sqlFederationEnabled = globalRuleMetaData.getSingleRule(SQLFederationRule.class).getConfiguration().isSqlFederationEnabled();
+        if (sqlFederationEnabled && (sqlStatement instanceof CreateViewStatement || sqlStatement instanceof AlterViewStatement || sqlStatement instanceof DropViewStatement)) {
             return new ShardingUnicastRoutingEngine(sqlStatementContext, shardingRuleTableNames, connectionContext);
         }
         if (!tableNames.isEmpty() && shardingRuleTableNames.isEmpty()) {
             return new ShardingIgnoreRoutingEngine();
         }
-        if (sqlStatementContext instanceof CursorAvailable) {
-            return getCursorRouteEngine(shardingRule, database, sqlStatementContext, hintValueContext, shardingConditions, props, connectionContext);
-        }
         return new ShardingTableBroadcastRoutingEngine(database, sqlStatementContext, shardingRuleTableNames);
     }
     
diff --git a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/ShardingStatementValidatorFactory.java b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/ShardingStatementValidatorFactory.java
index b7b0622e89e..dc145f91328 100644
--- a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/ShardingStatementValidatorFactory.java
+++ b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/ShardingStatementValidatorFactory.java
@@ -19,6 +19,7 @@ package org.apache.shardingsphere.sharding.route.engine.validator;
 
 import lombok.AccessLevel;
 import lombok.NoArgsConstructor;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
 import org.apache.shardingsphere.sharding.route.engine.condition.ShardingConditions;
 import org.apache.shardingsphere.sharding.route.engine.validator.ddl.impl.ShardingAlterIndexStatementValidator;
 import org.apache.shardingsphere.sharding.route.engine.validator.ddl.impl.ShardingAlterTableStatementValidator;
@@ -75,11 +76,12 @@ public final class ShardingStatementValidatorFactory {
      * 
      * @param sqlStatement SQL statement
      * @param shardingConditions sharding conditions
+     * @param globalRuleMetaData global rule meta data
      * @return created instance
      */
-    public static Optional<ShardingStatementValidator> newInstance(final SQLStatement sqlStatement, final ShardingConditions shardingConditions) {
+    public static Optional<ShardingStatementValidator> newInstance(final SQLStatement sqlStatement, final ShardingConditions shardingConditions, final ShardingSphereRuleMetaData globalRuleMetaData) {
         if (sqlStatement instanceof DDLStatement) {
-            return getDDLStatementValidator(sqlStatement);
+            return getDDLStatementValidator(sqlStatement, globalRuleMetaData);
         }
         if (sqlStatement instanceof DMLStatement) {
             return getDMLStatementValidator(sqlStatement, shardingConditions);
@@ -87,7 +89,7 @@ public final class ShardingStatementValidatorFactory {
         return Optional.empty();
     }
     
-    private static Optional<ShardingStatementValidator> getDDLStatementValidator(final SQLStatement sqlStatement) {
+    private static Optional<ShardingStatementValidator> getDDLStatementValidator(final SQLStatement sqlStatement, final ShardingSphereRuleMetaData globalRuleMetaData) {
         if (sqlStatement instanceof CreateTableStatement) {
             return Optional.of(new ShardingCreateTableStatementValidator());
         }
@@ -98,7 +100,7 @@ public final class ShardingStatementValidatorFactory {
             return Optional.of(new ShardingCreateProcedureStatementValidator());
         }
         if (sqlStatement instanceof CreateViewStatement) {
-            return Optional.of(new ShardingCreateViewStatementValidator());
+            return Optional.of(new ShardingCreateViewStatementValidator(globalRuleMetaData));
         }
         if (sqlStatement instanceof CreateIndexStatement) {
             return Optional.of(new ShardingCreateIndexStatementValidator());
diff --git a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/ddl/impl/ShardingCreateViewStatementValidator.java b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/ddl/impl/ShardingCreateViewStatementValidator.java
index 67e2a945588..a29dbc5939f 100644
--- a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/ddl/impl/ShardingCreateViewStatementValidator.java
+++ b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/ddl/impl/ShardingCreateViewStatementValidator.java
@@ -17,11 +17,12 @@
 
 package org.apache.shardingsphere.sharding.route.engine.validator.ddl.impl;
 
+import lombok.RequiredArgsConstructor;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
-import org.apache.shardingsphere.infra.config.props.ConfigurationPropertyKey;
 import org.apache.shardingsphere.infra.hint.HintValueContext;
 import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
 import org.apache.shardingsphere.infra.route.context.RouteContext;
 import org.apache.shardingsphere.sharding.exception.metadata.EngagedViewException;
 import org.apache.shardingsphere.sharding.exception.syntax.UnsupportedCreateViewException;
@@ -34,6 +35,7 @@ import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.Sim
 import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateViewStatement;
 import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;
 import org.apache.shardingsphere.sql.parser.sql.dialect.handler.dml.SelectStatementHandler;
+import org.apache.shardingsphere.sqlfederation.rule.SQLFederationRule;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -43,19 +45,22 @@ import java.util.List;
 /**
  * Sharding create view statement validator.
  */
+@RequiredArgsConstructor
 public final class ShardingCreateViewStatementValidator extends ShardingDDLStatementValidator {
     
+    private final ShardingSphereRuleMetaData globalRuleMetaData;
+    
     @Override
     public void preValidate(final ShardingRule shardingRule, final SQLStatementContext sqlStatementContext,
                             final List<Object> params, final ShardingSphereDatabase database, final ConfigurationProperties props) {
         TableExtractor extractor = new TableExtractor();
         extractor.extractTablesFromSelect(((CreateViewStatement) sqlStatementContext.getSqlStatement()).getSelect());
         Collection<SimpleTableSegment> tableSegments = extractor.getRewriteTables();
-        String sqlFederationType = props.getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE);
-        if ("NONE".equals(sqlFederationType) && isShardingTablesWithoutBinding(shardingRule, sqlStatementContext, tableSegments)) {
+        boolean sqlFederationEnabled = globalRuleMetaData.getSingleRule(SQLFederationRule.class).getConfiguration().isSqlFederationEnabled();
+        if (!sqlFederationEnabled && isShardingTablesWithoutBinding(shardingRule, sqlStatementContext, tableSegments)) {
             throw new EngagedViewException("sharding");
         }
-        if ("NONE".equals(sqlFederationType) && isAllBroadcastTablesWithoutConfigView(shardingRule, sqlStatementContext, tableSegments)) {
+        if (!sqlFederationEnabled && isAllBroadcastTablesWithoutConfigView(shardingRule, sqlStatementContext, tableSegments)) {
             throw new EngagedViewException("broadcast");
         }
     }
diff --git a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/yaml/swapper/NewYamlShardingRuleConfigurationSwapper.java b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/yaml/swapper/NewYamlShardingRuleConfigurationSwapper.java
index b173c2e8e23..b24ef7242b5 100644
--- a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/yaml/swapper/NewYamlShardingRuleConfigurationSwapper.java
+++ b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/yaml/swapper/NewYamlShardingRuleConfigurationSwapper.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.sharding.yaml.swapper;
 import org.apache.shardingsphere.infra.config.algorithm.AlgorithmConfiguration;
 import org.apache.shardingsphere.infra.util.yaml.YamlEngine;
 import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
+import org.apache.shardingsphere.infra.yaml.config.pojo.algorithm.YamlAlgorithmConfiguration;
 import org.apache.shardingsphere.infra.yaml.config.swapper.algorithm.YamlAlgorithmConfigurationSwapper;
 import org.apache.shardingsphere.infra.yaml.config.swapper.rule.NewYamlRuleConfigurationSwapper;
 import org.apache.shardingsphere.sharding.api.config.ShardingRuleConfiguration;
@@ -28,6 +29,12 @@ import org.apache.shardingsphere.sharding.api.config.rule.ShardingTableReference
 import org.apache.shardingsphere.sharding.api.config.rule.ShardingTableRuleConfiguration;
 import org.apache.shardingsphere.sharding.constant.ShardingOrder;
 import org.apache.shardingsphere.sharding.metadata.converter.ShardingNodeConverter;
+import org.apache.shardingsphere.sharding.yaml.config.cache.YamlShardingCacheConfiguration;
+import org.apache.shardingsphere.sharding.yaml.config.rule.YamlShardingAutoTableRuleConfiguration;
+import org.apache.shardingsphere.sharding.yaml.config.rule.YamlTableRuleConfiguration;
+import org.apache.shardingsphere.sharding.yaml.config.strategy.audit.YamlShardingAuditStrategyConfiguration;
+import org.apache.shardingsphere.sharding.yaml.config.strategy.keygen.YamlKeyGenerateStrategyConfiguration;
+import org.apache.shardingsphere.sharding.yaml.config.strategy.sharding.YamlShardingStrategyConfiguration;
 import org.apache.shardingsphere.sharding.yaml.swapper.cache.YamlShardingCacheConfigurationSwapper;
 import org.apache.shardingsphere.sharding.yaml.swapper.rule.YamlShardingAutoTableRuleConfigurationSwapper;
 import org.apache.shardingsphere.sharding.yaml.swapper.rule.YamlShardingTableReferenceRuleConfigurationConverter;
@@ -123,7 +130,45 @@ public final class NewYamlShardingRuleConfigurationSwapper implements NewYamlRul
     
     @Override
     public ShardingRuleConfiguration swapToObject(final Collection<YamlDataNode> dataNodes) {
-        return new ShardingRuleConfiguration();
+        ShardingRuleConfiguration result = new ShardingRuleConfiguration();
+        for (YamlDataNode each : dataNodes) {
+            if (ShardingNodeConverter.isTablePath(each.getKey())) {
+                ShardingNodeConverter.getTableName(each.getKey())
+                        .ifPresent(tableName -> result.getTables().add(tableSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlTableRuleConfiguration.class))));
+            } else if (ShardingNodeConverter.isAutoTablePath(each.getKey())) {
+                ShardingNodeConverter.getAutoTableName(each.getKey())
+                        .ifPresent(autoTableName -> result.getAutoTables().add(autoTableYamlSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlShardingAutoTableRuleConfiguration.class))));
+            } else if (ShardingNodeConverter.isBindingTablePath(each.getKey())) {
+                ShardingNodeConverter.getBindingTableName(each.getKey())
+                        .ifPresent(bindingTableName -> result.getBindingTableGroups().add(YamlShardingTableReferenceRuleConfigurationConverter.convertToObject(each.getValue())));
+            } else if (ShardingNodeConverter.isBroadcastTablePath(each.getKey())) {
+                ShardingNodeConverter.getBroadcastTableName(each.getKey()).ifPresent(broadcastName -> result.getBroadcastTables().add(each.getValue()));
+            } else if (ShardingNodeConverter.isDefaultDatabaseStrategyPath(each.getKey())) {
+                result.setDefaultDatabaseShardingStrategy(shardingStrategySwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlShardingStrategyConfiguration.class)));
+            } else if (ShardingNodeConverter.isDefaultTableStrategyPath(each.getKey())) {
+                result.setDefaultTableShardingStrategy(shardingStrategySwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlShardingStrategyConfiguration.class)));
+            } else if (ShardingNodeConverter.isDefaultKeyGenerateStrategyPath(each.getKey())) {
+                result.setDefaultKeyGenerateStrategy(keyGenerateStrategySwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlKeyGenerateStrategyConfiguration.class)));
+            } else if (ShardingNodeConverter.isDefaultAuditStrategyPath(each.getKey())) {
+                result.setDefaultAuditStrategy(auditStrategySwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlShardingAuditStrategyConfiguration.class)));
+            } else if (ShardingNodeConverter.isDefaultShardingColumnPath(each.getKey())) {
+                result.setDefaultShardingColumn(each.getValue());
+            } else if (ShardingNodeConverter.isShardingAlgorithmPath(each.getKey())) {
+                ShardingNodeConverter.getShardingAlgorithmName(each.getKey())
+                        .ifPresent(algorithmName -> result.getShardingAlgorithms().put(algorithmName,
+                                algorithmSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlAlgorithmConfiguration.class))));
+            } else if (ShardingNodeConverter.isKeyGeneratorPath(each.getKey())) {
+                ShardingNodeConverter.getKeyGeneratorName(each.getKey())
+                        .ifPresent(keyGeneratorName -> result.getKeyGenerators().put(keyGeneratorName,
+                                algorithmSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlAlgorithmConfiguration.class))));
+            } else if (ShardingNodeConverter.isAuditorPath(each.getKey())) {
+                ShardingNodeConverter.getAuditorName(each.getKey())
+                        .ifPresent(auditorName -> result.getAuditors().put(auditorName, algorithmSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlAlgorithmConfiguration.class))));
+            } else if (ShardingNodeConverter.isShardingCachePath(each.getKey())) {
+                result.setShardingCache(shardingCacheYamlSwapper.swapToObject(YamlEngine.unmarshal(each.getValue(), YamlShardingCacheConfiguration.class)));
+            }
+        }
+        return result;
     }
     
     @Override
diff --git a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/yaml/swapper/strategy/YamlShardingAuditStrategyConfigurationSwapper.java b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/yaml/swapper/strategy/YamlShardingAuditStrategyConfigurationSwapper.java
index 625a5d53399..3f774010e50 100644
--- a/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/yaml/swapper/strategy/YamlShardingAuditStrategyConfigurationSwapper.java
+++ b/features/sharding/core/src/main/java/org/apache/shardingsphere/sharding/yaml/swapper/strategy/YamlShardingAuditStrategyConfigurationSwapper.java
@@ -21,6 +21,8 @@ import org.apache.shardingsphere.infra.util.yaml.swapper.YamlConfigurationSwappe
 import org.apache.shardingsphere.sharding.api.config.strategy.audit.ShardingAuditStrategyConfiguration;
 import org.apache.shardingsphere.sharding.yaml.config.strategy.audit.YamlShardingAuditStrategyConfiguration;
 
+import java.util.LinkedList;
+
 /**
  * YAML sharding audit strategy configuration swapper.
  */
@@ -29,7 +31,7 @@ public final class YamlShardingAuditStrategyConfigurationSwapper implements Yaml
     @Override
     public YamlShardingAuditStrategyConfiguration swapToYamlConfiguration(final ShardingAuditStrategyConfiguration data) {
         YamlShardingAuditStrategyConfiguration result = new YamlShardingAuditStrategyConfiguration();
-        result.setAuditorNames(data.getAuditorNames());
+        result.setAuditorNames(new LinkedList<>(data.getAuditorNames()));
         result.setAllowHintDisable(data.isAllowHintDisable());
         return result;
     }
diff --git a/features/sharding/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider b/features/sharding/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider
new file mode 100644
index 00000000000..f96bc312aec
--- /dev/null
+++ b/features/sharding/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider
@@ -0,0 +1,18 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+org.apache.shardingsphere.sharding.decider.ShardingSQLFederationDecider
diff --git a/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/metadata/converter/ShardingNodeConverterTest.java b/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/metadata/converter/ShardingNodeConverterTest.java
new file mode 100644
index 00000000000..7761d70a034
--- /dev/null
+++ b/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/metadata/converter/ShardingNodeConverterTest.java
@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sharding.metadata.converter;
+
+import org.junit.jupiter.api.Test;
+
+import java.util.Optional;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+class ShardingNodeConverterTest {
+    
+    @Test
+    void assertGetTableNamePath() {
+        assertThat(ShardingNodeConverter.getTableNamePath("foo_table"), is("tables/foo_table"));
+    }
+    
+    @Test
+    void assertGetAutoTableNamePath() {
+        assertThat(ShardingNodeConverter.getAutoTableNamePath("foo_auto_table"), is("auto_tables/foo_auto_table"));
+    }
+    
+    @Test
+    void assertGetBindingTableNamePath() {
+        assertThat(ShardingNodeConverter.getBindingTableNamePath("foo_binding_table"), is("binding_tables/foo_binding_table"));
+    }
+    
+    @Test
+    void assertGetBroadcastTableNamePath() {
+        assertThat(ShardingNodeConverter.getBroadcastTablesPath(), is("broadcast_tables"));
+    }
+    
+    @Test
+    void assertGetDefaultDatabaseStrategyPath() {
+        assertThat(ShardingNodeConverter.getDefaultDatabaseStrategyPath(), is("default_strategies/default_database_strategy"));
+    }
+    
+    @Test
+    void assertGetDefaultTableStrategyPath() {
+        assertThat(ShardingNodeConverter.getDefaultTableStrategyPath(), is("default_strategies/default_table_strategy"));
+    }
+    
+    @Test
+    void assertGetDefaultKeyGenerateStrategyPath() {
+        assertThat(ShardingNodeConverter.getDefaultKeyGenerateStrategyPath(), is("default_strategies/default_key_generate_strategy"));
+    }
+    
+    @Test
+    void assertGetDefaultAuditStrategyPath() {
+        assertThat(ShardingNodeConverter.getDefaultAuditStrategyPath(), is("default_strategies/default_audit_strategy"));
+    }
+    
+    @Test
+    void assertGetDefaultShardingColumnPath() {
+        assertThat(ShardingNodeConverter.getDefaultShardingColumnPath(), is("default_strategies/default_sharding_column"));
+    }
+    
+    @Test
+    void assertGetShardingAlgorithmPath() {
+        assertThat(ShardingNodeConverter.getShardingAlgorithmPath("MOD"), is("algorithms/MOD"));
+    }
+    
+    @Test
+    void assertGetKeyGeneratorPath() {
+        assertThat(ShardingNodeConverter.getKeyGeneratorPath("DEFAULT"), is("key_generators/DEFAULT"));
+    }
+    
+    @Test
+    void assertGetAuditorPath() {
+        assertThat(ShardingNodeConverter.getAuditorPath("DML_SHARDING_CONDITIONS"), is("auditors/DML_SHARDING_CONDITIONS"));
+    }
+    
+    @Test
+    void assertGetShardingCachePath() {
+        assertThat(ShardingNodeConverter.getShardingCachePath(), is("sharding_cache"));
+    }
+    
+    @Test
+    void assertCheckIsTargetRuleByRulePath() {
+        assertTrue(ShardingNodeConverter.isShardingPath("/metadata/foo_db/rules/sharding/tables/foo_table"));
+        assertFalse(ShardingNodeConverter.isShardingPath("/metadata/foo_db/rules/foo/tables/foo_table"));
+        assertTrue(ShardingNodeConverter.isTablePath("/metadata/foo_db/rules/sharding/tables/foo_table"));
+        assertFalse(ShardingNodeConverter.isTablePath("/metadata/foo_db/rules/sharding/algorithms/MD5"));
+        assertTrue(ShardingNodeConverter.isAutoTablePath("/metadata/foo_db/rules/sharding/auto_tables/foo_table"));
+        assertFalse(ShardingNodeConverter.isAutoTablePath("/metadata/foo_db/rules/sharding/algorithms/MD5"));
+        assertTrue(ShardingNodeConverter.isBindingTablePath("/metadata/foo_db/rules/sharding/binding_tables/foo_table"));
+        assertFalse(ShardingNodeConverter.isBindingTablePath("/metadata/foo_db/rules/sharding/algorithms/MD5"));
+        assertTrue(ShardingNodeConverter.isBroadcastTablePath("/metadata/foo_db/rules/sharding/broadcast_tables/foo_table"));
+        assertFalse(ShardingNodeConverter.isBroadcastTablePath("/metadata/foo_db/rules/sharding/algorithms/MD5"));
+        assertTrue(ShardingNodeConverter.isDefaultDatabaseStrategyPath("/metadata/foo_db/rules/sharding/default_strategies/default_database_strategy"));
+        assertFalse(ShardingNodeConverter.isDefaultDatabaseStrategyPath("/metadata/foo_db/rules/sharding/default_strategies/default_database_strategy/foo"));
+        assertTrue(ShardingNodeConverter.isDefaultTableStrategyPath("/metadata/foo_db/rules/sharding/default_strategies/default_table_strategy"));
+        assertFalse(ShardingNodeConverter.isDefaultTableStrategyPath("/metadata/foo_db/rules/sharding/default_strategies/default_table_strategy/foo"));
+        assertTrue(ShardingNodeConverter.isDefaultKeyGenerateStrategyPath("/metadata/foo_db/rules/sharding/default_strategies/default_key_generate_strategy"));
+        assertFalse(ShardingNodeConverter.isDefaultKeyGenerateStrategyPath("/metadata/foo_db/rules/sharding/default_strategies/default_key_generate_strategy/foo"));
+        assertTrue(ShardingNodeConverter.isDefaultAuditStrategyPath("/metadata/foo_db/rules/sharding/default_strategies/default_audit_strategy"));
+        assertFalse(ShardingNodeConverter.isDefaultAuditStrategyPath("/metadata/foo_db/rules/sharding/default_strategies/default_audit_strategy/foo"));
+        assertTrue(ShardingNodeConverter.isDefaultShardingColumnPath("/metadata/foo_db/rules/sharding/default_strategies/default_sharding_column"));
+        assertFalse(ShardingNodeConverter.isDefaultShardingColumnPath("/metadata/foo_db/rules/sharding/default_strategies/default_sharding_column/foo"));
+        assertTrue(ShardingNodeConverter.isShardingAlgorithmPath("/metadata/foo_db/rules/sharding/algorithms/foo_table"));
+        assertFalse(ShardingNodeConverter.isShardingAlgorithmPath("/metadata/foo_db/rules/sharding/key_generators/foo"));
+        assertTrue(ShardingNodeConverter.isKeyGeneratorPath("/metadata/foo_db/rules/sharding/key_generators/foo"));
+        assertFalse(ShardingNodeConverter.isKeyGeneratorPath("/metadata/foo_db/rules/sharding/algorithms/MD5"));
+        assertTrue(ShardingNodeConverter.isAuditorPath("/metadata/foo_db/rules/sharding/auditors/foo"));
+        assertFalse(ShardingNodeConverter.isAuditorPath("/metadata/foo_db/rules/sharding/algorithms/MD5"));
+        assertTrue(ShardingNodeConverter.isShardingCachePath("/metadata/foo_db/rules/sharding/sharding_cache"));
+        assertFalse(ShardingNodeConverter.isShardingCachePath("/metadata/foo_db/rules/sharding/sharding_cache/foo"));
+    }
+    
+    @Test
+    void assertGetTableNameByRulePath() {
+        Optional<String> actual = ShardingNodeConverter.getTableName("/metadata/foo_db/rules/sharding/tables/foo_table");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo_table"));
+    }
+    
+    @Test
+    void assertGetAutoTableNameByRulePath() {
+        Optional<String> actual = ShardingNodeConverter.getAutoTableName("/metadata/foo_db/rules/sharding/auto_tables/foo_table");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo_table"));
+    }
+    
+    @Test
+    void assertGetBindingTableNameByRulePath() {
+        Optional<String> actual = ShardingNodeConverter.getBindingTableName("/metadata/foo_db/rules/sharding/binding_tables/foo_table");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo_table"));
+    }
+    
+    @Test
+    void assertGetBroadcastTableNameByRulePath() {
+        Optional<String> actual = ShardingNodeConverter.getBroadcastTableName("/metadata/foo_db/rules/sharding/broadcast_tables/foo_table");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo_table"));
+    }
+    
+    @Test
+    void assertGetAlgorithmNameByRulePath() {
+        Optional<String> actual = ShardingNodeConverter.getShardingAlgorithmName("/metadata/foo_db/rules/sharding/algorithms/foo");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo"));
+    }
+    
+    @Test
+    void assertGetKeyGeneratorNameByRulePath() {
+        Optional<String> actual = ShardingNodeConverter.getKeyGeneratorName("/metadata/foo_db/rules/sharding/key_generators/foo");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo"));
+    }
+    
+    @Test
+    void assertGetAuditorNameByRulePath() {
+        Optional<String> actual = ShardingNodeConverter.getAuditorName("/metadata/foo_db/rules/sharding/auditors/foo");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("foo"));
+    }
+}
diff --git a/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/route/engine/type/ShardingRouteEngineFactoryTest.java b/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/route/engine/type/ShardingRouteEngineFactoryTest.java
index aeb6964278a..855d7e88d05 100644
--- a/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/route/engine/type/ShardingRouteEngineFactoryTest.java
+++ b/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/route/engine/type/ShardingRouteEngineFactoryTest.java
@@ -27,6 +27,7 @@ import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
 import org.apache.shardingsphere.infra.database.DefaultDatabase;
 import org.apache.shardingsphere.infra.hint.HintValueContext;
 import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
 import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereSchema;
 import org.apache.shardingsphere.infra.session.connection.ConnectionContext;
 import org.apache.shardingsphere.infra.session.query.QueryContext;
@@ -66,6 +67,7 @@ import org.apache.shardingsphere.sql.parser.sql.dialect.statement.postgresql.dal
 import org.apache.shardingsphere.sql.parser.sql.dialect.statement.postgresql.dcl.PostgreSQLGrantStatement;
 import org.apache.shardingsphere.sql.parser.sql.dialect.statement.sql92.dcl.SQL92GrantStatement;
 import org.apache.shardingsphere.sql.parser.sql.dialect.statement.sqlserver.dcl.SQLServerGrantStatement;
+import org.apache.shardingsphere.sqlfederation.rule.SQLFederationRule;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
@@ -124,7 +126,8 @@ class ShardingRouteEngineFactoryTest {
         TCLStatement tclStatement = mock(TCLStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(tclStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingDatabaseBroadcastRoutingEngine.class));
     }
     
@@ -132,7 +135,11 @@ class ShardingRouteEngineFactoryTest {
     void assertNewInstanceForDDLWithShardingRule() {
         when(sqlStatementContext.getSqlStatement()).thenReturn(mock(DDLStatement.class));
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingSphereRuleMetaData globalRuleMetaData = mock(ShardingSphereRuleMetaData.class);
+        SQLFederationRule sqlFederationRule = mock(SQLFederationRule.class, RETURNS_DEEP_STUBS);
+        when(globalRuleMetaData.getSingleRule(SQLFederationRule.class)).thenReturn(sqlFederationRule);
+        when(sqlFederationRule.getConfiguration().isSqlFederationEnabled()).thenReturn(false);
+        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), globalRuleMetaData);
         assertThat(actual, instanceOf(ShardingTableBroadcastRoutingEngine.class));
     }
     
@@ -143,7 +150,8 @@ class ShardingRouteEngineFactoryTest {
         DALStatement dalStatement = mock(DALStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(dalStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingUnicastRoutingEngine.class));
     }
     
@@ -152,7 +160,8 @@ class ShardingRouteEngineFactoryTest {
         DALStatement dalStatement = mock(DALStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(dalStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingDataSourceGroupBroadcastRoutingEngine.class));
     }
     
@@ -161,7 +170,8 @@ class ShardingRouteEngineFactoryTest {
         DALStatement dalStatement = mock(MySQLShowDatabasesStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(dalStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingDatabaseBroadcastRoutingEngine.class));
     }
     
@@ -178,7 +188,8 @@ class ShardingRouteEngineFactoryTest {
     private void assertNewInstanceForDALSet(final DALStatement dalStatement) {
         when(sqlStatementContext.getSqlStatement()).thenReturn(dalStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingDatabaseBroadcastRoutingEngine.class));
     }
     
@@ -216,7 +227,8 @@ class ShardingRouteEngineFactoryTest {
         grantStatement.getTables().add(new SimpleTableSegment(new TableNameSegment(0, 0, new IdentifierValue("tbl"))));
         GrantStatementContext sqlStatementContext = new GrantStatementContext(grantStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingIgnoreRoutingEngine.class));
     }
     
@@ -224,7 +236,8 @@ class ShardingRouteEngineFactoryTest {
         grantStatement.getTables().add(new SimpleTableSegment(new TableNameSegment(0, 0, new IdentifierValue("tbl"))));
         GrantStatementContext sqlStatementContext = new GrantStatementContext(grantStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingIgnoreRoutingEngine.class));
     }
     
@@ -233,7 +246,8 @@ class ShardingRouteEngineFactoryTest {
         DCLStatement dclStatement = mock(DCLStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(dclStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingInstanceBroadcastRoutingEngine.class));
     }
     
@@ -242,7 +256,8 @@ class ShardingRouteEngineFactoryTest {
         SQLStatement sqlStatement = mock(MySQLSelectStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(sqlStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingUnicastRoutingEngine.class));
     }
     
@@ -252,7 +267,8 @@ class ShardingRouteEngineFactoryTest {
         SQLStatement sqlStatement = mock(InsertStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(sqlStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingDatabaseBroadcastRoutingEngine.class));
     }
     
@@ -262,7 +278,8 @@ class ShardingRouteEngineFactoryTest {
         SQLStatement sqlStatement = mock(MySQLSelectStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(sqlStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingUnicastRoutingEngine.class));
     }
     
@@ -271,7 +288,8 @@ class ShardingRouteEngineFactoryTest {
         SQLStatement sqlStatement = mock(SQLStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(sqlStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingUnicastRoutingEngine.class));
     }
     
@@ -283,7 +301,8 @@ class ShardingRouteEngineFactoryTest {
         when(shardingRule.getShardingLogicTableNames(sqlStatementContext.getTablesContext().getTableNames())).thenReturn(tableNames);
         when(shardingRule.isAllShardingTables(tableNames)).thenReturn(true);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingStandardRoutingEngine.class));
     }
     
@@ -295,7 +314,8 @@ class ShardingRouteEngineFactoryTest {
         tableNames.add("2");
         when(shardingRule.getShardingLogicTableNames(tableNames)).thenReturn(tableNames);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingComplexRoutingEngine.class));
     }
     
@@ -306,7 +326,8 @@ class ShardingRouteEngineFactoryTest {
         tableNames.add("table_1");
         when(shardingRule.getShardingRuleTableNames(tableNames)).thenReturn(tableNames);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingUnicastRoutingEngine.class));
     }
     
@@ -317,7 +338,8 @@ class ShardingRouteEngineFactoryTest {
         tableNames.add("table_1");
         when(shardingRule.getShardingRuleTableNames(tableNames)).thenReturn(tableNames);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingUnicastRoutingEngine.class));
     }
     
@@ -332,7 +354,7 @@ class ShardingRouteEngineFactoryTest {
         when(shardingRule.isAllShardingTables(Collections.singletonList("t_order"))).thenReturn(true);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
         ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, mock(ConfigurationProperties.class),
-                new ConnectionContext());
+                new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingStandardRoutingEngine.class));
     }
     
@@ -341,7 +363,8 @@ class ShardingRouteEngineFactoryTest {
         MySQLCreateResourceGroupStatement resourceGroupStatement = mock(MySQLCreateResourceGroupStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(resourceGroupStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingInstanceBroadcastRoutingEngine.class));
     }
     
@@ -350,7 +373,8 @@ class ShardingRouteEngineFactoryTest {
         MySQLSetResourceGroupStatement resourceGroupStatement = mock(MySQLSetResourceGroupStatement.class);
         when(sqlStatementContext.getSqlStatement()).thenReturn(resourceGroupStatement);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingInstanceBroadcastRoutingEngine.class));
     }
     
@@ -361,7 +385,8 @@ class ShardingRouteEngineFactoryTest {
         tableNames.add("table_1");
         when(shardingRule.getShardingRuleTableNames(tableNames)).thenReturn(tableNames);
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingTableBroadcastRoutingEngine.class));
     }
     
@@ -372,7 +397,8 @@ class ShardingRouteEngineFactoryTest {
         tableNames.add("table_1");
         when(shardingRule.getShardingRuleTableNames(tableNames)).thenReturn(Collections.emptyList());
         QueryContext queryContext = new QueryContext(sqlStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingIgnoreRoutingEngine.class));
     }
     
@@ -388,7 +414,8 @@ class ShardingRouteEngineFactoryTest {
         when(shardingRule.isAllBroadcastTables(tableNames)).thenReturn(true);
         when(shardingRule.getShardingRuleTableNames(tableNames)).thenReturn(tableNames);
         QueryContext queryContext = new QueryContext(cursorStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingUnicastRoutingEngine.class));
     }
     
@@ -405,7 +432,8 @@ class ShardingRouteEngineFactoryTest {
         when(shardingRule.getShardingRuleTableNames(tableNames)).thenReturn(tableNames);
         when(shardingRule.getShardingLogicTableNames(tableNames)).thenReturn(tableNames);
         QueryContext queryContext = new QueryContext(cursorStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingStandardRoutingEngine.class));
     }
     
@@ -417,7 +445,8 @@ class ShardingRouteEngineFactoryTest {
         Collection<SimpleTableSegment> tableSegments = createSimpleTableSegments();
         when(cursorStatementContext.getAllTables()).thenReturn(tableSegments);
         QueryContext queryContext = new QueryContext(cursorStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingIgnoreRoutingEngine.class));
     }
     
@@ -431,7 +460,8 @@ class ShardingRouteEngineFactoryTest {
         when(closeStatementContext.getSqlStatement()).thenReturn(closeStatement);
         when(shardingRule.getShardingRuleTableNames(tableNames)).thenReturn(tableNames);
         QueryContext queryContext = new QueryContext(closeStatementContext, "", Collections.emptyList(), new HintValueContext());
-        ShardingRouteEngine actual = ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext());
+        ShardingRouteEngine actual =
+                ShardingRouteEngineFactory.newInstance(shardingRule, database, queryContext, shardingConditions, props, new ConnectionContext(), mock(ShardingSphereRuleMetaData.class));
         assertThat(actual, instanceOf(ShardingDatabaseBroadcastRoutingEngine.class));
     }
     
diff --git a/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/route/engine/validator/ddl/ShardingCreateViewStatementValidatorTest.java b/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/route/engine/validator/ddl/ShardingCreateViewStatementValidatorTest.java
index 1b0c0becf2e..77b54ab3cc6 100644
--- a/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/route/engine/validator/ddl/ShardingCreateViewStatementValidatorTest.java
+++ b/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/route/engine/validator/ddl/ShardingCreateViewStatementValidatorTest.java
@@ -19,9 +19,9 @@ package org.apache.shardingsphere.sharding.route.engine.validator.ddl;
 
 import org.apache.shardingsphere.infra.binder.statement.ddl.CreateViewStatementContext;
 import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
-import org.apache.shardingsphere.infra.config.props.ConfigurationPropertyKey;
 import org.apache.shardingsphere.infra.hint.HintValueContext;
 import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
 import org.apache.shardingsphere.infra.route.context.RouteContext;
 import org.apache.shardingsphere.sharding.exception.metadata.EngagedViewException;
 import org.apache.shardingsphere.sharding.exception.syntax.UnsupportedCreateViewException;
@@ -33,6 +33,7 @@ import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.Tab
 import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateViewStatement;
 import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;
 import org.apache.shardingsphere.sql.parser.sql.common.value.identifier.IdentifierValue;
+import org.apache.shardingsphere.sqlfederation.rule.SQLFederationRule;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
@@ -47,6 +48,7 @@ import java.util.Collections;
 import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
@@ -80,7 +82,11 @@ class ShardingCreateViewStatementValidatorTest {
     
     @Test
     void assertPreValidateCreateView() {
-        assertDoesNotThrow(() -> new ShardingCreateViewStatementValidator().preValidate(
+        ShardingSphereRuleMetaData globalRuleMetaData = mock(ShardingSphereRuleMetaData.class);
+        SQLFederationRule sqlFederationRule = mock(SQLFederationRule.class, RETURNS_DEEP_STUBS);
+        when(globalRuleMetaData.getSingleRule(SQLFederationRule.class)).thenReturn(sqlFederationRule);
+        when(sqlFederationRule.getConfiguration().isSqlFederationEnabled()).thenReturn(false);
+        assertDoesNotThrow(() -> new ShardingCreateViewStatementValidator(globalRuleMetaData).preValidate(
                 shardingRule, createViewStatementContext, Collections.emptyList(), mock(ShardingSphereDatabase.class), mock(ConfigurationProperties.class)));
     }
     
@@ -89,16 +95,20 @@ class ShardingCreateViewStatementValidatorTest {
         when(shardingRule.isShardingTable(any())).thenReturn(true);
         when(shardingRule.isAllBindingTables(any())).thenReturn(false);
         ConfigurationProperties props = mock(ConfigurationProperties.class);
-        when(props.getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE)).thenReturn("NONE");
+        ShardingSphereRuleMetaData globalRuleMetaData = mock(ShardingSphereRuleMetaData.class);
+        SQLFederationRule sqlFederationRule = mock(SQLFederationRule.class, RETURNS_DEEP_STUBS);
+        when(globalRuleMetaData.getSingleRule(SQLFederationRule.class)).thenReturn(sqlFederationRule);
+        when(sqlFederationRule.getConfiguration().isSqlFederationEnabled()).thenReturn(false);
         assertThrows(EngagedViewException.class,
-                () -> new ShardingCreateViewStatementValidator().preValidate(shardingRule, createViewStatementContext, Collections.emptyList(), mock(ShardingSphereDatabase.class), props));
+                () -> new ShardingCreateViewStatementValidator(globalRuleMetaData).preValidate(shardingRule, createViewStatementContext, Collections.emptyList(), mock(ShardingSphereDatabase.class),
+                        props));
     }
     
     @Test
     void assertPostValidateCreateView() {
         ProjectionsSegment projectionsSegment = mock(ProjectionsSegment.class);
         when(selectStatement.getProjections()).thenReturn(projectionsSegment);
-        assertDoesNotThrow(() -> new ShardingCreateViewStatementValidator().postValidate(
+        assertDoesNotThrow(() -> new ShardingCreateViewStatementValidator(mock(ShardingSphereRuleMetaData.class)).postValidate(
                 shardingRule, createViewStatementContext, new HintValueContext(), Collections.emptyList(), mock(ShardingSphereDatabase.class), mock(ConfigurationProperties.class), routeContext));
     }
     
@@ -108,7 +118,7 @@ class ShardingCreateViewStatementValidatorTest {
         when(projectionsSegment.isDistinctRow()).thenReturn(true);
         when(selectStatement.getProjections()).thenReturn(projectionsSegment);
         assertThrows(UnsupportedCreateViewException.class,
-                () -> new ShardingCreateViewStatementValidator().postValidate(shardingRule,
+                () -> new ShardingCreateViewStatementValidator(mock(ShardingSphereRuleMetaData.class)).postValidate(shardingRule,
                         createViewStatementContext, new HintValueContext(), Collections.emptyList(), mock(ShardingSphereDatabase.class), mock(ConfigurationProperties.class), routeContext));
     }
     
@@ -117,8 +127,12 @@ class ShardingCreateViewStatementValidatorTest {
         when(shardingRule.isAllBroadcastTables(any())).thenReturn(true);
         when(shardingRule.isBroadcastTable("order_view")).thenReturn(false);
         ConfigurationProperties props = mock(ConfigurationProperties.class);
-        when(props.getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE)).thenReturn("NONE");
+        ShardingSphereRuleMetaData globalRuleMetaData = mock(ShardingSphereRuleMetaData.class);
+        SQLFederationRule sqlFederationRule = mock(SQLFederationRule.class, RETURNS_DEEP_STUBS);
+        when(globalRuleMetaData.getSingleRule(SQLFederationRule.class)).thenReturn(sqlFederationRule);
+        when(sqlFederationRule.getConfiguration().isSqlFederationEnabled()).thenReturn(false);
         assertThrows(EngagedViewException.class,
-                () -> new ShardingCreateViewStatementValidator().preValidate(shardingRule, createViewStatementContext, Collections.emptyList(), mock(ShardingSphereDatabase.class), props));
+                () -> new ShardingCreateViewStatementValidator(globalRuleMetaData).preValidate(shardingRule, createViewStatementContext, Collections.emptyList(), mock(ShardingSphereDatabase.class),
+                        props));
     }
 }
diff --git a/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/yaml/swapper/NewYamlShardingRuleConfigurationSwapperTest.java b/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/yaml/swapper/NewYamlShardingRuleConfigurationSwapperTest.java
index 16ae14d69f5..52531978e9f 100644
--- a/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/yaml/swapper/NewYamlShardingRuleConfigurationSwapperTest.java
+++ b/features/sharding/core/src/test/java/org/apache/shardingsphere/sharding/yaml/swapper/NewYamlShardingRuleConfigurationSwapperTest.java
@@ -20,20 +20,26 @@ package org.apache.shardingsphere.sharding.yaml.swapper;
 import org.apache.shardingsphere.infra.config.algorithm.AlgorithmConfiguration;
 import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
 import org.apache.shardingsphere.sharding.api.config.ShardingRuleConfiguration;
+import org.apache.shardingsphere.sharding.api.config.rule.ShardingAutoTableRuleConfiguration;
 import org.apache.shardingsphere.sharding.api.config.rule.ShardingTableReferenceRuleConfiguration;
 import org.apache.shardingsphere.sharding.api.config.rule.ShardingTableRuleConfiguration;
 import org.apache.shardingsphere.sharding.api.config.strategy.audit.ShardingAuditStrategyConfiguration;
 import org.apache.shardingsphere.sharding.api.config.strategy.keygen.KeyGenerateStrategyConfiguration;
 import org.apache.shardingsphere.sharding.api.config.strategy.sharding.StandardShardingStrategyConfiguration;
+import org.apache.shardingsphere.test.util.PropertiesBuilder;
 import org.junit.jupiter.api.Test;
 
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.Properties;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 class NewYamlShardingRuleConfigurationSwapperTest {
     
@@ -47,35 +53,43 @@ class NewYamlShardingRuleConfigurationSwapperTest {
     }
     
     @Test
-    void assertSwapFullConfigToDataNodesEmpty() {
+    void assertSwapFullConfigToDataNodes() {
         ShardingRuleConfiguration config = createMaximumShardingRule();
         Collection<YamlDataNode> result = swapper.swapToDataNodes(config);
-        assertThat(result.size(), is(14));
+        assertThat(result.size(), is(16));
         Iterator<YamlDataNode> iterator = result.iterator();
-        assertThat(iterator.next().getKey(), is("tables/table_LOGIC_TABLE"));
-        assertThat(iterator.next().getKey(), is("tables/table_SUB_LOGIC_TABLE"));
-        assertThat(iterator.next().getKey(), is("binding_tables/binding_table_foo"));
+        assertThat(iterator.next().getKey(), is("tables/LOGIC_TABLE"));
+        assertThat(iterator.next().getKey(), is("tables/SUB_LOGIC_TABLE"));
+        assertThat(iterator.next().getKey(), is("auto_tables/auto_table"));
+        assertThat(iterator.next().getKey(), is("binding_tables/foo"));
         assertThat(iterator.next().getKey(), is("broadcast_tables"));
-        assertThat(iterator.next().getKey(), is("default_strategy/default_database_strategy"));
-        assertThat(iterator.next().getKey(), is("default_strategy/default_table_strategy"));
-        assertThat(iterator.next().getKey(), is("default_strategy/default_key_generate_strategy"));
-        assertThat(iterator.next().getKey(), is("default_strategy/default_audit_strategy"));
-        assertThat(iterator.next().getKey(), is("sharding_algorithms/core_standard_fixture"));
+        assertThat(iterator.next().getKey(), is("default_strategies/default_database_strategy"));
+        assertThat(iterator.next().getKey(), is("default_strategies/default_table_strategy"));
+        assertThat(iterator.next().getKey(), is("default_strategies/default_key_generate_strategy"));
+        assertThat(iterator.next().getKey(), is("default_strategies/default_audit_strategy"));
+        assertThat(iterator.next().getKey(), is("algorithms/core_standard_fixture"));
+        assertThat(iterator.next().getKey(), is("algorithms/hash_mod"));
         assertThat(iterator.next().getKey(), is("key_generators/uuid"));
         assertThat(iterator.next().getKey(), is("key_generators/default"));
         assertThat(iterator.next().getKey(), is("key_generators/auto_increment"));
         assertThat(iterator.next().getKey(), is("auditors/audit_algorithm"));
-        assertThat(iterator.next().getKey(), is("default_strategy/default_sharding_column"));
+        assertThat(iterator.next().getKey(), is("default_strategies/default_sharding_column"));
     }
     
     private ShardingRuleConfiguration createMaximumShardingRule() {
         ShardingRuleConfiguration result = new ShardingRuleConfiguration();
         ShardingTableRuleConfiguration shardingTableRuleConfig = createTableRuleConfiguration("LOGIC_TABLE", "ds_${0..1}.table_${0..2}");
         shardingTableRuleConfig.setKeyGenerateStrategy(new KeyGenerateStrategyConfiguration("id", "uuid"));
+        shardingTableRuleConfig.setAuditStrategy(new ShardingAuditStrategyConfiguration(Collections.singleton("audit_algorithm"), false));
+        result.getTables().add(shardingTableRuleConfig);
         ShardingTableRuleConfiguration subTableRuleConfig = createTableRuleConfiguration("SUB_LOGIC_TABLE", "ds_${0..1}.sub_table_${0..2}");
         subTableRuleConfig.setKeyGenerateStrategy(new KeyGenerateStrategyConfiguration("id", "auto_increment"));
-        result.getTables().add(shardingTableRuleConfig);
         result.getTables().add(subTableRuleConfig);
+        ShardingAutoTableRuleConfiguration autoTableRuleConfiguration = new ShardingAutoTableRuleConfiguration("auto_table", "ds_1,ds_2");
+        autoTableRuleConfiguration.setShardingStrategy(new StandardShardingStrategyConfiguration("user_id", "hash_mod"));
+        autoTableRuleConfiguration.setKeyGenerateStrategy(new KeyGenerateStrategyConfiguration("id", "auto_increment"));
+        autoTableRuleConfiguration.setAuditStrategy(new ShardingAuditStrategyConfiguration(Collections.singleton("audit_algorithm"), true));
+        result.getAutoTables().add(autoTableRuleConfiguration);
         result.getBindingTableGroups().add(new ShardingTableReferenceRuleConfiguration("foo", shardingTableRuleConfig.getLogicTable() + "," + subTableRuleConfig.getLogicTable()));
         result.getBroadcastTables().add("BROADCAST_TABLE");
         result.setDefaultDatabaseShardingStrategy(new StandardShardingStrategyConfiguration("ds_id", "standard"));
@@ -84,6 +98,7 @@ class NewYamlShardingRuleConfigurationSwapperTest {
         result.setDefaultKeyGenerateStrategy(new KeyGenerateStrategyConfiguration("id", "default"));
         result.setDefaultAuditStrategy(new ShardingAuditStrategyConfiguration(Collections.singletonList("audit_algorithm"), false));
         result.getShardingAlgorithms().put("core_standard_fixture", new AlgorithmConfiguration("CORE.STANDARD.FIXTURE", new Properties()));
+        result.getShardingAlgorithms().put("hash_mod", new AlgorithmConfiguration("hash_mod", PropertiesBuilder.build(new PropertiesBuilder.Property("sharding-count", "4"))));
         result.getKeyGenerators().put("uuid", new AlgorithmConfiguration("UUID", new Properties()));
         result.getKeyGenerators().put("default", new AlgorithmConfiguration("UUID", new Properties()));
         result.getKeyGenerators().put("auto_increment", new AlgorithmConfiguration("AUTO_INCREMENT.FIXTURE", new Properties()));
@@ -97,4 +112,152 @@ class NewYamlShardingRuleConfigurationSwapperTest {
         result.setTableShardingStrategy(new StandardShardingStrategyConfiguration("order_id", "table_inline"));
         return result;
     }
+    
+    @Test
+    void assertSwapToObjectEmpty() {
+        Collection<YamlDataNode> config = new LinkedList<>();
+        ShardingRuleConfiguration result = swapper.swapToObject(config);
+        assertThat(result.getTables().size(), is(0));
+        assertThat(result.getAutoTables().size(), is(0));
+        assertThat(result.getBindingTableGroups().size(), is(0));
+        assertThat(result.getBroadcastTables().size(), is(0));
+        assertNull(result.getDefaultDatabaseShardingStrategy());
+        assertNull(result.getDefaultTableShardingStrategy());
+        assertNull(result.getDefaultKeyGenerateStrategy());
+        assertNull(result.getDefaultAuditStrategy());
+        assertNull(result.getDefaultShardingColumn());
+        assertThat(result.getShardingAlgorithms().size(), is(0));
+        assertThat(result.getKeyGenerators().size(), is(0));
+        assertThat(result.getAuditors().size(), is(0));
+        assertNull(result.getShardingCache());
+    }
+    
+    @Test
+    void assertSwapToObject() {
+        Collection<YamlDataNode> config = new LinkedList<>();
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/tables/LOGIC_TABLE", "actualDataNodes: ds_${0..1}.table_${0..2}\n"
+                + "auditStrategy:\n"
+                + "  allowHintDisable: false\n"
+                + "  auditorNames:\n"
+                + "  - audit_algorithm\n"
+                + "databaseStrategy:\n"
+                + "  standard:\n"
+                + "    shardingAlgorithmName: database_inline\n"
+                + "    shardingColumn: user_id\n"
+                + "keyGenerateStrategy:\n"
+                + "  column: id\n"
+                + "  keyGeneratorName: uuid\n"
+                + "logicTable: LOGIC_TABLE\n"
+                + "tableStrategy:\n"
+                + "  standard:\n"
+                + "    shardingAlgorithmName: table_inline\n"
+                + "    shardingColumn: order_id\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/tables/SUB_LOGIC_TABLE", "actualDataNodes: ds_${0..1}.sub_table_${0..2}\n"
+                + "databaseStrategy:\n"
+                + "  standard:\n"
+                + "    shardingAlgorithmName: database_inline\n"
+                + "    shardingColumn: user_id\n"
+                + "keyGenerateStrategy:\n"
+                + "  column: id\n"
+                + "  keyGeneratorName: auto_increment\n"
+                + "logicTable: SUB_LOGIC_TABLE\n"
+                + "tableStrategy:\n"
+                + "  standard:\n"
+                + "    shardingAlgorithmName: table_inline\n"
+                + "    shardingColumn: order_id\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/auto_tables/auto_table", "actualDataSources: ds_1,ds_2\n"
+                + "auditStrategy:\n"
+                + "  allowHintDisable: true\n"
+                + "  auditorNames:\n"
+                + "  - audit_algorithm\n"
+                + "keyGenerateStrategy:\n"
+                + "  column: id\n"
+                + "  keyGeneratorName: auto_increment\n"
+                + "logicTable: auto_table\n"
+                + "shardingStrategy:\n"
+                + "  standard:\n"
+                + "    shardingAlgorithmName: hash_mod\n"
+                + "    shardingColumn: user_id\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/binding_tables/foo", "foo:LOGIC_TABLE,SUB_LOGIC_TABLE"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/broadcast_tables", "- BROADCAST_TABLE\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/default_strategies/default_database_strategy", "standard:\n"
+                + "  shardingAlgorithmName: standard\n"
+                + "  shardingColumn: ds_id\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/default_strategies/default_table_strategy", "standard:\n"
+                + "  shardingAlgorithmName: standard\n"
+                + "  shardingColumn: table_id\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/default_strategies/default_key_generate_strategy", "column: id\n"
+                + "keyGeneratorName: default\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/default_strategies/default_audit_strategy", "allowHintDisable: false\n"
+                + "auditorNames:\n"
+                + "- audit_algorithm\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/algorithms/core_standard_fixture", "type: CORE.STANDARD.FIXTURE\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/algorithms/hash_mod", "props:\n"
+                + "  sharding-count: '4'\n"
+                + "type: hash_mod\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/key_generators/uuid", "type: UUID\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/key_generators/default", "type: UUID\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/key_generators/auto_increment", "type: AUTO_INCREMENT.FIXTURE\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/auditors/audit_algorithm", "type: DML_SHARDING_CONDITIONS\n"));
+        config.add(new YamlDataNode("/metadata/foo_db/rules/sharding/default_strategies/default_sharding_column", "table_id"));
+        ShardingRuleConfiguration result = swapper.swapToObject(config);
+        assertThat(result.getTables().size(), is(2));
+        assertThat(result.getTables().iterator().next().getLogicTable(), is("LOGIC_TABLE"));
+        assertThat(result.getTables().iterator().next().getActualDataNodes(), is("ds_${0..1}.table_${0..2}"));
+        assertTrue(result.getTables().iterator().next().getDatabaseShardingStrategy() instanceof StandardShardingStrategyConfiguration);
+        assertThat(((StandardShardingStrategyConfiguration) result.getTables().iterator().next().getDatabaseShardingStrategy()).getShardingColumn(), is("user_id"));
+        assertThat(result.getTables().iterator().next().getDatabaseShardingStrategy().getShardingAlgorithmName(), is("database_inline"));
+        assertThat(result.getTables().iterator().next().getDatabaseShardingStrategy().getType(), is("STANDARD"));
+        assertTrue(result.getTables().iterator().next().getTableShardingStrategy() instanceof StandardShardingStrategyConfiguration);
+        assertThat(((StandardShardingStrategyConfiguration) result.getTables().iterator().next().getTableShardingStrategy()).getShardingColumn(), is("order_id"));
+        assertThat(result.getTables().iterator().next().getTableShardingStrategy().getShardingAlgorithmName(), is("table_inline"));
+        assertThat(result.getTables().iterator().next().getTableShardingStrategy().getType(), is("STANDARD"));
+        assertThat(result.getTables().iterator().next().getKeyGenerateStrategy().getColumn(), is("id"));
+        assertThat(result.getTables().iterator().next().getKeyGenerateStrategy().getKeyGeneratorName(), is("uuid"));
+        assertThat(result.getTables().iterator().next().getAuditStrategy().getAuditorNames().size(), is(1));
+        assertThat(result.getTables().iterator().next().getAuditStrategy().getAuditorNames().iterator().next(), is("audit_algorithm"));
+        assertFalse(result.getTables().iterator().next().getAuditStrategy().isAllowHintDisable());
+        assertThat(result.getAutoTables().size(), is(1));
+        assertThat(result.getAutoTables().iterator().next().getLogicTable(), is("auto_table"));
+        assertThat(result.getAutoTables().iterator().next().getActualDataSources(), is("ds_1,ds_2"));
+        assertTrue(result.getAutoTables().iterator().next().getShardingStrategy() instanceof StandardShardingStrategyConfiguration);
+        assertThat(((StandardShardingStrategyConfiguration) result.getAutoTables().iterator().next().getShardingStrategy()).getShardingColumn(), is("user_id"));
+        assertThat(result.getAutoTables().iterator().next().getShardingStrategy().getShardingAlgorithmName(), is("hash_mod"));
+        assertThat(result.getAutoTables().iterator().next().getShardingStrategy().getType(), is("STANDARD"));
+        assertThat(result.getAutoTables().iterator().next().getKeyGenerateStrategy().getColumn(), is("id"));
+        assertThat(result.getAutoTables().iterator().next().getKeyGenerateStrategy().getKeyGeneratorName(), is("auto_increment"));
+        assertThat(result.getAutoTables().iterator().next().getAuditStrategy().getAuditorNames().size(), is(1));
+        assertThat(result.getAutoTables().iterator().next().getAuditStrategy().getAuditorNames().iterator().next(), is("audit_algorithm"));
+        assertTrue(result.getAutoTables().iterator().next().getAuditStrategy().isAllowHintDisable());
+        assertThat(result.getBindingTableGroups().size(), is(1));
+        assertThat(result.getBindingTableGroups().iterator().next().getName(), is("foo"));
+        assertThat(result.getBindingTableGroups().iterator().next().getReference(), is("LOGIC_TABLE,SUB_LOGIC_TABLE"));
+        assertTrue(result.getDefaultDatabaseShardingStrategy() instanceof StandardShardingStrategyConfiguration);
+        assertThat(((StandardShardingStrategyConfiguration) result.getDefaultDatabaseShardingStrategy()).getType(), is("STANDARD"));
+        assertThat(((StandardShardingStrategyConfiguration) result.getDefaultDatabaseShardingStrategy()).getShardingColumn(), is("ds_id"));
+        assertThat(result.getDefaultDatabaseShardingStrategy().getShardingAlgorithmName(), is("standard"));
+        assertTrue(result.getDefaultTableShardingStrategy() instanceof StandardShardingStrategyConfiguration);
+        assertThat(((StandardShardingStrategyConfiguration) result.getDefaultTableShardingStrategy()).getType(), is("STANDARD"));
+        assertThat(((StandardShardingStrategyConfiguration) result.getDefaultTableShardingStrategy()).getShardingColumn(), is("table_id"));
+        assertThat(result.getDefaultTableShardingStrategy().getShardingAlgorithmName(), is("standard"));
+        assertThat(result.getDefaultKeyGenerateStrategy().getColumn(), is("id"));
+        assertThat(result.getDefaultKeyGenerateStrategy().getKeyGeneratorName(), is("default"));
+        assertThat(result.getDefaultAuditStrategy().getAuditorNames().size(), is(1));
+        assertThat(result.getDefaultAuditStrategy().getAuditorNames().iterator().next(), is("audit_algorithm"));
+        assertFalse(result.getDefaultAuditStrategy().isAllowHintDisable());
+        assertThat(result.getDefaultShardingColumn(), is("table_id"));
+        assertThat(result.getShardingAlgorithms().size(), is(2));
+        assertThat(result.getShardingAlgorithms().get("core_standard_fixture").getType(), is("CORE.STANDARD.FIXTURE"));
+        assertThat(result.getShardingAlgorithms().get("hash_mod").getType(), is("hash_mod"));
+        assertThat(result.getShardingAlgorithms().get("hash_mod").getProps().size(), is(1));
+        assertThat(result.getShardingAlgorithms().get("hash_mod").getProps().get("sharding-count"), is("4"));
+        assertThat(result.getKeyGenerators().size(), is(3));
+        assertThat(result.getKeyGenerators().get("uuid").getType(), is("UUID"));
+        assertThat(result.getKeyGenerators().get("uuid").getProps().size(), is(0));
+        assertThat(result.getKeyGenerators().get("auto_increment").getType(), is("AUTO_INCREMENT.FIXTURE"));
+        assertThat(result.getAuditors().size(), is(1));
+        assertThat(result.getAuditors().get("audit_algorithm").getType(), is("DML_SHARDING_CONDITIONS"));
+        assertThat(result.getAuditors().get("audit_algorithm").getProps().size(), is(0));
+        assertNull(result.getShardingCache());
+    }
 }
diff --git a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/projection/engine/ProjectionEngine.java b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/projection/engine/ProjectionEngine.java
index 2f1eb8fe1d1..db43f0d67d2 100644
--- a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/projection/engine/ProjectionEngine.java
+++ b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/projection/engine/ProjectionEngine.java
@@ -105,7 +105,7 @@ public final class ProjectionEngine {
             return Optional.of(createProjection((AggregationProjectionSegment) projectionSegment));
         }
         if (projectionSegment instanceof SubqueryProjectionSegment) {
-            return Optional.of(createProjection((SubqueryProjectionSegment) projectionSegment));
+            return Optional.of(createProjection(table, (SubqueryProjectionSegment) projectionSegment));
         }
         if (projectionSegment instanceof ParameterMarkerExpressionSegment) {
             return Optional.of(createProjection((ParameterMarkerExpressionSegment) projectionSegment));
@@ -117,8 +117,10 @@ public final class ProjectionEngine {
         return new ParameterMarkerProjection(projectionSegment.getParameterMarkerIndex(), projectionSegment.getParameterMarkerType(), projectionSegment.getAliasName().orElse(null));
     }
     
-    private SubqueryProjection createProjection(final SubqueryProjectionSegment projectionSegment) {
-        return new SubqueryProjection(projectionSegment.getText(), projectionSegment.getAliasName().orElse(null));
+    private SubqueryProjection createProjection(final TableSegment table, final SubqueryProjectionSegment projectionSegment) {
+        Projection subqueryProjection = createProjection(table, projectionSegment.getSubquery().getSelect().getProjections().getProjections().iterator().next())
+                .orElseThrow(() -> new IllegalArgumentException("Subquery projection must have at least one projection column."));
+        return new SubqueryProjection(projectionSegment.getText(), subqueryProjection, projectionSegment.getAliasName().orElse(null), databaseType);
     }
     
     private ShorthandProjection createProjection(final TableSegment table, final ShorthandProjectionSegment projectionSegment) {
diff --git a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/projection/impl/SubqueryProjection.java b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/projection/impl/SubqueryProjection.java
index 2c88e929214..b456eb08b61 100644
--- a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/projection/impl/SubqueryProjection.java
+++ b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/projection/impl/SubqueryProjection.java
@@ -17,11 +17,14 @@
 
 package org.apache.shardingsphere.infra.binder.segment.select.projection.impl;
 
+import com.google.common.base.Strings;
 import lombok.EqualsAndHashCode;
 import lombok.Getter;
 import lombok.RequiredArgsConstructor;
 import lombok.ToString;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
+import org.apache.shardingsphere.infra.database.type.DatabaseType;
+import org.apache.shardingsphere.infra.database.type.dialect.OracleDatabaseType;
 import org.apache.shardingsphere.sql.parser.sql.common.value.identifier.IdentifierValue;
 
 import java.util.Optional;
@@ -37,11 +40,22 @@ public final class SubqueryProjection implements Projection {
     
     private final String expression;
     
+    private final Projection projection;
+    
     private final String alias;
     
+    private final DatabaseType databaseType;
+    
     @Override
     public Optional<String> getAlias() {
-        return Optional.ofNullable(alias);
+        return Strings.isNullOrEmpty(alias) ? buildDefaultAlias(databaseType) : Optional.of(alias);
+    }
+    
+    private Optional<String> buildDefaultAlias(final DatabaseType databaseType) {
+        if (databaseType instanceof OracleDatabaseType) {
+            return Optional.of(expression.replace(" ", "").toUpperCase());
+        }
+        return Optional.of(expression);
     }
     
     @Override
@@ -51,6 +65,6 @@ public final class SubqueryProjection implements Projection {
     
     @Override
     public Projection cloneWithOwner(final IdentifierValue ownerIdentifier) {
-        return new SubqueryProjection(expression, alias);
+        return new SubqueryProjection(expression, projection, alias, databaseType);
     }
 }
diff --git a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/subquery/SubqueryTableContext.java b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/subquery/SubqueryTableContext.java
index 81793496d01..3ff6e40b582 100644
--- a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/subquery/SubqueryTableContext.java
+++ b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/subquery/SubqueryTableContext.java
@@ -21,6 +21,7 @@ import lombok.Getter;
 import lombok.RequiredArgsConstructor;
 
 import java.util.Collection;
+import java.util.LinkedList;
 
 /**
  * Subquery table context.
@@ -31,7 +32,7 @@ public final class SubqueryTableContext {
     
     private final String tableName;
     
-    private final String alias;
+    private final String aliasName;
     
-    private final Collection<String> columnNames;
+    private final Collection<String> columnNames = new LinkedList<>();
 }
diff --git a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/subquery/engine/SubqueryTableContextEngine.java b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/subquery/engine/SubqueryTableContextEngine.java
index 1651d4f8378..3899af3f9aa 100644
--- a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/subquery/engine/SubqueryTableContextEngine.java
+++ b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/select/subquery/engine/SubqueryTableContextEngine.java
@@ -17,14 +17,18 @@
 
 package org.apache.shardingsphere.infra.binder.segment.select.subquery.engine;
 
+import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
 import org.apache.shardingsphere.infra.binder.segment.select.subquery.SubqueryTableContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.JoinTableSegment;
+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;
+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.TableSegment;
 
 import java.util.Collection;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.stream.Collectors;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Optional;
 
 /**
  * Subquery table context engine.
@@ -35,16 +39,36 @@ public final class SubqueryTableContextEngine {
      * Create subquery table contexts.
      *
      * @param subqueryContext subquery context
-     * @param alias subquery alias
-     * @return subquery table context collection
+     * @param aliasName subquery alias name
+     * @return subquery table context map
      */
-    public Collection<SubqueryTableContext> createSubqueryTableContexts(final SelectStatementContext subqueryContext, final String alias) {
-        Collection<SubqueryTableContext> result = new LinkedList<>();
-        List<String> columnNames = subqueryContext.getProjectionsContext().getExpandProjections().stream()
-                .filter(ColumnProjection.class::isInstance).map(each -> ((ColumnProjection) each).getName()).collect(Collectors.toList());
-        for (String each : subqueryContext.getTablesContext().getTableNames()) {
-            result.add(new SubqueryTableContext(each, alias, columnNames));
+    public Map<String, SubqueryTableContext> createSubqueryTableContexts(final SelectStatementContext subqueryContext, final String aliasName) {
+        Map<String, SubqueryTableContext> result = new LinkedHashMap<>();
+        TableSegment tableSegment = subqueryContext.getSqlStatement().getFrom();
+        for (Projection each : subqueryContext.getProjectionsContext().getExpandProjections()) {
+            if (!(each instanceof ColumnProjection)) {
+                continue;
+            }
+            String columnName = ((ColumnProjection) each).getName();
+            if (tableSegment instanceof SimpleTableSegment) {
+                String tableName = ((SimpleTableSegment) tableSegment).getTableName().getIdentifier().getValue();
+                result.computeIfAbsent(tableName.toLowerCase(), unused -> new SubqueryTableContext(tableName, aliasName)).getColumnNames().add(columnName);
+            }
+            if (tableSegment instanceof JoinTableSegment && null != ((ColumnProjection) each).getOwner()) {
+                Optional<String> tableName = getTableNameByOwner(subqueryContext.getTablesContext().getSimpleTableSegments(), ((ColumnProjection) each).getOwner());
+                tableName.ifPresent(optional -> result.computeIfAbsent(optional.toLowerCase(), unused -> new SubqueryTableContext(optional, aliasName)).getColumnNames().add(columnName));
+            }
         }
         return result;
     }
+    
+    private Optional<String> getTableNameByOwner(final Collection<SimpleTableSegment> simpleTableSegments, final String owner) {
+        for (SimpleTableSegment each : simpleTableSegments) {
+            String tableNameOrAlias = each.getAliasName().orElseGet(() -> each.getTableName().getIdentifier().getValue());
+            if (tableNameOrAlias.equalsIgnoreCase(owner)) {
+                return Optional.of(each.getTableName().getIdentifier().getValue());
+            }
+        }
+        return Optional.empty();
+    }
 }
diff --git a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/table/TablesContext.java b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/table/TablesContext.java
index 87631094ca7..aba9c48fa77 100644
--- a/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/table/TablesContext.java
+++ b/infra/binder/src/main/java/org/apache/shardingsphere/infra/binder/segment/table/TablesContext.java
@@ -97,11 +97,11 @@ public final class TablesContext {
     
     private Map<String, Collection<SubqueryTableContext>> createSubqueryTables(final Map<Integer, SelectStatementContext> subqueryContexts, final SubqueryTableSegment subqueryTable) {
         SelectStatementContext subqueryContext = subqueryContexts.get(subqueryTable.getSubquery().getStartIndex());
-        Collection<SubqueryTableContext> subqueryTableContexts = new SubqueryTableContextEngine().createSubqueryTableContexts(subqueryContext, subqueryTable.getAliasName().orElse(null));
+        Map<String, SubqueryTableContext> subqueryTableContexts = new SubqueryTableContextEngine().createSubqueryTableContexts(subqueryContext, subqueryTable.getAliasName().orElse(null));
         Map<String, Collection<SubqueryTableContext>> result = new HashMap<>();
-        for (SubqueryTableContext subQuery : subqueryTableContexts) {
-            if (null != subQuery.getAlias()) {
-                result.computeIfAbsent(subQuery.getAlias(), unused -> new LinkedList<>()).add(subQuery);
+        for (SubqueryTableContext each : subqueryTableContexts.values()) {
+            if (null != each.getAliasName()) {
+                result.computeIfAbsent(each.getAliasName(), unused -> new LinkedList<>()).add(each);
             }
         }
         return result;
diff --git a/infra/binder/src/test/java/org/apache/shardingsphere/infra/binder/statement/dml/SelectStatementContextTest.java b/infra/binder/src/test/java/org/apache/shardingsphere/infra/binder/statement/dml/SelectStatementContextTest.java
index d8a88584dd5..03473aecbdd 100644
--- a/infra/binder/src/test/java/org/apache/shardingsphere/infra/binder/statement/dml/SelectStatementContextTest.java
+++ b/infra/binder/src/test/java/org/apache/shardingsphere/infra/binder/statement/dml/SelectStatementContextTest.java
@@ -60,7 +60,6 @@ import org.junit.jupiter.api.Test;
 
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.Optional;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -423,21 +422,15 @@ class SelectStatementContextTest {
     }
     
     private void assertContainsSubquery(final SelectStatement selectStatement, final SelectStatement subSelectStatement) {
-        SubqueryProjectionSegment projectionSegment = mock(SubqueryProjectionSegment.class);
-        SubquerySegment subquery = mock(SubquerySegment.class);
-        when(projectionSegment.getSubquery()).thenReturn(subquery);
-        SelectStatement select = mock(SelectStatement.class);
-        when(subquery.getSelect()).thenReturn(select);
-        WhereSegment subWhere = mock(WhereSegment.class);
-        when(select.getWhere()).thenReturn(Optional.of(subWhere));
-        when(projectionSegment.getSubquery().getSelect().getWhere()).thenReturn(Optional.of(mock(WhereSegment.class)));
         WhereSegment whereSegment = new WhereSegment(0, 0, null);
         subSelectStatement.setWhere(whereSegment);
-        subSelectStatement.setProjections(new ProjectionsSegment(0, 0));
-        SubquerySegment subquerySegment = new SubquerySegment(0, 0, subSelectStatement);
-        when(projectionSegment.getSubquery()).thenReturn(subquerySegment);
+        ProjectionsSegment subqueryProjections = new ProjectionsSegment(0, 0);
+        subqueryProjections.getProjections().add(new ColumnProjectionSegment(new ColumnSegment(0, 0, new IdentifierValue("order_id"))));
+        subSelectStatement.setProjections(subqueryProjections);
         ProjectionsSegment projectionsSegment = new ProjectionsSegment(0, 0);
-        projectionsSegment.getProjections().add(projectionSegment);
+        SubquerySegment subquerySegment = new SubquerySegment(0, 0, subSelectStatement);
+        SubqueryProjectionSegment subqueryProjectionSegment = new SubqueryProjectionSegment(subquerySegment, "");
+        projectionsSegment.getProjections().add(subqueryProjectionSegment);
         selectStatement.setProjections(projectionsSegment);
         ShardingSphereDatabase database = mock(ShardingSphereDatabase.class);
         assertTrue(new SelectStatementContext(createShardingSphereMetaData(database), Collections.emptyList(), selectStatement, DefaultDatabase.LOGIC_NAME).isContainsSubquery());
@@ -474,7 +467,9 @@ class SelectStatementContextTest {
         BinaryOperationExpression expression = new BinaryOperationExpression(0, 0, left, right, "=", null);
         WhereSegment subWhereSegment = new WhereSegment(0, 0, expression);
         subSelectStatement.setWhere(subWhereSegment);
-        subSelectStatement.setProjections(new ProjectionsSegment(0, 0));
+        ProjectionsSegment subqueryProjections = new ProjectionsSegment(0, 0);
+        subqueryProjections.getProjections().add(new ColumnProjectionSegment(new ColumnSegment(0, 0, new IdentifierValue("order_id"))));
+        subSelectStatement.setProjections(subqueryProjections);
         SubqueryExpressionSegment subqueryExpressionSegment = new SubqueryExpressionSegment(new SubquerySegment(0, 0, subSelectStatement));
         SubqueryProjectionSegment projectionSegment = mock(SubqueryProjectionSegment.class);
         WhereSegment whereSegment = new WhereSegment(0, 0, subqueryExpressionSegment);
diff --git a/infra/common/src/main/java/org/apache/shardingsphere/infra/config/props/ConfigurationPropertyKey.java b/infra/common/src/main/java/org/apache/shardingsphere/infra/config/props/ConfigurationPropertyKey.java
index 191aa035535..e15b76f5c46 100644
--- a/infra/common/src/main/java/org/apache/shardingsphere/infra/config/props/ConfigurationPropertyKey.java
+++ b/infra/common/src/main/java/org/apache/shardingsphere/infra/config/props/ConfigurationPropertyKey.java
@@ -62,11 +62,6 @@ public enum ConfigurationPropertyKey implements TypedPropertyKey {
      */
     CHECK_TABLE_METADATA_ENABLED("check-table-metadata-enabled", String.valueOf(Boolean.FALSE), boolean.class, false),
     
-    /**
-     * SQL federation type.
-     */
-    SQL_FEDERATION_TYPE("sql-federation-type", "NONE", String.class, false),
-    
     /**
      * Frontend database protocol type for ShardingSphere-Proxy.
      */
diff --git a/infra/common/src/main/java/org/apache/shardingsphere/infra/metadata/database/rule/ShardingSphereRuleMetaData.java b/infra/common/src/main/java/org/apache/shardingsphere/infra/metadata/database/rule/ShardingSphereRuleMetaData.java
index db64fbe0976..166ae231440 100644
--- a/infra/common/src/main/java/org/apache/shardingsphere/infra/metadata/database/rule/ShardingSphereRuleMetaData.java
+++ b/infra/common/src/main/java/org/apache/shardingsphere/infra/metadata/database/rule/ShardingSphereRuleMetaData.java
@@ -80,7 +80,7 @@ public final class ShardingSphereRuleMetaData {
     }
     
     /**
-     * Find single rule by class.
+     * Get single rule by class.
      *
      * @param clazz target class
      * @param <T> type of rule
diff --git a/infra/common/src/main/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderRule.java b/infra/common/src/main/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderRule.java
index 5324feb2d99..5be150b9a87 100644
--- a/infra/common/src/main/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderRule.java
+++ b/infra/common/src/main/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderRule.java
@@ -76,7 +76,8 @@ public enum SystemSchemaBuilderRule {
     
     POSTGRESQL_INFORMATION_SCHEMA("PostgreSQL", "information_schema", new HashSet<>(Arrays.asList("columns", "tables", "views"))),
     
-    POSTGRESQL_PG_CATALOG("PostgreSQL", "pg_catalog", new HashSet<>(Arrays.asList("pg_aggregate", "pg_class", "pg_database", "pg_inherits", "pg_tablespace", "pg_trigger", "pg_namespace"))),
+    POSTGRESQL_PG_CATALOG("PostgreSQL", "pg_catalog", new HashSet<>(Arrays.asList("pg_aggregate", "pg_class", "pg_database", "pg_tables", "pg_inherits",
+            "pg_tablespace", "pg_trigger", "pg_namespace", "pg_roles"))),
     
     POSTGRESQL_SHARDING_SPHERE("PostgreSQL", "shardingsphere", new HashSet<>(Arrays.asList("sharding_table_statistics", "cluster_information"))),
     
diff --git a/infra/common/src/main/java/org/apache/shardingsphere/infra/yaml/config/swapper/rule/NewYamlRuleConfigurationSwapperEngine.java b/infra/common/src/main/java/org/apache/shardingsphere/infra/yaml/config/swapper/rule/NewYamlRuleConfigurationSwapperEngine.java
index 188740d7953..43c41b856ea 100644
--- a/infra/common/src/main/java/org/apache/shardingsphere/infra/yaml/config/swapper/rule/NewYamlRuleConfigurationSwapperEngine.java
+++ b/infra/common/src/main/java/org/apache/shardingsphere/infra/yaml/config/swapper/rule/NewYamlRuleConfigurationSwapperEngine.java
@@ -45,17 +45,13 @@ public final class NewYamlRuleConfigurationSwapperEngine {
     /**
      * Swap from YAML rule configurations to rule configurations.
      *
-     * @param ruleName rule name
      * @param dataNodes YAML data nodes
      * @return rule configurations
      */
     @SuppressWarnings({"unchecked", "rawtypes"})
-    public Collection<RuleConfiguration> swapToRuleConfigurations(final String ruleName, final Collection<YamlDataNode> dataNodes) {
+    public Collection<RuleConfiguration> swapToRuleConfigurations(final Collection<YamlDataNode> dataNodes) {
         Collection<RuleConfiguration> result = new LinkedList<>();
         for (NewYamlRuleConfigurationSwapper each : OrderedSPILoader.getServices(NewYamlRuleConfigurationSwapper.class)) {
-            if (!each.getRuleTagName().toLowerCase().equals(ruleName)) {
-                continue;
-            }
             result.add((RuleConfiguration) each.swapToObject(dataNodes));
         }
         return result;
diff --git a/infra/common/src/main/resources/schema/postgresql/pg_catalog/pg_roles.yaml b/infra/common/src/main/resources/schema/postgresql/pg_catalog/pg_roles.yaml
new file mode 100644
index 00000000000..04a60852300
--- /dev/null
+++ b/infra/common/src/main/resources/schema/postgresql/pg_catalog/pg_roles.yaml
@@ -0,0 +1,201 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+name: pg_roles
+columns:
+  oid:
+    caseSensitive: true
+    dataType: -5
+    generated: false
+    name: oid
+    primaryKey: false
+    visible: false
+  rolname:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: rolname
+    primaryKey: false
+    visible: true
+  rolsuper:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolsuper
+    primaryKey: false
+    visible: true
+  rolcreaterole:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolcreaterole
+    primaryKey: false
+    visible: true
+  rolcreatedb:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolcreatedb
+    primaryKey: false
+    visible: true
+  rolcatupdate:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolcatupdate
+    primaryKey: false
+    visible: true
+  rolcanlogin:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolcanlogin
+    primaryKey: false
+    visible: true
+  rolreplication:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolreplication
+    primaryKey: false
+    visible: true
+  rolauditadmin:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolauditadmin
+    primaryKey: false
+    visible: true
+  rolsystemadmin:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolsystemadmin
+    primaryKey: false
+    visible: true
+  rolconnlimit:
+    caseSensitive: true
+    dataType: 4
+    generated: false
+    name: rolconnlimit
+    primaryKey: false
+    visible: true
+  rolpassword:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: rolpassword
+    primaryKey: false
+    visible: true
+  rolvalidbegin:
+    caseSensitive: true
+    dataType: 2014
+    generated: false
+    name: rolpassword
+    primaryKey: false
+    visible: true
+  rolvaliduntil:
+    caseSensitive: true
+    dataType: 2014
+    generated: false
+    name: rolvaliduntil
+    primaryKey: false
+    visible: true
+  rolrespool:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: rolrespool
+    primaryKey: false
+    visible: true
+  rolparentid:
+    caseSensitive: true
+    dataType: -5
+    generated: false
+    name: rolparentid
+    primaryKey: false
+    visible: true
+  roltabspace:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: roltabspace
+    primaryKey: false
+    visible: true
+  rolconfig:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: rolconfig
+    primaryKey: false
+    visible: true
+  roluseft:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: roluseft
+    primaryKey: false
+    visible: true
+  rolkind:
+    caseSensitive: true
+    dataType: 1
+    generated: false
+    name: rolkind
+    primaryKey: false
+    visible: true
+  nodegroup:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: nodegroup
+    primaryKey: false
+    visible: true
+  roltempspace:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: roltempspace
+    primaryKey: false
+    visible: true
+  rolspillspace:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: rolspillspace
+    primaryKey: false
+    visible: true
+  rolmonitoradmin:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolmonitoradmin
+    primaryKey: false
+    visible: true
+  roloperatoradmin:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: roloperatoradmin
+    primaryKey: false
+    visible: true
+  rolpolicyadmin:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: rolpolicyadmin
+    primaryKey: false
+    visible: true
diff --git a/infra/common/src/main/resources/schema/postgresql/pg_catalog/pg_tables.yaml b/infra/common/src/main/resources/schema/postgresql/pg_catalog/pg_tables.yaml
new file mode 100644
index 00000000000..1034cefed5e
--- /dev/null
+++ b/infra/common/src/main/resources/schema/postgresql/pg_catalog/pg_tables.yaml
@@ -0,0 +1,96 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+name: pg_tables
+columns:
+  oid:
+    caseSensitive: true
+    dataType: -5
+    generated: false
+    name: oid
+    primaryKey: false
+    visible: false
+  schemaname:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: schemaname
+    primaryKey: false
+    visible: true
+  tablename:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: tablename
+    primaryKey: false
+    visible: true
+  tableowner:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: tableowner
+    primaryKey: false
+    visible: true
+  tablespace:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: tablespace
+    primaryKey: false
+    visible: true
+  hasindexes:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: hasindexes
+    primaryKey: false
+    visible: true
+  hasrules:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: hasrules
+    primaryKey: false
+    visible: true
+  hastriggers:
+    caseSensitive: true
+    dataType: -7
+    generated: false
+    name: hastriggers
+    primaryKey: false
+    visible: true
+  tablecreator:
+    caseSensitive: true
+    dataType: 12
+    generated: false
+    name: tablecreator
+    primaryKey: false
+    visible: true
+  created:
+    caseSensitive: true
+    dataType: 2014
+    generated: false
+    name: created
+    primaryKey: false
+    visible: true
+  last_ddl_time:
+    caseSensitive: true
+    dataType: 2014
+    generated: false
+    name: last_ddl_time
+    primaryKey: false
+    visible: true
diff --git a/infra/common/src/test/java/org/apache/shardingsphere/infra/config/props/ConfigurationPropertiesTest.java b/infra/common/src/test/java/org/apache/shardingsphere/infra/config/props/ConfigurationPropertiesTest.java
index c1db06c4752..95764cfcf28 100644
--- a/infra/common/src/test/java/org/apache/shardingsphere/infra/config/props/ConfigurationPropertiesTest.java
+++ b/infra/common/src/test/java/org/apache/shardingsphere/infra/config/props/ConfigurationPropertiesTest.java
@@ -39,7 +39,6 @@ class ConfigurationPropertiesTest {
         assertThat(actual.getValue(ConfigurationPropertyKey.KERNEL_EXECUTOR_SIZE), is(20));
         assertThat(actual.getValue(ConfigurationPropertyKey.MAX_CONNECTIONS_SIZE_PER_QUERY), is(20));
         assertTrue((Boolean) actual.getValue(ConfigurationPropertyKey.CHECK_TABLE_METADATA_ENABLED));
-        assertThat(actual.getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE), is("ORIGINAL"));
         assertThat(actual.getValue(ConfigurationPropertyKey.PROXY_FRONTEND_DATABASE_PROTOCOL_TYPE), is("PostgreSQL"));
         assertThat(actual.getValue(ConfigurationPropertyKey.PROXY_FRONTEND_FLUSH_THRESHOLD), is(20));
         assertThat(actual.getValue(ConfigurationPropertyKey.PROXY_BACKEND_QUERY_FETCH_SIZE), is(20));
@@ -58,7 +57,6 @@ class ConfigurationPropertiesTest {
                 new Property(ConfigurationPropertyKey.KERNEL_EXECUTOR_SIZE.getKey(), "20"),
                 new Property(ConfigurationPropertyKey.MAX_CONNECTIONS_SIZE_PER_QUERY.getKey(), "20"),
                 new Property(ConfigurationPropertyKey.CHECK_TABLE_METADATA_ENABLED.getKey(), Boolean.TRUE.toString()),
-                new Property(ConfigurationPropertyKey.SQL_FEDERATION_TYPE.getKey(), "ORIGINAL"),
                 new Property(ConfigurationPropertyKey.PROXY_FRONTEND_DATABASE_PROTOCOL_TYPE.getKey(), "PostgreSQL"),
                 new Property(ConfigurationPropertyKey.PROXY_FRONTEND_FLUSH_THRESHOLD.getKey(), "20"),
                 new Property(ConfigurationPropertyKey.PROXY_BACKEND_QUERY_FETCH_SIZE.getKey(), "20"),
@@ -78,7 +76,6 @@ class ConfigurationPropertiesTest {
         assertThat(actual.getValue(ConfigurationPropertyKey.KERNEL_EXECUTOR_SIZE), is(0));
         assertThat(actual.getValue(ConfigurationPropertyKey.MAX_CONNECTIONS_SIZE_PER_QUERY), is(1));
         assertFalse((Boolean) actual.getValue(ConfigurationPropertyKey.CHECK_TABLE_METADATA_ENABLED));
-        assertThat(actual.getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE), is("NONE"));
         assertThat(actual.getValue(ConfigurationPropertyKey.PROXY_FRONTEND_DATABASE_PROTOCOL_TYPE), is(""));
         assertThat(actual.getValue(ConfigurationPropertyKey.PROXY_FRONTEND_FLUSH_THRESHOLD), is(128));
         assertThat(actual.getValue(ConfigurationPropertyKey.PROXY_BACKEND_QUERY_FETCH_SIZE), is(-1));
diff --git a/infra/common/src/test/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderRuleTest.java b/infra/common/src/test/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderRuleTest.java
index 96707963968..fa1132180ee 100644
--- a/infra/common/src/test/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderRuleTest.java
+++ b/infra/common/src/test/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderRuleTest.java
@@ -42,7 +42,7 @@ class SystemSchemaBuilderRuleTest {
         assertThat(actualPerformanceSchema.getTables().size(), is(87));
         SystemSchemaBuilderRule actualPgCatalog = SystemSchemaBuilderRule.valueOf(new PostgreSQLDatabaseType().getType(), "pg_catalog");
         assertThat(actualPgCatalog, is(SystemSchemaBuilderRule.POSTGRESQL_PG_CATALOG));
-        assertThat(actualPgCatalog.getTables().size(), is(7));
+        assertThat(actualPgCatalog.getTables().size(), is(9));
     }
     
     @Test
@@ -54,7 +54,9 @@ class SystemSchemaBuilderRuleTest {
     void assertIsisSystemTable() {
         assertTrue(SystemSchemaBuilderRule.isSystemTable("information_schema", "columns"));
         assertTrue(SystemSchemaBuilderRule.isSystemTable("pg_catalog", "pg_database"));
+        assertTrue(SystemSchemaBuilderRule.isSystemTable("pg_catalog", "pg_tables"));
         assertTrue(SystemSchemaBuilderRule.isSystemTable("pg_catalog", "pg_aggregate"));
+        assertTrue(SystemSchemaBuilderRule.isSystemTable("pg_catalog", "pg_roles"));
         assertFalse(SystemSchemaBuilderRule.isSystemTable("sharding_db", "t_order"));
     }
 }
diff --git a/infra/common/src/test/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderTest.java b/infra/common/src/test/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderTest.java
index ac140a4790b..1e12fa4ab78 100644
--- a/infra/common/src/test/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderTest.java
+++ b/infra/common/src/test/java/org/apache/shardingsphere/infra/metadata/database/schema/builder/SystemSchemaBuilderTest.java
@@ -55,7 +55,7 @@ class SystemSchemaBuilderTest {
         assertTrue(actual.containsKey("pg_catalog"));
         assertTrue(actual.containsKey("shardingsphere"));
         assertThat(actual.get("information_schema").getTables().size(), is(3));
-        assertThat(actual.get("pg_catalog").getTables().size(), is(7));
+        assertThat(actual.get("pg_catalog").getTables().size(), is(9));
         assertThat(actual.get("shardingsphere").getTables().size(), is(2));
     }
     
diff --git a/infra/context/src/main/java/org/apache/shardingsphere/infra/connection/validator/ShardingSphereMetaDataValidateUtils.java b/infra/context/src/main/java/org/apache/shardingsphere/infra/connection/validator/ShardingSphereMetaDataValidateUtils.java
index f47d6b3f4a6..e3209a97f69 100644
--- a/infra/context/src/main/java/org/apache/shardingsphere/infra/connection/validator/ShardingSphereMetaDataValidateUtils.java
+++ b/infra/context/src/main/java/org/apache/shardingsphere/infra/connection/validator/ShardingSphereMetaDataValidateUtils.java
@@ -25,6 +25,9 @@ import org.apache.shardingsphere.infra.database.type.DatabaseTypeEngine;
 import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
 import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereSchema;
 
+import java.util.Collection;
+import java.util.HashSet;
+
 /**
  * ShardingSphere meta data validate utility class.
  */
@@ -32,6 +35,12 @@ import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSp
 @NoArgsConstructor(access = AccessLevel.PRIVATE)
 public final class ShardingSphereMetaDataValidateUtils {
     
+    private static final Collection<String> EXCLUDE_VALIDATE_TABLES = new HashSet<>(1, 1F);
+    
+    static {
+        EXCLUDE_VALIDATE_TABLES.add("DUAL");
+    }
+    
     /**
      * Validate table exist.
      *
@@ -43,7 +52,7 @@ public final class ShardingSphereMetaDataValidateUtils {
         String defaultSchemaName = DatabaseTypeEngine.getDefaultSchemaName(sqlStatementContext.getDatabaseType(), database.getName());
         ShardingSphereSchema schema = sqlStatementContext.getTablesContext().getSchemaName().map(database::getSchema).orElseGet(() -> database.getSchema(defaultSchemaName));
         for (String each : sqlStatementContext.getTablesContext().getTableNames()) {
-            if (!schema.containsTable(each)) {
+            if (!EXCLUDE_VALIDATE_TABLES.contains(each.toUpperCase()) && !schema.containsTable(each)) {
                 throw new NoSuchTableException(each);
             }
         }
diff --git a/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/QueryResult.java b/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/QueryResult.java
index 99eabddaf13..e2a8460702d 100644
--- a/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/QueryResult.java
+++ b/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/QueryResult.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.infra.executor.sql.execute.result.query;
 import org.apache.shardingsphere.infra.executor.sql.execute.result.ExecuteResult;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 
@@ -67,6 +68,15 @@ public interface QueryResult extends ExecuteResult, AutoCloseable {
      */
     InputStream getInputStream(int columnIndex, String type) throws SQLException;
     
+    /**
+     * Get CharacterStream.
+     *
+     * @param columnIndex column index
+     * @return reader
+     * @throws SQLException SQL exception
+     */
+    Reader getCharacterStream(int columnIndex) throws SQLException;
+    
     /**
      * Judge result set is null or not.
      *
diff --git a/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/impl/driver/jdbc/type/stream/JDBCStreamQueryResult.java b/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/impl/driver/jdbc/type/stream/JDBCStreamQueryResult.java
index 60663208772..bcfaba882b1 100644
--- a/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/impl/driver/jdbc/type/stream/JDBCStreamQueryResult.java
+++ b/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/impl/driver/jdbc/type/stream/JDBCStreamQueryResult.java
@@ -24,6 +24,7 @@ import org.apache.shardingsphere.infra.executor.sql.execute.result.query.impl.dr
 import org.apache.shardingsphere.infra.executor.sql.execute.result.query.type.stream.AbstractStreamQueryResult;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.math.BigDecimal;
 import java.sql.Array;
 import java.sql.Blob;
@@ -135,6 +136,11 @@ public final class JDBCStreamQueryResult extends AbstractStreamQueryResult {
         }
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        return resultSet.getCharacterStream(columnIndex);
+    }
+    
     @Override
     public boolean wasNull() throws SQLException {
         return resultSet.wasNull();
diff --git a/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/type/memory/AbstractMemoryQueryResult.java b/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/type/memory/AbstractMemoryQueryResult.java
index e37f906a809..0a92070ea4f 100644
--- a/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/type/memory/AbstractMemoryQueryResult.java
+++ b/infra/executor/src/main/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/type/memory/AbstractMemoryQueryResult.java
@@ -23,11 +23,15 @@ import org.apache.shardingsphere.infra.executor.sql.execute.result.query.QueryRe
 import org.apache.shardingsphere.infra.executor.sql.execute.result.query.QueryResultMetaData;
 import org.apache.shardingsphere.infra.executor.sql.execute.result.query.type.memory.row.MemoryQueryResultDataRow;
 
+import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.io.ObjectOutputStream;
+import java.io.Reader;
+import java.sql.SQLException;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Iterator;
@@ -98,6 +102,12 @@ public abstract class AbstractMemoryQueryResult implements QueryResult {
         return new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        // TODO Support connection property character encoding
+        return new BufferedReader(new InputStreamReader(getInputStream(columnIndex)));
+    }
+    
     @Override
     public final boolean wasNull() {
         return wasNull;
diff --git a/infra/executor/src/test/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/impl/driver/jdbc/type/stream/JDBCStreamQueryResultTest.java b/infra/executor/src/test/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/impl/driver/jdbc/type/stream/JDBCStreamQueryResultTest.java
index 7e3076541dc..9353519f6e6 100644
--- a/infra/executor/src/test/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/impl/driver/jdbc/type/stream/JDBCStreamQueryResultTest.java
+++ b/infra/executor/src/test/java/org/apache/shardingsphere/infra/executor/sql/execute/result/query/impl/driver/jdbc/type/stream/JDBCStreamQueryResultTest.java
@@ -237,6 +237,15 @@ class JDBCStreamQueryResultTest {
         assertThrows(SQLException.class, () -> queryResult.getInputStream(1, "Unsupported Type"));
     }
     
+    @Test
+    void assertGetCharacterStream() throws SQLException {
+        ResultSet resultSet = getResultSet();
+        JDBCStreamQueryResult queryResult = new JDBCStreamQueryResult(resultSet);
+        queryResult.next();
+        queryResult.getCharacterStream(1);
+        verify(resultSet).getCharacterStream(1);
+    }
+    
     @Test
     void assertWasNull() throws SQLException {
         JDBCStreamQueryResult queryResult = new JDBCStreamQueryResult(getResultSet());
diff --git a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/MergedResult.java b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/MergedResult.java
index ac31372f71e..d7f4610f2b0 100644
--- a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/MergedResult.java
+++ b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/MergedResult.java
@@ -18,6 +18,7 @@
 package org.apache.shardingsphere.infra.merge.result;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 
@@ -65,6 +66,15 @@ public interface MergedResult {
      */
     InputStream getInputStream(int columnIndex, String type) throws SQLException;
     
+    /**
+     * Get CharacterStream.
+     *
+     * @param columnIndex column index
+     * @return Reader
+     * @throws SQLException SQL exception
+     */
+    Reader getCharacterStream(int columnIndex) throws SQLException;
+    
     /**
      * Judge ResultSet is null or not.
      * 
diff --git a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/decorator/DecoratorMergedResult.java b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/decorator/DecoratorMergedResult.java
index e36d18a914c..7a00e7117f9 100644
--- a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/decorator/DecoratorMergedResult.java
+++ b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/decorator/DecoratorMergedResult.java
@@ -22,6 +22,7 @@ import lombok.RequiredArgsConstructor;
 import org.apache.shardingsphere.infra.merge.result.MergedResult;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 
@@ -49,6 +50,11 @@ public abstract class DecoratorMergedResult implements MergedResult {
         return mergedResult.getInputStream(columnIndex, type);
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        return mergedResult.getCharacterStream(columnIndex);
+    }
+    
     @Override
     public final boolean wasNull() throws SQLException {
         return mergedResult.wasNull();
diff --git a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/local/LocalDataMergedResult.java b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/local/LocalDataMergedResult.java
index 220bfc6bc63..d615f66ed97 100644
--- a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/local/LocalDataMergedResult.java
+++ b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/local/LocalDataMergedResult.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.infra.merge.result.impl.local;
 import org.apache.shardingsphere.infra.merge.result.MergedResult;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.sql.SQLFeatureNotSupportedException;
 import java.util.Calendar;
@@ -63,6 +64,11 @@ public final class LocalDataMergedResult implements MergedResult {
         throw new SQLFeatureNotSupportedException("getInputStream");
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        throw new SQLFeatureNotSupportedException("getCharacterStream");
+    }
+    
     @Override
     public boolean wasNull() {
         return null == currentRow;
diff --git a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/memory/MemoryMergedResult.java b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/memory/MemoryMergedResult.java
index ff3b0b06bd3..526c5f5e683 100644
--- a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/memory/MemoryMergedResult.java
+++ b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/memory/MemoryMergedResult.java
@@ -93,6 +93,11 @@ public abstract class MemoryMergedResult<T extends ShardingSphereRule> implement
         throw new SQLFeatureNotSupportedException(String.format("Get input stream from `%s`", type));
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        throw new SQLFeatureNotSupportedException("Get Character stream");
+    }
+    
     @Override
     public final boolean wasNull() {
         return wasNull;
diff --git a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/stream/StreamMergedResult.java b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/stream/StreamMergedResult.java
index 44f65a8d3be..4d70c7ce3ad 100644
--- a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/stream/StreamMergedResult.java
+++ b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/stream/StreamMergedResult.java
@@ -23,6 +23,7 @@ import org.apache.shardingsphere.infra.merge.result.MergedResult;
 import org.apache.shardingsphere.infra.util.exception.ShardingSpherePreconditions;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 
@@ -62,6 +63,13 @@ public abstract class StreamMergedResult implements MergedResult {
         return result;
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        Reader result = getCurrentQueryResult().getCharacterStream(columnIndex);
+        wasNull = getCurrentQueryResult().wasNull();
+        return result;
+    }
+    
     @Override
     public final boolean wasNull() {
         return wasNull;
diff --git a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/transparent/TransparentMergedResult.java b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/transparent/TransparentMergedResult.java
index b24eb533c80..db55ad768ed 100644
--- a/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/transparent/TransparentMergedResult.java
+++ b/infra/merge/src/main/java/org/apache/shardingsphere/infra/merge/result/impl/transparent/TransparentMergedResult.java
@@ -22,6 +22,7 @@ import org.apache.shardingsphere.infra.executor.sql.execute.result.query.QueryRe
 import org.apache.shardingsphere.infra.merge.result.MergedResult;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.SQLException;
 import java.util.Calendar;
 
@@ -53,6 +54,11 @@ public final class TransparentMergedResult implements MergedResult {
         return queryResult.getInputStream(columnIndex, type);
     }
     
+    @Override
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        return queryResult.getCharacterStream(columnIndex);
+    }
+    
     @Override
     public boolean wasNull() throws SQLException {
         return queryResult.wasNull();
diff --git a/infra/merge/src/test/java/org/apache/shardingsphere/infra/merge/result/impl/local/LocalDataMergedResultTest.java b/infra/merge/src/test/java/org/apache/shardingsphere/infra/merge/result/impl/local/LocalDataMergedResultTest.java
index 2f6ea41dc4b..1f50709a14d 100644
--- a/infra/merge/src/test/java/org/apache/shardingsphere/infra/merge/result/impl/local/LocalDataMergedResultTest.java
+++ b/infra/merge/src/test/java/org/apache/shardingsphere/infra/merge/result/impl/local/LocalDataMergedResultTest.java
@@ -64,6 +64,13 @@ class LocalDataMergedResultTest {
         assertThrows(SQLFeatureNotSupportedException.class, () -> actual.getInputStream(1, "Ascii"));
     }
     
+    @Test
+    void assertGetCharacterStream() {
+        List<Object> row = Collections.singletonList("value");
+        LocalDataMergedResult actual = new LocalDataMergedResult(Collections.singletonList(new LocalDataQueryResultRow(row)));
+        assertThrows(SQLFeatureNotSupportedException.class, () -> actual.getCharacterStream(1));
+    }
+    
     @Test
     void assertWasNull() {
         List<Object> row = Collections.singletonList("value");
diff --git a/infra/merge/src/test/java/org/apache/shardingsphere/infra/merge/result/impl/transparent/TransparentMergedResultTest.java b/infra/merge/src/test/java/org/apache/shardingsphere/infra/merge/result/impl/transparent/TransparentMergedResultTest.java
index 138de553654..6cc7a9d733f 100644
--- a/infra/merge/src/test/java/org/apache/shardingsphere/infra/merge/result/impl/transparent/TransparentMergedResultTest.java
+++ b/infra/merge/src/test/java/org/apache/shardingsphere/infra/merge/result/impl/transparent/TransparentMergedResultTest.java
@@ -21,6 +21,7 @@ import org.apache.shardingsphere.infra.executor.sql.execute.result.query.QueryRe
 import org.junit.jupiter.api.Test;
 
 import java.io.InputStream;
+import java.io.Reader;
 import java.sql.Date;
 import java.sql.SQLException;
 
@@ -67,6 +68,15 @@ class TransparentMergedResultTest {
         assertThat(actual.getInputStream(1, "Ascii"), is(value));
     }
     
+    @Test
+    void assertGetCharacterStream() throws SQLException {
+        QueryResult queryResult = mock(QueryResult.class);
+        Reader value = mock(Reader.class);
+        when(queryResult.getCharacterStream(1)).thenReturn(value);
+        TransparentMergedResult actual = new TransparentMergedResult(queryResult);
+        assertThat(actual.getCharacterStream(1), is(value));
+    }
+    
     @Test
     void assertWasNull() throws SQLException {
         TransparentMergedResult actual = new TransparentMergedResult(mock(QueryResult.class));
diff --git a/infra/rewrite/src/main/java/org/apache/shardingsphere/infra/rewrite/sql/token/pojo/generic/SubstitutableColumnNameToken.java b/infra/rewrite/src/main/java/org/apache/shardingsphere/infra/rewrite/sql/token/pojo/generic/SubstitutableColumnNameToken.java
index be67b190489..40c39db6783 100644
--- a/infra/rewrite/src/main/java/org/apache/shardingsphere/infra/rewrite/sql/token/pojo/generic/SubstitutableColumnNameToken.java
+++ b/infra/rewrite/src/main/java/org/apache/shardingsphere/infra/rewrite/sql/token/pojo/generic/SubstitutableColumnNameToken.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.infra.rewrite.sql.token.pojo.generic;
 import com.google.common.base.Strings;
 import lombok.EqualsAndHashCode;
 import lombok.Getter;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
 import org.apache.shardingsphere.infra.rewrite.sql.token.pojo.RouteUnitAware;
 import org.apache.shardingsphere.infra.rewrite.sql.token.pojo.SQLToken;
@@ -27,8 +28,6 @@ import org.apache.shardingsphere.infra.rewrite.sql.token.pojo.Substitutable;
 import org.apache.shardingsphere.infra.route.context.RouteMapper;
 import org.apache.shardingsphere.infra.route.context.RouteUnit;
 import org.apache.shardingsphere.sql.parser.sql.common.enums.QuoteCharacter;
-import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.AliasSegment;
-import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.TableSegment;
 
 import java.util.Collection;
 import java.util.Collections;
@@ -47,15 +46,13 @@ public final class SubstitutableColumnNameToken extends SQLToken implements Subs
     @Getter
     private final int stopIndex;
     
-    private final Collection<ColumnProjection> projections;
+    private final Collection<Projection> projections;
     
     private final boolean lastColumn;
     
     private final QuoteCharacter quoteCharacter;
     
-    private final Map<String, AliasSegment> tableAliasSegments = new LinkedHashMap<>();
-    
-    public SubstitutableColumnNameToken(final int startIndex, final int stopIndex, final Collection<ColumnProjection> projections) {
+    public SubstitutableColumnNameToken(final int startIndex, final int stopIndex, final Collection<Projection> projections) {
         super(startIndex);
         this.stopIndex = stopIndex;
         this.lastColumn = false;
@@ -63,7 +60,7 @@ public final class SubstitutableColumnNameToken extends SQLToken implements Subs
         this.projections = projections;
     }
     
-    public SubstitutableColumnNameToken(final int startIndex, final int stopIndex, final Collection<ColumnProjection> projections, final boolean lastColumn) {
+    public SubstitutableColumnNameToken(final int startIndex, final int stopIndex, final Collection<Projection> projections, final boolean lastColumn) {
         super(startIndex);
         this.stopIndex = stopIndex;
         this.lastColumn = lastColumn;
@@ -71,24 +68,12 @@ public final class SubstitutableColumnNameToken extends SQLToken implements Subs
         this.projections = projections;
     }
     
-    public SubstitutableColumnNameToken(final int startIndex, final int stopIndex, final Collection<ColumnProjection> projections, final QuoteCharacter quoteCharacter,
-                                        final Collection<TableSegment> tableSegments) {
+    public SubstitutableColumnNameToken(final int startIndex, final int stopIndex, final Collection<Projection> projections, final QuoteCharacter quoteCharacter) {
         super(startIndex);
         this.stopIndex = stopIndex;
         this.lastColumn = false;
         this.quoteCharacter = quoteCharacter;
         this.projections = projections;
-        tableAliasSegments.putAll(createTableAliasSegments(tableSegments));
-    }
-    
-    private Map<String, AliasSegment> createTableAliasSegments(final Collection<TableSegment> tableSegments) {
-        Map<String, AliasSegment> result = new LinkedHashMap<>();
-        for (TableSegment each : tableSegments) {
-            if (each.getAlias().isPresent()) {
-                result.put(each.getAlias().get().getIdentifier().getValue().toLowerCase(), each.getAlias().get());
-            }
-        }
-        return result;
     }
     
     @Override
@@ -99,11 +84,11 @@ public final class SubstitutableColumnNameToken extends SQLToken implements Subs
         }
         StringBuilder result = new StringBuilder();
         int count = 0;
-        for (ColumnProjection each : projections) {
+        for (Projection each : projections) {
             if (0 == count && !lastColumn) {
-                result.append(getColumnName(each, logicAndActualTables));
+                result.append(getColumnExpression(each, logicAndActualTables));
             } else {
-                result.append(COLUMN_NAME_SPLITTER).append(getColumnName(each, logicAndActualTables));
+                result.append(COLUMN_NAME_SPLITTER).append(getColumnExpression(each, logicAndActualTables));
             }
             count++;
         }
@@ -116,22 +101,30 @@ public final class SubstitutableColumnNameToken extends SQLToken implements Subs
         }
         Map<String, String> result = new LinkedHashMap<>();
         for (RouteMapper each : routeUnit.getTableMappers()) {
-            result.put(each.getLogicName(), each.getActualName());
+            result.put(each.getLogicName().toLowerCase(), each.getActualName());
         }
         return result;
     }
     
-    private String getColumnName(final ColumnProjection columnProjection, final Map<String, String> logicActualTableNames) {
+    private String getColumnExpression(final Projection projection, final Map<String, String> logicActualTableNames) {
         StringBuilder builder = new StringBuilder();
-        String owner = columnProjection.getOwner();
-        if (!Strings.isNullOrEmpty(owner)) {
-            QuoteCharacter ownerQuoteCharacter = tableAliasSegments.containsKey(owner.toLowerCase()) ? tableAliasSegments.get(owner.toLowerCase()).getIdentifier().getQuoteCharacter() : quoteCharacter;
-            builder.append(ownerQuoteCharacter.wrap(logicActualTableNames.getOrDefault(owner, owner))).append('.');
+        if (projection instanceof ColumnProjection) {
+            appendColumnProjection((ColumnProjection) projection, logicActualTableNames, builder);
+        } else {
+            // TODO use alias quoteCharacter to avoid oracle rewrite error
+            builder.append(quoteCharacter.wrap(projection.getColumnLabel()));
+        }
+        return builder.toString();
+    }
+    
+    private static void appendColumnProjection(final ColumnProjection columnProjection, final Map<String, String> logicActualTableNames, final StringBuilder builder) {
+        if (!Strings.isNullOrEmpty(columnProjection.getOwner())) {
+            String lowerCaseOwner = columnProjection.getOwner().toLowerCase();
+            builder.append(columnProjection.getOwnerIdentifier().getQuoteCharacter().wrap(logicActualTableNames.getOrDefault(lowerCaseOwner, columnProjection.getOwner()))).append('.');
         }
         builder.append(columnProjection.getNameIdentifier().getQuoteCharacter().wrap(columnProjection.getName()));
         if (columnProjection.getAlias().isPresent()) {
             builder.append(" AS ").append(columnProjection.getAliasIdentifier().getQuoteCharacter().wrap(columnProjection.getAlias().get()));
         }
-        return builder.toString();
     }
 }
diff --git a/infra/rewrite/src/test/java/org/apache/shardingsphere/infra/rewrite/sql/token/pojo/generic/SubstitutableColumnNameTokenTest.java b/infra/rewrite/src/test/java/org/apache/shardingsphere/infra/rewrite/sql/token/pojo/generic/SubstitutableColumnNameTokenTest.java
index 806d2e738d5..b0697dc2643 100644
--- a/infra/rewrite/src/test/java/org/apache/shardingsphere/infra/rewrite/sql/token/pojo/generic/SubstitutableColumnNameTokenTest.java
+++ b/infra/rewrite/src/test/java/org/apache/shardingsphere/infra/rewrite/sql/token/pojo/generic/SubstitutableColumnNameTokenTest.java
@@ -17,15 +17,16 @@
 
 package org.apache.shardingsphere.infra.rewrite.sql.token.pojo.generic;
 
+import org.apache.shardingsphere.infra.binder.segment.select.projection.Projection;
 import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.ColumnProjection;
+import org.apache.shardingsphere.infra.binder.segment.select.projection.impl.SubqueryProjection;
+import org.apache.shardingsphere.infra.database.type.dialect.OracleDatabaseType;
 import org.apache.shardingsphere.infra.route.context.RouteUnit;
 import org.apache.shardingsphere.sql.parser.sql.common.enums.QuoteCharacter;
-import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.AliasSegment;
-import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;
-import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.TableNameSegment;
 import org.apache.shardingsphere.sql.parser.sql.common.value.identifier.IdentifierValue;
 import org.junit.jupiter.api.Test;
 
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 
@@ -37,25 +38,33 @@ class SubstitutableColumnNameTokenTest {
     
     @Test
     void assertToString() {
-        Collection<ColumnProjection> projections = Collections.singletonList(new ColumnProjection(null, "id", null));
+        Collection<Projection> projections = Collections.singletonList(new ColumnProjection(null, "id", null));
         assertThat(new SubstitutableColumnNameToken(0, 1, projections).toString(mock(RouteUnit.class)), is("id"));
     }
     
     @Test
     void assertToStringWithQuote() {
-        Collection<ColumnProjection> projections = Collections.singletonList(new ColumnProjection(null,
+        Collection<Projection> projections = Collections.singletonList(new ColumnProjection(null,
                 new IdentifierValue("id", QuoteCharacter.BACK_QUOTE), new IdentifierValue("id", QuoteCharacter.BACK_QUOTE)));
-        assertThat(new SubstitutableColumnNameToken(0, 1, projections, QuoteCharacter.BACK_QUOTE, Collections.emptyList()).toString(mock(RouteUnit.class)), is("`id` AS `id`"));
+        assertThat(new SubstitutableColumnNameToken(0, 1, projections, QuoteCharacter.BACK_QUOTE).toString(mock(RouteUnit.class)), is("`id` AS `id`"));
     }
     
     @Test
-    void assertToStringWithAliasQuote() {
-        Collection<ColumnProjection> projections = Collections.singletonList(new ColumnProjection(new IdentifierValue("temp", QuoteCharacter.BACK_QUOTE),
+    void assertToStringWithOwnerQuote() {
+        Collection<Projection> projectionsWithOwnerQuote = Collections.singletonList(new ColumnProjection(new IdentifierValue("temp", QuoteCharacter.BACK_QUOTE),
                 new IdentifierValue("id", QuoteCharacter.BACK_QUOTE), new IdentifierValue("id", QuoteCharacter.BACK_QUOTE)));
-        SimpleTableSegment tableSegment = new SimpleTableSegment(new TableNameSegment(0, 0, new IdentifierValue("t_order")));
-        tableSegment.setAlias(new AliasSegment(0, 0, new IdentifierValue("`temp`")));
-        assertThat(new SubstitutableColumnNameToken(0, 1, projections, QuoteCharacter.BACK_QUOTE, Collections.singletonList(tableSegment)).toString(mock(RouteUnit.class)), is("`temp`.`id` AS `id`"));
-        tableSegment.setAlias(new AliasSegment(0, 0, new IdentifierValue("temp")));
-        assertThat(new SubstitutableColumnNameToken(0, 1, projections, QuoteCharacter.BACK_QUOTE, Collections.singletonList(tableSegment)).toString(mock(RouteUnit.class)), is("temp.`id` AS `id`"));
+        assertThat(new SubstitutableColumnNameToken(0, 1, projectionsWithOwnerQuote, QuoteCharacter.BACK_QUOTE).toString(mock(RouteUnit.class)), is("`temp`.`id` AS `id`"));
+        Collection<Projection> projectionsWithoutOwnerQuote = Collections.singletonList(new ColumnProjection(new IdentifierValue("temp", QuoteCharacter.NONE),
+                new IdentifierValue("id", QuoteCharacter.BACK_QUOTE), new IdentifierValue("id", QuoteCharacter.BACK_QUOTE)));
+        assertThat(new SubstitutableColumnNameToken(0, 1, projectionsWithoutOwnerQuote, QuoteCharacter.BACK_QUOTE).toString(mock(RouteUnit.class)), is("temp.`id` AS `id`"));
+    }
+    
+    @Test
+    void assertToStringWithSubqueryProjection() {
+        Collection<Projection> projections = Arrays.asList(new ColumnProjection(new IdentifierValue("temp", QuoteCharacter.BACK_QUOTE),
+                new IdentifierValue("id", QuoteCharacter.BACK_QUOTE), new IdentifierValue("id", QuoteCharacter.BACK_QUOTE)),
+                new SubqueryProjection("(SELECT name FROM t_order)", new ColumnProjection(null, "name", null), "name", new OracleDatabaseType()));
+        assertThat(new SubstitutableColumnNameToken(0, 1, projections, QuoteCharacter.BACK_QUOTE).toString(mock(RouteUnit.class)),
+                is("`temp`.`id` AS `id`, `name`"));
     }
 }
diff --git a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/api/yaml/YamlJDBCConfiguration.java b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/api/yaml/YamlJDBCConfiguration.java
index 40e914cfdfa..146af6feefa 100644
--- a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/api/yaml/YamlJDBCConfiguration.java
+++ b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/api/yaml/YamlJDBCConfiguration.java
@@ -27,6 +27,7 @@ import org.apache.shardingsphere.infra.yaml.config.pojo.mode.YamlModeConfigurati
 import org.apache.shardingsphere.infra.yaml.config.pojo.rule.YamlRuleConfiguration;
 import org.apache.shardingsphere.logging.yaml.config.YamlLoggingRuleConfiguration;
 import org.apache.shardingsphere.parser.yaml.config.YamlSQLParserRuleConfiguration;
+import org.apache.shardingsphere.sqlfederation.yaml.config.YamlSQLFederationRuleConfiguration;
 import org.apache.shardingsphere.sqltranslator.yaml.config.YamlSQLTranslatorRuleConfiguration;
 import org.apache.shardingsphere.traffic.yaml.config.YamlTrafficRuleConfiguration;
 import org.apache.shardingsphere.transaction.yaml.config.YamlTransactionRuleConfiguration;
@@ -76,6 +77,8 @@ public final class YamlJDBCConfiguration implements YamlConfiguration {
     
     private YamlGlobalClockRuleConfiguration globalClock;
     
+    private YamlSQLFederationRuleConfiguration sqlFederation;
+    
     /**
      * Get database name.
      * 
diff --git a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/api/yaml/YamlShardingSphereDataSourceFactory.java b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/api/yaml/YamlShardingSphereDataSourceFactory.java
index 87a43051511..2f33ff5f88d 100644
--- a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/api/yaml/YamlShardingSphereDataSourceFactory.java
+++ b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/api/yaml/YamlShardingSphereDataSourceFactory.java
@@ -190,5 +190,8 @@ public final class YamlShardingSphereDataSourceFactory {
         if (null != jdbcConfiguration.getLogging()) {
             jdbcConfiguration.getRules().add(jdbcConfiguration.getLogging());
         }
+        if (null != jdbcConfiguration.getSqlFederation()) {
+            jdbcConfiguration.getRules().add(jdbcConfiguration.getSqlFederation());
+        }
     }
 }
diff --git a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/resultset/ShardingSphereResultSet.java b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/resultset/ShardingSphereResultSet.java
index 6d93ec9babd..9d6ec2c9146 100644
--- a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/resultset/ShardingSphereResultSet.java
+++ b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/resultset/ShardingSphereResultSet.java
@@ -298,7 +298,8 @@ public final class ShardingSphereResultSet extends AbstractResultSetAdapter {
     
     @Override
     public Reader getCharacterStream(final int columnIndex) throws SQLException {
-        return (Reader) mergeResultSet.getValue(columnIndex, Reader.class);
+        // TODO To be supported: encrypt, mask, and so on
+        return mergeResultSet.getCharacterStream(columnIndex);
     }
     
     @Override
diff --git a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/statement/ShardingSpherePreparedStatement.java b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/statement/ShardingSpherePreparedStatement.java
index 596301cd447..2d9b42e2219 100644
--- a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/statement/ShardingSpherePreparedStatement.java
+++ b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/statement/ShardingSpherePreparedStatement.java
@@ -34,12 +34,11 @@ import org.apache.shardingsphere.driver.jdbc.core.statement.metadata.ShardingSph
 import org.apache.shardingsphere.driver.jdbc.exception.syntax.EmptySQLException;
 import org.apache.shardingsphere.infra.binder.SQLStatementContextFactory;
 import org.apache.shardingsphere.infra.binder.aware.ParameterAware;
-import org.apache.shardingsphere.infra.binder.decider.SQLFederationDecideEngine;
+import org.apache.shardingsphere.sqlfederation.decider.SQLFederationDecideEngine;
 import org.apache.shardingsphere.infra.binder.segment.insert.keygen.GeneratedKeyContext;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.InsertStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
-import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
 import org.apache.shardingsphere.infra.config.props.ConfigurationPropertyKey;
 import org.apache.shardingsphere.infra.connection.kernel.KernelProcessor;
 import org.apache.shardingsphere.infra.database.type.DatabaseType;
@@ -261,7 +260,7 @@ public final class ShardingSpherePreparedStatement extends AbstractPreparedState
                 return executor.getTrafficExecutor().execute(executionUnit, (statement, sql) -> ((PreparedStatement) statement).executeQuery());
             }
             useFederation = decide(queryContext,
-                    metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData(), metaDataContexts.getMetaData().getProps());
+                    metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData());
             if (useFederation) {
                 return executeFederationQuery(queryContext);
             }
@@ -285,8 +284,8 @@ public final class ShardingSpherePreparedStatement extends AbstractPreparedState
         return result;
     }
     
-    private boolean decide(final QueryContext queryContext, final ShardingSphereDatabase database, final ShardingSphereRuleMetaData globalRuleMetaData, final ConfigurationProperties props) {
-        return new SQLFederationDecideEngine(database.getRuleMetaData().getRules(), props).decide(queryContext.getSqlStatementContext(), queryContext.getParameters(), database, globalRuleMetaData);
+    private boolean decide(final QueryContext queryContext, final ShardingSphereDatabase database, final ShardingSphereRuleMetaData globalRuleMetaData) {
+        return new SQLFederationDecideEngine(database.getRuleMetaData().getRules()).decide(queryContext.getSqlStatementContext(), queryContext.getParameters(), database, globalRuleMetaData);
     }
     
     private JDBCExecutionUnit createTrafficExecutionUnit(final String trafficInstanceId, final QueryContext queryContext) throws SQLException {
@@ -428,7 +427,7 @@ public final class ShardingSpherePreparedStatement extends AbstractPreparedState
                 return executor.getTrafficExecutor().execute(executionUnit, (statement, sql) -> ((PreparedStatement) statement).execute());
             }
             useFederation = decide(queryContext,
-                    metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData(), metaDataContexts.getMetaData().getProps());
+                    metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData());
             if (useFederation) {
                 ResultSet resultSet = executeFederationQuery(queryContext);
                 return null != resultSet;
diff --git a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/statement/ShardingSphereStatement.java b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/statement/ShardingSphereStatement.java
index 3b3ff67fda2..bd6ff57d570 100644
--- a/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/statement/ShardingSphereStatement.java
+++ b/jdbc/core/src/main/java/org/apache/shardingsphere/driver/jdbc/core/statement/ShardingSphereStatement.java
@@ -33,13 +33,12 @@ import org.apache.shardingsphere.driver.jdbc.core.resultset.ShardingSphereResult
 import org.apache.shardingsphere.driver.jdbc.exception.syntax.EmptySQLException;
 import org.apache.shardingsphere.driver.jdbc.exception.transaction.JDBCTransactionAcrossDatabasesException;
 import org.apache.shardingsphere.infra.binder.SQLStatementContextFactory;
-import org.apache.shardingsphere.infra.binder.decider.SQLFederationDecideEngine;
+import org.apache.shardingsphere.sqlfederation.decider.SQLFederationDecideEngine;
 import org.apache.shardingsphere.infra.binder.segment.insert.keygen.GeneratedKeyContext;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.InsertStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
 import org.apache.shardingsphere.infra.binder.type.TableAvailable;
-import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
 import org.apache.shardingsphere.infra.config.props.ConfigurationPropertyKey;
 import org.apache.shardingsphere.infra.connection.kernel.KernelProcessor;
 import org.apache.shardingsphere.infra.database.type.DatabaseType;
@@ -172,7 +171,7 @@ public final class ShardingSphereStatement extends AbstractStatementAdapter {
                 return executor.getTrafficExecutor().execute(executionUnit, Statement::executeQuery);
             }
             useFederation = decide(queryContext,
-                    metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData(), metaDataContexts.getMetaData().getProps());
+                    metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData());
             if (useFederation) {
                 return executeFederationQuery(queryContext);
             }
@@ -193,8 +192,8 @@ public final class ShardingSphereStatement extends AbstractStatementAdapter {
         return result;
     }
     
-    private boolean decide(final QueryContext queryContext, final ShardingSphereDatabase database, final ShardingSphereRuleMetaData globalRuleMetaData, final ConfigurationProperties props) {
-        return new SQLFederationDecideEngine(database.getRuleMetaData().getRules(), props).decide(queryContext.getSqlStatementContext(), queryContext.getParameters(), database, globalRuleMetaData);
+    private boolean decide(final QueryContext queryContext, final ShardingSphereDatabase database, final ShardingSphereRuleMetaData globalRuleMetaData) {
+        return new SQLFederationDecideEngine(database.getRuleMetaData().getRules()).decide(queryContext.getSqlStatementContext(), queryContext.getParameters(), database, globalRuleMetaData);
     }
     
     private Optional<String> getInstanceIdAndSet(final QueryContext queryContext) {
@@ -466,7 +465,7 @@ public final class ShardingSphereStatement extends AbstractStatementAdapter {
                 return executor.getTrafficExecutor().execute(executionUnit, trafficCallback);
             }
             useFederation = decide(queryContext,
-                    metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData(), metaDataContexts.getMetaData().getProps());
+                    metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData());
             if (useFederation) {
                 ResultSet resultSet = executeFederationQuery(queryContext);
                 return null != resultSet;
diff --git a/jdbc/core/src/test/java/org/apache/shardingsphere/driver/jdbc/adapter/ResultSetGetterAdapterTest.java b/jdbc/core/src/test/java/org/apache/shardingsphere/driver/jdbc/adapter/ResultSetGetterAdapterTest.java
index 44bba35cc24..8055db2578f 100644
--- a/jdbc/core/src/test/java/org/apache/shardingsphere/driver/jdbc/adapter/ResultSetGetterAdapterTest.java
+++ b/jdbc/core/src/test/java/org/apache/shardingsphere/driver/jdbc/adapter/ResultSetGetterAdapterTest.java
@@ -18,6 +18,7 @@
 package org.apache.shardingsphere.driver.jdbc.adapter;
 
 import org.apache.shardingsphere.driver.jdbc.core.resultset.ShardingSphereResultSet;
+import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.executor.sql.context.ExecutionContext;
 import org.apache.shardingsphere.infra.merge.result.MergedResult;
 import org.junit.jupiter.api.Test;
@@ -343,7 +344,7 @@ class ResultSetGetterAdapterTest {
     void assertGetCharacterStreamForColumnIndex() throws SQLException {
         Reader reader = mock(Reader.class);
         MergedResult mergedResult = mock(MergedResult.class);
-        when(mergedResult.getValue(1, Reader.class)).thenReturn(reader);
+        when(mergedResult.getCharacterStream(1)).thenReturn(reader);
         assertThat(mockShardingSphereResultSet(mergedResult).getCharacterStream(1), is(reader));
     }
     
@@ -351,7 +352,7 @@ class ResultSetGetterAdapterTest {
     void assertGetCharacterStreamForColumnLabel() throws SQLException {
         Reader reader = mock(Reader.class);
         MergedResult mergedResult = mock(MergedResult.class);
-        when(mergedResult.getValue(1, Reader.class)).thenReturn(reader);
+        when(mergedResult.getCharacterStream(1)).thenReturn(reader);
         assertThat(mockShardingSphereResultSet(mergedResult).getCharacterStream("col"), is(reader));
     }
     
@@ -439,6 +440,9 @@ class ResultSetGetterAdapterTest {
         ResultSet resultSet = mock(ResultSet.class);
         when(resultSetMetaData.getColumnCount()).thenReturn(1);
         when(resultSet.getMetaData()).thenReturn(resultSetMetaData);
-        return new ShardingSphereResultSet(Collections.singletonList(resultSet), mergedResult, mock(Statement.class), true, mock(ExecutionContext.class));
+        SQLStatementContext sqlStatementContext = mock(SQLStatementContext.class);
+        ExecutionContext executionContext = mock(ExecutionContext.class);
+        when(executionContext.getSqlStatementContext()).thenReturn(sqlStatementContext);
+        return new ShardingSphereResultSet(Collections.singletonList(resultSet), mergedResult, mock(Statement.class), true, executionContext);
     }
 }
diff --git a/jdbc/core/src/test/java/org/apache/shardingsphere/driver/jdbc/core/resultset/ShardingSphereResultSetTest.java b/jdbc/core/src/test/java/org/apache/shardingsphere/driver/jdbc/core/resultset/ShardingSphereResultSetTest.java
index 6e9784599f5..7956854a5cd 100644
--- a/jdbc/core/src/test/java/org/apache/shardingsphere/driver/jdbc/core/resultset/ShardingSphereResultSetTest.java
+++ b/jdbc/core/src/test/java/org/apache/shardingsphere/driver/jdbc/core/resultset/ShardingSphereResultSetTest.java
@@ -391,14 +391,14 @@ class ShardingSphereResultSetTest {
     @Test
     void assertGetCharacterStreamWithColumnIndex() throws SQLException {
         Reader reader = mock(Reader.class);
-        when(mergeResultSet.getValue(1, Reader.class)).thenReturn(reader);
+        when(mergeResultSet.getCharacterStream(1)).thenReturn(reader);
         assertThat(shardingSphereResultSet.getCharacterStream(1), is(reader));
     }
     
     @Test
     void assertGetCharacterStreamWithColumnLabel() throws SQLException {
         Reader reader = mock(Reader.class);
-        when(mergeResultSet.getValue(1, Reader.class)).thenReturn(reader);
+        when(mergeResultSet.getCharacterStream(1)).thenReturn(reader);
         assertThat(shardingSphereResultSet.getCharacterStream("label"), is(reader));
     }
     
diff --git a/kernel/authority/core/src/main/java/org/apache/shardingsphere/authority/metadata/converter/AuthorityNodeConverter.java b/kernel/authority/core/src/main/java/org/apache/shardingsphere/authority/metadata/converter/AuthorityNodeConverter.java
new file mode 100644
index 00000000000..6c72868b607
--- /dev/null
+++ b/kernel/authority/core/src/main/java/org/apache/shardingsphere/authority/metadata/converter/AuthorityNodeConverter.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.authority.metadata.converter;
+
+import lombok.AccessLevel;
+import lombok.NoArgsConstructor;
+
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Authority node converter.
+ */
+@NoArgsConstructor(access = AccessLevel.PRIVATE)
+public final class AuthorityNodeConverter {
+    
+    private static final String ROOT_NODE = "authority/";
+    
+    private static final String VERSION_NODE_PREFIX = "/rules/" + ROOT_NODE;
+    
+    /**
+     * Get group name path.
+     *
+     * @return group name path
+     */
+    public static String getRootNode() {
+        return ROOT_NODE;
+    }
+    
+    /**
+     * Get version.
+     *
+     * @param rulePath rule path
+     * @return version
+     */
+    public static Optional<String> getVersion(final String rulePath) {
+        Pattern pattern = Pattern.compile(VERSION_NODE_PREFIX + "versions" + "/([\\w\\-]+)$", Pattern.CASE_INSENSITIVE);
+        Matcher matcher = pattern.matcher(rulePath);
+        return matcher.find() ? Optional.of(matcher.group(1)) : Optional.empty();
+    }
+}
diff --git a/kernel/authority/core/src/main/java/org/apache/shardingsphere/authority/yaml/swapper/NewYamlAuthorityRuleConfigurationSwapper.java b/kernel/authority/core/src/main/java/org/apache/shardingsphere/authority/yaml/swapper/NewYamlAuthorityRuleConfigurationSwapper.java
new file mode 100644
index 00000000000..f1723f8959f
--- /dev/null
+++ b/kernel/authority/core/src/main/java/org/apache/shardingsphere/authority/yaml/swapper/NewYamlAuthorityRuleConfigurationSwapper.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.authority.yaml.swapper;
+
+import org.apache.shardingsphere.authority.config.AuthorityRuleConfiguration;
+import org.apache.shardingsphere.authority.constant.AuthorityOrder;
+import org.apache.shardingsphere.authority.converter.YamlUsersConfigurationConverter;
+import org.apache.shardingsphere.authority.metadata.converter.AuthorityNodeConverter;
+import org.apache.shardingsphere.authority.rule.builder.DefaultAuthorityRuleConfigurationBuilder;
+import org.apache.shardingsphere.authority.yaml.config.YamlAuthorityRuleConfiguration;
+import org.apache.shardingsphere.infra.util.yaml.YamlEngine;
+import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
+import org.apache.shardingsphere.infra.yaml.config.swapper.algorithm.YamlAlgorithmConfigurationSwapper;
+import org.apache.shardingsphere.infra.yaml.config.swapper.rule.NewYamlRuleConfigurationSwapper;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Optional;
+
+/**
+ * TODO Rename YamlAuthorityRuleConfigurationSwapper when metadata structure adjustment completed. #25485
+ * New YAML Authority rule configuration swapper.
+ */
+public final class NewYamlAuthorityRuleConfigurationSwapper implements NewYamlRuleConfigurationSwapper<AuthorityRuleConfiguration> {
+    
+    private final YamlAlgorithmConfigurationSwapper algorithmSwapper = new YamlAlgorithmConfigurationSwapper();
+    
+    @Override
+    public Collection<YamlDataNode> swapToDataNodes(final AuthorityRuleConfiguration data) {
+        return Collections.singletonList(new YamlDataNode(AuthorityNodeConverter.getRootNode(), YamlEngine.marshal(swapToYamlConfiguration(data))));
+        
+    }
+    
+    private YamlAuthorityRuleConfiguration swapToYamlConfiguration(final AuthorityRuleConfiguration data) {
+        YamlAuthorityRuleConfiguration result = new YamlAuthorityRuleConfiguration();
+        result.setPrivilege(algorithmSwapper.swapToYamlConfiguration(data.getAuthorityProvider()));
+        result.setUsers(YamlUsersConfigurationConverter.convertToYamlUserConfiguration(data.getUsers()));
+        result.setDefaultAuthenticator(data.getDefaultAuthenticator());
+        if (!data.getAuthenticators().isEmpty()) {
+            data.getAuthenticators().forEach((key, value) -> result.getAuthenticators().put(key, algorithmSwapper.swapToYamlConfiguration(value)));
+        }
+        return result;
+    }
+    
+    @Override
+    public AuthorityRuleConfiguration swapToObject(final Collection<YamlDataNode> dataNodes) {
+        for (YamlDataNode each : dataNodes) {
+            Optional<String> version = AuthorityNodeConverter.getVersion(each.getKey());
+            if (!version.isPresent()) {
+                continue;
+            }
+            return YamlEngine.unmarshal(each.getValue(), AuthorityRuleConfiguration.class);
+        }
+        return new AuthorityRuleConfiguration(Collections.emptyList(), new DefaultAuthorityRuleConfigurationBuilder().build().getAuthorityProvider(), "");
+    }
+    
+    @Override
+    public Class<AuthorityRuleConfiguration> getTypeClass() {
+        return AuthorityRuleConfiguration.class;
+    }
+    
+    @Override
+    public String getRuleTagName() {
+        return "AUTHORITY";
+    }
+    
+    @Override
+    public int getOrder() {
+        return AuthorityOrder.ORDER;
+    }
+}
diff --git a/kernel/authority/core/src/test/java/org/apache/shardingsphere/authority/metadata/AuthorityNodeConverterTest.java b/kernel/authority/core/src/test/java/org/apache/shardingsphere/authority/metadata/AuthorityNodeConverterTest.java
new file mode 100644
index 00000000000..6b861643f33
--- /dev/null
+++ b/kernel/authority/core/src/test/java/org/apache/shardingsphere/authority/metadata/AuthorityNodeConverterTest.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.authority.metadata;
+
+import org.apache.shardingsphere.authority.metadata.converter.AuthorityNodeConverter;
+import org.junit.jupiter.api.Test;
+
+import java.util.Optional;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+class AuthorityNodeConverterTest {
+    
+    @Test
+    void assetGetRootNode() {
+        assertThat(AuthorityNodeConverter.getRootNode(), is("authority/"));
+    }
+    
+    @Test
+    void assertGetVersion() {
+        Optional<String> actual = AuthorityNodeConverter.getVersion("/rules/authority/versions/0");
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), is("0"));
+    }
+}
diff --git a/kernel/authority/core/src/test/java/org/apache/shardingsphere/authority/yaml/swapper/NewYamlAuthorityRuleConfigurationSwapperTest.java b/kernel/authority/core/src/test/java/org/apache/shardingsphere/authority/yaml/swapper/NewYamlAuthorityRuleConfigurationSwapperTest.java
new file mode 100644
index 00000000000..e4ced41489d
--- /dev/null
+++ b/kernel/authority/core/src/test/java/org/apache/shardingsphere/authority/yaml/swapper/NewYamlAuthorityRuleConfigurationSwapperTest.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.authority.yaml.swapper;
+
+import org.apache.shardingsphere.authority.config.AuthorityRuleConfiguration;
+import org.apache.shardingsphere.infra.config.algorithm.AlgorithmConfiguration;
+import org.apache.shardingsphere.infra.metadata.user.ShardingSphereUser;
+import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
+import org.junit.jupiter.api.Test;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Properties;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+// TODO Rename YamlAuthorityRuleConfigurationSwapperTest when metadata structure adjustment completed. #25485
+class NewYamlAuthorityRuleConfigurationSwapperTest {
+    
+    private final NewYamlAuthorityRuleConfigurationSwapper swapper = new NewYamlAuthorityRuleConfigurationSwapper();
+    
+    @Test
+    void assertSwapToDataNodes() {
+        Collection<ShardingSphereUser> users = Collections.singleton(new ShardingSphereUser("root", "", "localhost"));
+        Collection<YamlDataNode> actual = swapper.swapToDataNodes(new AuthorityRuleConfiguration(users, new AlgorithmConfiguration("ALL_PERMITTED", new Properties()), null));
+        assertThat(actual.iterator().next().getKey(), is("authority/"));
+    }
+}
diff --git a/kernel/data-pipeline/api/src/main/java/org/apache/shardingsphere/data/pipeline/api/ingest/record/DataRecord.java b/kernel/data-pipeline/api/src/main/java/org/apache/shardingsphere/data/pipeline/api/ingest/record/DataRecord.java
index 6b60eef04e7..b0f0fa5622b 100644
--- a/kernel/data-pipeline/api/src/main/java/org/apache/shardingsphere/data/pipeline/api/ingest/record/DataRecord.java
+++ b/kernel/data-pipeline/api/src/main/java/org/apache/shardingsphere/data/pipeline/api/ingest/record/DataRecord.java
@@ -37,20 +37,22 @@ import java.util.List;
 @ToString
 public final class DataRecord extends Record {
     
+    private final String type;
+    
+    private final String tableName;
+    
     private final List<Column> columns;
     
     private final List<Object> uniqueKeyValue = new LinkedList<>();
     
     private final List<Object> oldUniqueKeyValues = new ArrayList<>();
     
-    private String type;
-    
-    private String tableName;
-    
     private Long csn;
     
-    public DataRecord(final IngestPosition position, final int columnCount) {
+    public DataRecord(final String type, final String tableName, final IngestPosition position, final int columnCount) {
         super(position);
+        this.type = type;
+        this.tableName = tableName;
         columns = new ArrayList<>(columnCount);
     }
     
diff --git a/kernel/data-pipeline/api/src/main/java/org/apache/shardingsphere/data/pipeline/spi/sqlbuilder/PipelineSQLBuilder.java b/kernel/data-pipeline/api/src/main/java/org/apache/shardingsphere/data/pipeline/spi/sqlbuilder/PipelineSQLBuilder.java
index d0610dcb3be..440ff4f8363 100644
--- a/kernel/data-pipeline/api/src/main/java/org/apache/shardingsphere/data/pipeline/spi/sqlbuilder/PipelineSQLBuilder.java
+++ b/kernel/data-pipeline/api/src/main/java/org/apache/shardingsphere/data/pipeline/spi/sqlbuilder/PipelineSQLBuilder.java
@@ -136,7 +136,6 @@ public interface PipelineSQLBuilder extends TypedSPI {
      * @param tableName table name
      * @return count SQL
      */
-    // TODO keep it for now, it might be used later
     String buildCountSQL(String schemaName, String tableName);
     
     /**
@@ -148,6 +147,16 @@ public interface PipelineSQLBuilder extends TypedSPI {
      */
     Optional<String> buildEstimatedCountSQL(String schemaName, String tableName);
     
+    /**
+     * Build unique key minimum maximum values SQL.
+     *
+     * @param schemaName schema name
+     * @param tableName table name
+     * @param uniqueKey unique key
+     * @return min max unique key SQL
+     */
+    String buildUniqueKeyMinMaxValuesSQL(String schemaName, String tableName, String uniqueKey);
+    
     /**
      * Build query all ordering SQL.
      *
@@ -169,16 +178,6 @@ public interface PipelineSQLBuilder extends TypedSPI {
      */
     String buildCheckEmptySQL(String schemaName, String tableName);
     
-    /**
-     * Build split by primary key range SQL.
-     *
-     * @param schemaName schema name
-     * @param tableName table name
-     * @param uniqueKey unique key
-     * @return split SQL
-     */
-    String buildSplitByPrimaryKeyRangeSQL(String schemaName, String tableName, String uniqueKey);
-    
     /**
      * Build CRC32 SQL.
      *
diff --git a/kernel/data-pipeline/cdc/core/src/test/java/org/apache/shardingsphere/data/pipeline/cdc/util/DataRecordResultConvertUtilsTest.java b/kernel/data-pipeline/cdc/core/src/test/java/org/apache/shardingsphere/data/pipeline/cdc/util/DataRecordResultConvertUtilsTest.java
index 1da75e1d7e6..7280fdddac6 100644
--- a/kernel/data-pipeline/cdc/core/src/test/java/org/apache/shardingsphere/data/pipeline/cdc/util/DataRecordResultConvertUtilsTest.java
+++ b/kernel/data-pipeline/cdc/core/src/test/java/org/apache/shardingsphere/data/pipeline/cdc/util/DataRecordResultConvertUtilsTest.java
@@ -54,7 +54,7 @@ class DataRecordResultConvertUtilsTest {
     
     @Test
     void assertConvertDataRecordToRecord() throws InvalidProtocolBufferException, SQLException {
-        DataRecord dataRecord = new DataRecord(new IntegerPrimaryKeyPosition(0, 1), 2);
+        DataRecord dataRecord = new DataRecord("INSERT", "t_order", new IntegerPrimaryKeyPosition(0, 1), 2);
         dataRecord.addColumn(new Column("order_id", BigInteger.ONE, false, true));
         dataRecord.addColumn(new Column("price", BigDecimal.valueOf(123), false, false));
         dataRecord.addColumn(new Column("user_id", Long.MAX_VALUE, false, false));
@@ -73,8 +73,6 @@ class DataRecordResultConvertUtilsTest {
         when(mockedClob.getSubString(anyLong(), anyInt())).thenReturn("clob\n");
         dataRecord.addColumn(new Column("text_clob", mockedClob, false, false));
         dataRecord.addColumn(new Column("update_time", new Timestamp(System.currentTimeMillis()), false, false));
-        dataRecord.setTableName("t_order");
-        dataRecord.setType("INSERT");
         TypeRegistry registry = TypeRegistry.newBuilder().add(EmptyProto.getDescriptor().getMessageTypes()).add(TimestampProto.getDescriptor().getMessageTypes())
                 .add(WrappersProto.getDescriptor().getMessageTypes()).build();
         Record expectedRecord = DataRecordResultConvertUtils.convertDataRecordToRecord("test", null, dataRecord);
diff --git a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/ingest/dumper/InventoryDumper.java b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/ingest/dumper/InventoryDumper.java
index 576b437728f..59fa207e192 100644
--- a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/ingest/dumper/InventoryDumper.java
+++ b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/ingest/dumper/InventoryDumper.java
@@ -198,9 +198,7 @@ public final class InventoryDumper extends AbstractLifecycleExecutor implements
     
     private DataRecord loadDataRecord(final ResultSet resultSet, final ResultSetMetaData resultSetMetaData, final PipelineTableMetaData tableMetaData) throws SQLException {
         int columnCount = resultSetMetaData.getColumnCount();
-        DataRecord result = new DataRecord(newPosition(resultSet), columnCount);
-        result.setType(IngestDataChangeType.INSERT);
-        result.setTableName(dumperConfig.getLogicTableName());
+        DataRecord result = new DataRecord(IngestDataChangeType.INSERT, dumperConfig.getLogicTableName(), newPosition(resultSet), columnCount);
         List<String> insertColumnNames = Optional.ofNullable(dumperConfig.getInsertColumnNames()).orElse(Collections.emptyList());
         ShardingSpherePreconditions.checkState(insertColumnNames.isEmpty() || insertColumnNames.size() == resultSetMetaData.getColumnCount(),
                 () -> new PipelineInvalidParameterException("Insert colum names count not equals ResultSet column count"));
diff --git a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/prepare/InventoryRecordsCountCalculator.java b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/prepare/InventoryRecordsCountCalculator.java
index facdda8e9af..f1e3496d203 100644
--- a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/prepare/InventoryRecordsCountCalculator.java
+++ b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/prepare/InventoryRecordsCountCalculator.java
@@ -17,6 +17,8 @@
 
 package org.apache.shardingsphere.data.pipeline.core.prepare;
 
+import lombok.AccessLevel;
+import lombok.NoArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
 import org.apache.shardingsphere.data.pipeline.api.config.ingest.InventoryDumperConfiguration;
 import org.apache.shardingsphere.data.pipeline.api.datasource.PipelineDataSourceWrapper;
@@ -38,6 +40,7 @@ import java.util.Optional;
 /**
  * Inventory records count calculator.
  */
+@NoArgsConstructor(access = AccessLevel.PRIVATE)
 @Slf4j
 public final class InventoryRecordsCountCalculator {
     
diff --git a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/prepare/InventoryTaskSplitter.java b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/prepare/InventoryTaskSplitter.java
index 86b781f41ab..c30d6f30e2b 100644
--- a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/prepare/InventoryTaskSplitter.java
+++ b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/prepare/InventoryTaskSplitter.java
@@ -19,6 +19,7 @@ package org.apache.shardingsphere.data.pipeline.core.prepare;
 
 import lombok.RequiredArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.Range;
 import org.apache.shardingsphere.data.pipeline.api.config.ImporterConfiguration;
 import org.apache.shardingsphere.data.pipeline.api.config.ingest.InventoryDumperConfiguration;
 import org.apache.shardingsphere.data.pipeline.api.config.process.PipelineReadConfiguration;
@@ -43,15 +44,17 @@ import org.apache.shardingsphere.data.pipeline.core.ingest.dumper.InventoryDumpe
 import org.apache.shardingsphere.data.pipeline.core.metadata.loader.PipelineTableMetaDataUtils;
 import org.apache.shardingsphere.data.pipeline.core.task.InventoryTask;
 import org.apache.shardingsphere.data.pipeline.core.task.PipelineTaskUtils;
+import org.apache.shardingsphere.data.pipeline.core.util.IntervalToRangeIterator;
 import org.apache.shardingsphere.data.pipeline.core.util.PipelineJdbcUtils;
 import org.apache.shardingsphere.data.pipeline.spi.ratelimit.JobRateLimitAlgorithm;
 import org.apache.shardingsphere.data.pipeline.spi.sqlbuilder.PipelineSQLBuilder;
 import org.apache.shardingsphere.data.pipeline.util.spi.PipelineTypedSPILoader;
 
+import javax.sql.DataSource;
 import java.sql.Connection;
-import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Statement;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedList;
@@ -161,7 +164,8 @@ public final class InventoryTaskSplitter {
                 return result;
             }
         }
-        jobItemContext.updateInventoryRecordsCount(InventoryRecordsCountCalculator.getTableRecordsCount(dumperConfig, dataSource));
+        long tableRecordsCount = InventoryRecordsCountCalculator.getTableRecordsCount(dumperConfig, dataSource);
+        jobItemContext.updateInventoryRecordsCount(tableRecordsCount);
         if (!dumperConfig.hasUniqueKey()) {
             return Collections.singletonList(new NoUniqueKeyPosition());
         }
@@ -169,7 +173,7 @@ public final class InventoryTaskSplitter {
         if (1 == uniqueKeyColumns.size()) {
             int firstColumnDataType = uniqueKeyColumns.get(0).getDataType();
             if (PipelineJdbcUtils.isIntegerColumn(firstColumnDataType)) {
-                return getPositionByIntegerUniqueKeyRange(dumperConfig, jobItemContext, dataSource);
+                return getPositionByIntegerUniqueKeyRange(dumperConfig, tableRecordsCount, jobItemContext, dataSource);
             }
             if (PipelineJdbcUtils.isStringColumn(firstColumnDataType)) {
                 // TODO Support string unique key table splitting. Ascii characters ordering are different in different versions of databases.
@@ -179,40 +183,36 @@ public final class InventoryTaskSplitter {
         return Collections.singletonList(new UnsupportedKeyPosition());
     }
     
-    private Collection<IngestPosition> getPositionByIntegerUniqueKeyRange(final InventoryDumperConfiguration dumperConfig, final InventoryIncrementalJobItemContext jobItemContext,
-                                                                          final PipelineDataSourceWrapper dataSource) {
+    private Collection<IngestPosition> getPositionByIntegerUniqueKeyRange(final InventoryDumperConfiguration dumperConfig, final long tableRecordsCount,
+                                                                          final InventoryIncrementalJobItemContext jobItemContext, final PipelineDataSourceWrapper dataSource) {
+        if (0 == tableRecordsCount) {
+            return Collections.singletonList(new IntegerPrimaryKeyPosition(0, 0));
+        }
         Collection<IngestPosition> result = new LinkedList<>();
-        String uniqueKey = dumperConfig.getUniqueKeyColumns().get(0).getName();
-        String sql = PipelineTypedSPILoader.getDatabaseTypedService(PipelineSQLBuilder.class, dataSource.getDatabaseType().getType())
-                .buildSplitByPrimaryKeyRangeSQL(dumperConfig.getSchemaName(new LogicTableName(dumperConfig.getLogicTableName())), dumperConfig.getActualTableName(), uniqueKey);
+        Range<Long> uniqueKeyValuesRange = getUniqueKeyValuesRange(jobItemContext, dataSource, dumperConfig);
         int shardingSize = jobItemContext.getJobProcessContext().getPipelineProcessConfig().getRead().getShardingSize();
+        long splitCount = tableRecordsCount / shardingSize + (tableRecordsCount % shardingSize > 0 ? 1 : 0);
+        long interval = (uniqueKeyValuesRange.getMaximum() - uniqueKeyValuesRange.getMinimum()) / splitCount;
+        IntervalToRangeIterator rangeIterator = new IntervalToRangeIterator(uniqueKeyValuesRange.getMinimum(), uniqueKeyValuesRange.getMaximum(), interval);
+        while (rangeIterator.hasNext()) {
+            Range<Long> range = rangeIterator.next();
+            result.add(new IntegerPrimaryKeyPosition(range.getMinimum(), range.getMaximum()));
+        }
+        return result;
+    }
+    
+    private Range<Long> getUniqueKeyValuesRange(final InventoryIncrementalJobItemContext jobItemContext, final DataSource dataSource, final InventoryDumperConfiguration dumperConfig) {
+        String uniqueKey = dumperConfig.getUniqueKeyColumns().get(0).getName();
+        String sql = PipelineTypedSPILoader.getDatabaseTypedService(PipelineSQLBuilder.class, jobItemContext.getJobConfig().getSourceDatabaseType())
+                .buildUniqueKeyMinMaxValuesSQL(dumperConfig.getSchemaName(new LogicTableName(dumperConfig.getLogicTableName())), dumperConfig.getActualTableName(), uniqueKey);
         try (
                 Connection connection = dataSource.getConnection();
-                PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
-            // TODO query minimum value less than 0
-            long beginId = 0;
-            for (int i = 0; i < Integer.MAX_VALUE; i++) {
-                preparedStatement.setLong(1, beginId);
-                preparedStatement.setLong(2, shardingSize);
-                try (ResultSet resultSet = preparedStatement.executeQuery()) {
-                    if (!resultSet.next()) {
-                        break;
-                    }
-                    long endId = resultSet.getLong(1);
-                    if (0 == endId) {
-                        break;
-                    }
-                    result.add(new IntegerPrimaryKeyPosition(beginId, endId));
-                    beginId = endId + 1;
-                }
-            }
-            // fix empty table missing inventory task
-            if (result.isEmpty()) {
-                result.add(new IntegerPrimaryKeyPosition(0, 0));
-            }
+                Statement statement = connection.createStatement();
+                ResultSet resultSet = statement.executeQuery(sql)) {
+            resultSet.next();
+            return Range.between(resultSet.getLong(1), resultSet.getLong(2));
         } catch (final SQLException ex) {
             throw new SplitPipelineJobByUniqueKeyException(dumperConfig.getActualTableName(), uniqueKey, ex);
         }
-        return result;
     }
 }
diff --git a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/AbstractPipelineSQLBuilder.java b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/AbstractPipelineSQLBuilder.java
index 6494932f763..443655123ee 100644
--- a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/AbstractPipelineSQLBuilder.java
+++ b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/AbstractPipelineSQLBuilder.java
@@ -190,6 +190,12 @@ public abstract class AbstractPipelineSQLBuilder implements PipelineSQLBuilder {
         return String.format("SELECT COUNT(*) FROM %s", getQualifiedTableName(schemaName, tableName));
     }
     
+    @Override
+    public String buildUniqueKeyMinMaxValuesSQL(final String schemaName, final String tableName, final String uniqueKey) {
+        String quotedUniqueKey = quote(uniqueKey);
+        return String.format("SELECT MIN(%s), MAX(%s) FROM %s", quotedUniqueKey, quotedUniqueKey, getQualifiedTableName(schemaName, tableName));
+    }
+    
     @Override
     public String buildQueryAllOrderingSQL(final String schemaName, final String tableName, final List<String> columnNames, final String uniqueKey, final boolean firstQuery) {
         String qualifiedTableName = getQualifiedTableName(schemaName, tableName);
@@ -203,11 +209,4 @@ public abstract class AbstractPipelineSQLBuilder implements PipelineSQLBuilder {
     public String buildCheckEmptySQL(final String schemaName, final String tableName) {
         return String.format("SELECT * FROM %s LIMIT 1", getQualifiedTableName(schemaName, tableName));
     }
-    
-    @Override
-    public String buildSplitByPrimaryKeyRangeSQL(final String schemaName, final String tableName, final String uniqueKey) {
-        String quotedUniqueKey = quote(uniqueKey);
-        return String.format("SELECT MAX(%s),COUNT(1) FROM (SELECT %s FROM %s WHERE %s>=? ORDER BY %s LIMIT ?) t",
-                quotedUniqueKey, quotedUniqueKey, getQualifiedTableName(schemaName, tableName), quotedUniqueKey, quotedUniqueKey);
-    }
 }
diff --git a/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/util/IntervalToRangeIterator.java b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/util/IntervalToRangeIterator.java
new file mode 100644
index 00000000000..2ac010aaaa7
--- /dev/null
+++ b/kernel/data-pipeline/core/src/main/java/org/apache/shardingsphere/data/pipeline/core/util/IntervalToRangeIterator.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.data.pipeline.core.util;
+
+import org.apache.commons.lang3.Range;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Interval to range iterator.
+ * <p>
+ * It's not thread-safe.
+ * </p>
+ */
+public final class IntervalToRangeIterator implements Iterator<Range<Long>> {
+    
+    private final long maximum;
+    
+    private final long interval;
+    
+    private long current;
+    
+    public IntervalToRangeIterator(final long minimum, final long maximum, final long interval) {
+        if (minimum > maximum) {
+            throw new IllegalArgumentException("minimum greater than maximum");
+        }
+        if (interval < 0) {
+            throw new IllegalArgumentException("interval is less than zero");
+        }
+        this.maximum = maximum;
+        this.interval = interval;
+        this.current = minimum;
+    }
+    
+    @Override
+    public boolean hasNext() {
+        return current <= maximum;
+    }
+    
+    @Override
+    public Range<Long> next() {
+        if (!hasNext()) {
+            throw new NoSuchElementException();
+        }
+        long upperLimit = Math.min(maximum, current + interval);
+        Range<Long> result = Range.between(current, upperLimit);
+        current = upperLimit + 1;
+        return result;
+    }
+}
diff --git a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/importer/DataRecordMergerTest.java b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/importer/DataRecordMergerTest.java
index 93f6cc62a77..75bb3b1657e 100644
--- a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/importer/DataRecordMergerTest.java
+++ b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/importer/DataRecordMergerTest.java
@@ -165,9 +165,7 @@ class DataRecordMergerTest {
     }
     
     private DataRecord mockInsertDataRecord(final String tableName, final int id, final int userId, final int totalPrice) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 3);
-        result.setType(IngestDataChangeType.INSERT);
-        result.setTableName(tableName);
+        DataRecord result = new DataRecord(IngestDataChangeType.INSERT, tableName, new PlaceholderPosition(), 3);
         result.addColumn(new Column("id", id, true, true));
         result.addColumn(new Column("user_id", userId, true, false));
         result.addColumn(new Column("total_price", totalPrice, true, false));
@@ -187,9 +185,7 @@ class DataRecordMergerTest {
     }
     
     private DataRecord mockUpdateDataRecord(final String tableName, final Integer oldId, final int id, final int userId, final int totalPrice) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 3);
-        result.setType(IngestDataChangeType.UPDATE);
-        result.setTableName(tableName);
+        DataRecord result = new DataRecord(IngestDataChangeType.UPDATE, tableName, new PlaceholderPosition(), 3);
         result.addColumn(new Column("id", oldId, id, null != oldId, true));
         result.addColumn(new Column("user_id", userId, true, false));
         result.addColumn(new Column("total_price", totalPrice, true, false));
@@ -201,9 +197,7 @@ class DataRecordMergerTest {
     }
     
     private DataRecord mockDeleteDataRecord(final String tableName, final int id, final int userId, final int totalPrice) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 3);
-        result.setType(IngestDataChangeType.DELETE);
-        result.setTableName(tableName);
+        DataRecord result = new DataRecord(IngestDataChangeType.DELETE, tableName, new PlaceholderPosition(), 3);
         result.addColumn(new Column("id", id, null, true, true));
         result.addColumn(new Column("user_id", userId, null, true, false));
         result.addColumn(new Column("total_price", totalPrice, null, true, false));
diff --git a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/ingest/channel/memory/MultiplexMemoryPipelineChannelTest.java b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/ingest/channel/memory/MultiplexMemoryPipelineChannelTest.java
index 144ef6d9808..35cefe84c8a 100644
--- a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/ingest/channel/memory/MultiplexMemoryPipelineChannelTest.java
+++ b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/ingest/channel/memory/MultiplexMemoryPipelineChannelTest.java
@@ -27,6 +27,7 @@ import org.apache.shardingsphere.data.pipeline.api.ingest.record.DataRecord;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.FinishedRecord;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.PlaceholderRecord;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.Record;
+import org.apache.shardingsphere.data.pipeline.core.ingest.IngestDataChangeType;
 import org.junit.jupiter.api.Test;
 
 import java.security.SecureRandom;
@@ -97,7 +98,7 @@ class MultiplexMemoryPipelineChannelTest {
     private Record[] mockRecords() {
         Record[] result = new Record[100];
         for (int i = 1; i <= result.length; i++) {
-            result[i - 1] = random.nextBoolean() ? new DataRecord(new IntPosition(i), 0) : new PlaceholderRecord(new IntPosition(i));
+            result[i - 1] = random.nextBoolean() ? new DataRecord(IngestDataChangeType.INSERT, "t1", new IntPosition(i), 0) : new PlaceholderRecord(new IntPosition(i));
         }
         return result;
     }
diff --git a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/ingest/record/DataRecordTest.java b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/ingest/record/DataRecordTest.java
index 2d4ca0075d3..96345e69f47 100644
--- a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/ingest/record/DataRecordTest.java
+++ b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/ingest/record/DataRecordTest.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.data.pipeline.core.ingest.record;
 import org.apache.shardingsphere.data.pipeline.api.ingest.position.PlaceholderPosition;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.Column;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.DataRecord;
+import org.apache.shardingsphere.data.pipeline.core.ingest.IngestDataChangeType;
 import org.junit.jupiter.api.Test;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -33,12 +34,10 @@ class DataRecordTest {
     
     @Test
     void assertKeyEqual() {
-        beforeDataRecord = new DataRecord(new PlaceholderPosition(), 2);
-        beforeDataRecord.setTableName("t1");
+        beforeDataRecord = new DataRecord(IngestDataChangeType.UPDATE, "t1", new PlaceholderPosition(), 2);
         beforeDataRecord.addColumn(new Column("id", 1, true, true));
         beforeDataRecord.addColumn(new Column("name", "1", true, false));
-        afterDataRecord = new DataRecord(new PlaceholderPosition(), 2);
-        afterDataRecord.setTableName("t1");
+        afterDataRecord = new DataRecord(IngestDataChangeType.UPDATE, "t1", new PlaceholderPosition(), 2);
         afterDataRecord.addColumn(new Column("id", 1, true, true));
         afterDataRecord.addColumn(new Column("name", "2", true, false));
         assertThat(beforeDataRecord.getKey(), is(afterDataRecord.getKey()));
@@ -46,12 +45,10 @@ class DataRecordTest {
     
     @Test
     void assertOldKeyEqual() {
-        beforeDataRecord = new DataRecord(new PlaceholderPosition(), 2);
-        beforeDataRecord.setTableName("t1");
+        beforeDataRecord = new DataRecord(IngestDataChangeType.UPDATE, "t1", new PlaceholderPosition(), 2);
         beforeDataRecord.addColumn(new Column("id", 1, true, true));
         beforeDataRecord.addColumn(new Column("name", "1", true, false));
-        afterDataRecord = new DataRecord(new PlaceholderPosition(), 2);
-        afterDataRecord.setTableName("t1");
+        afterDataRecord = new DataRecord(IngestDataChangeType.UPDATE, "t1", new PlaceholderPosition(), 2);
         afterDataRecord.addColumn(new Column("id", 1, 2, true, true));
         afterDataRecord.addColumn(new Column("name", "2", true, false));
         assertThat(beforeDataRecord.getKey(), is(afterDataRecord.getOldKey()));
diff --git a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/record/RecordUtilsTest.java b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/record/RecordUtilsTest.java
index 0f5c00a80e9..ef9cdd7f2d9 100644
--- a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/record/RecordUtilsTest.java
+++ b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/record/RecordUtilsTest.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.data.pipeline.core.record;
 import org.apache.shardingsphere.data.pipeline.api.ingest.position.PlaceholderPosition;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.Column;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.DataRecord;
+import org.apache.shardingsphere.data.pipeline.core.ingest.IngestDataChangeType;
 import org.junit.jupiter.api.Test;
 
 import java.util.Arrays;
@@ -57,8 +58,7 @@ class RecordUtilsTest {
     }
     
     private DataRecord mockDataRecord(final String tableName) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 4);
-        result.setTableName(tableName);
+        DataRecord result = new DataRecord(IngestDataChangeType.INSERT, tableName, new PlaceholderPosition(), 4);
         result.addColumn(new Column("id", "", false, true));
         result.addColumn(new Column("sc", "", false, true));
         result.addColumn(new Column("c1", "", true, false));
diff --git a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/FixturePipelineSQLBuilder.java b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/FixturePipelineSQLBuilder.java
index 47eaa986d4d..1a67f178f1b 100644
--- a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/FixturePipelineSQLBuilder.java
+++ b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/FixturePipelineSQLBuilder.java
@@ -79,18 +79,18 @@ public final class FixturePipelineSQLBuilder implements PipelineSQLBuilder {
     }
     
     @Override
-    public String buildQueryAllOrderingSQL(final String schemaName, final String tableName, final List<String> columnNames, final String uniqueKey, final boolean firstQuery) {
+    public String buildUniqueKeyMinMaxValuesSQL(final String schemaName, final String tableName, final String uniqueKey) {
         return "";
     }
     
     @Override
-    public String buildCheckEmptySQL(final String schemaName, final String tableName) {
-        return null;
+    public String buildQueryAllOrderingSQL(final String schemaName, final String tableName, final List<String> columnNames, final String uniqueKey, final boolean firstQuery) {
+        return "";
     }
     
     @Override
-    public String buildSplitByPrimaryKeyRangeSQL(final String schemaName, final String tableName, final String uniqueKey) {
-        return "";
+    public String buildCheckEmptySQL(final String schemaName, final String tableName) {
+        return null;
     }
     
     @Override
diff --git a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/PipelineSQLBuilderTest.java b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/PipelineSQLBuilderTest.java
index 7481a806933..af3ff93b167 100644
--- a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/PipelineSQLBuilderTest.java
+++ b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/sqlbuilder/PipelineSQLBuilderTest.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.data.pipeline.core.sqlbuilder;
 import org.apache.shardingsphere.data.pipeline.api.ingest.position.PlaceholderPosition;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.Column;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.DataRecord;
+import org.apache.shardingsphere.data.pipeline.core.ingest.IngestDataChangeType;
 import org.apache.shardingsphere.data.pipeline.core.record.RecordUtils;
 import org.apache.shardingsphere.data.pipeline.spi.sqlbuilder.PipelineSQLBuilder;
 import org.junit.jupiter.api.Test;
@@ -112,8 +113,7 @@ class PipelineSQLBuilderTest {
     }
     
     private DataRecord mockDataRecord(final String tableName) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 4);
-        result.setTableName(tableName);
+        DataRecord result = new DataRecord(IngestDataChangeType.INSERT, tableName, new PlaceholderPosition(), 4);
         result.addColumn(new Column("id", "", false, true));
         result.addColumn(new Column("sc", "", false, false));
         result.addColumn(new Column("c1", "", true, false));
@@ -137,8 +137,7 @@ class PipelineSQLBuilderTest {
     }
     
     private DataRecord mockDataRecordWithoutUniqueKey(final String tableName) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 4);
-        result.setTableName(tableName);
+        DataRecord result = new DataRecord(IngestDataChangeType.INSERT, tableName, new PlaceholderPosition(), 4);
         result.addColumn(new Column("id", "", false, false));
         result.addColumn(new Column("name", "", true, false));
         return result;
diff --git a/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/util/IntervalToRangeIteratorTest.java b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/util/IntervalToRangeIteratorTest.java
new file mode 100644
index 00000000000..ab8fe008bde
--- /dev/null
+++ b/kernel/data-pipeline/core/src/test/java/org/apache/shardingsphere/data/pipeline/core/util/IntervalToRangeIteratorTest.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.data.pipeline.core.util;
+
+import org.apache.commons.lang3.Range;
+import org.junit.jupiter.api.Test;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.NoSuchElementException;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+class IntervalToRangeIteratorTest {
+    
+    @Test
+    void assertMinimumGreaterThanMaximum() {
+        assertThrows(IllegalArgumentException.class, () -> new IntervalToRangeIterator(200L, 100L, 10L));
+    }
+    
+    @Test
+    void assertIntervalLessThanZero() {
+        assertThrows(IllegalArgumentException.class, () -> new IntervalToRangeIterator(100L, 200L, -10L));
+    }
+    
+    @Test
+    void assertInvalidNext() {
+        IntervalToRangeIterator iterator = new IntervalToRangeIterator(200L, 200L, 0L);
+        if (iterator.hasNext()) {
+            iterator.next();
+        }
+        assertThrows(NoSuchElementException.class, iterator::next);
+    }
+    
+    @Test
+    void assertSmallRangeCorrect() {
+        IntervalToRangeIterator iterator = new IntervalToRangeIterator(200L, 200L, 0L);
+        List<Range<Long>> actual = new LinkedList<>();
+        while (iterator.hasNext()) {
+            actual.add(iterator.next());
+        }
+        assertThat(actual.size(), is(1));
+        assertThat(actual.get(0).getMinimum(), is(200L));
+        assertThat(actual.get(0).getMaximum(), is(200L));
+    }
+    
+    @Test
+    void assertLargeRangeCorrect() {
+        IntervalToRangeIterator iterator = new IntervalToRangeIterator(200L, 400L, 100L);
+        List<Range<Long>> actual = new LinkedList<>();
+        while (iterator.hasNext()) {
+            actual.add(iterator.next());
+        }
+        assertThat(actual.size(), is(2));
+        assertThat(actual.get(0).getMinimum(), is(200L));
+        assertThat(actual.get(0).getMaximum(), is(300L));
+        assertThat(actual.get(1).getMinimum(), is(301L));
+        assertThat(actual.get(1).getMaximum(), is(400L));
+    }
+}
diff --git a/kernel/data-pipeline/dialect/mysql/src/main/java/org/apache/shardingsphere/data/pipeline/mysql/ingest/MySQLIncrementalDumper.java b/kernel/data-pipeline/dialect/mysql/src/main/java/org/apache/shardingsphere/data/pipeline/mysql/ingest/MySQLIncrementalDumper.java
index 9a5ba016e04..93014201fa7 100644
--- a/kernel/data-pipeline/dialect/mysql/src/main/java/org/apache/shardingsphere/data/pipeline/mysql/ingest/MySQLIncrementalDumper.java
+++ b/kernel/data-pipeline/dialect/mysql/src/main/java/org/apache/shardingsphere/data/pipeline/mysql/ingest/MySQLIncrementalDumper.java
@@ -161,8 +161,7 @@ public final class MySQLIncrementalDumper extends AbstractLifecycleExecutor impl
         Set<ColumnName> columnNameSet = dumperConfig.getColumnNameSet(event.getTableName()).orElse(null);
         List<DataRecord> result = new LinkedList<>();
         for (Serializable[] each : event.getAfterRows()) {
-            DataRecord dataRecord = createDataRecord(event, each.length);
-            dataRecord.setType(IngestDataChangeType.INSERT);
+            DataRecord dataRecord = createDataRecord(IngestDataChangeType.INSERT, event, each.length);
             for (int i = 0; i < each.length; i++) {
                 PipelineColumnMetaData columnMetaData = tableMetaData.getColumnMetaData(i + 1);
                 if (isColumnUnneeded(columnNameSet, columnMetaData.getName())) {
@@ -185,8 +184,7 @@ public final class MySQLIncrementalDumper extends AbstractLifecycleExecutor impl
         for (int i = 0; i < event.getBeforeRows().size(); i++) {
             Serializable[] beforeValues = event.getBeforeRows().get(i);
             Serializable[] afterValues = event.getAfterRows().get(i);
-            DataRecord dataRecord = createDataRecord(event, beforeValues.length);
-            dataRecord.setType(IngestDataChangeType.UPDATE);
+            DataRecord dataRecord = createDataRecord(IngestDataChangeType.UPDATE, event, beforeValues.length);
             for (int j = 0; j < beforeValues.length; j++) {
                 Serializable oldValue = beforeValues[j];
                 Serializable newValue = afterValues[j];
@@ -208,8 +206,7 @@ public final class MySQLIncrementalDumper extends AbstractLifecycleExecutor impl
         Set<ColumnName> columnNameSet = dumperConfig.getColumnNameSet(event.getTableName()).orElse(null);
         List<DataRecord> result = new LinkedList<>();
         for (Serializable[] each : event.getBeforeRows()) {
-            DataRecord dataRecord = createDataRecord(event, each.length);
-            dataRecord.setType(IngestDataChangeType.DELETE);
+            DataRecord dataRecord = createDataRecord(IngestDataChangeType.DELETE, event, each.length);
             for (int i = 0, length = each.length; i < length; i++) {
                 PipelineColumnMetaData columnMetaData = tableMetaData.getColumnMetaData(i + 1);
                 if (isColumnUnneeded(columnNameSet, columnMetaData.getName())) {
@@ -233,9 +230,10 @@ public final class MySQLIncrementalDumper extends AbstractLifecycleExecutor impl
         return dataTypeHandler.isPresent() ? dataTypeHandler.get().handle(value) : value;
     }
     
-    private DataRecord createDataRecord(final AbstractRowsEvent rowsEvent, final int columnCount) {
-        DataRecord result = new DataRecord(new BinlogPosition(rowsEvent.getFileName(), rowsEvent.getPosition(), rowsEvent.getServerId()), columnCount);
-        result.setTableName(dumperConfig.getLogicTableName(rowsEvent.getTableName()).getOriginal());
+    private DataRecord createDataRecord(final String type, final AbstractRowsEvent rowsEvent, final int columnCount) {
+        String tableName = dumperConfig.getLogicTableName(rowsEvent.getTableName()).getOriginal();
+        IngestPosition position = new BinlogPosition(rowsEvent.getFileName(), rowsEvent.getPosition(), rowsEvent.getServerId());
+        DataRecord result = new DataRecord(type, tableName, position, columnCount);
         result.setCommitTime(rowsEvent.getTimestamp() * 1000);
         return result;
     }
diff --git a/kernel/data-pipeline/dialect/mysql/src/test/java/org/apache/shardingsphere/data/pipeline/mysql/sqlbuilder/MySQLPipelineSQLBuilderTest.java b/kernel/data-pipeline/dialect/mysql/src/test/java/org/apache/shardingsphere/data/pipeline/mysql/sqlbuilder/MySQLPipelineSQLBuilderTest.java
index 9acb3db3303..818fdc41e9a 100644
--- a/kernel/data-pipeline/dialect/mysql/src/test/java/org/apache/shardingsphere/data/pipeline/mysql/sqlbuilder/MySQLPipelineSQLBuilderTest.java
+++ b/kernel/data-pipeline/dialect/mysql/src/test/java/org/apache/shardingsphere/data/pipeline/mysql/sqlbuilder/MySQLPipelineSQLBuilderTest.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.data.pipeline.mysql.sqlbuilder;
 import org.apache.shardingsphere.data.pipeline.api.ingest.position.PlaceholderPosition;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.Column;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.DataRecord;
+import org.apache.shardingsphere.data.pipeline.core.ingest.IngestDataChangeType;
 import org.junit.jupiter.api.Test;
 
 import java.util.Optional;
@@ -52,8 +53,7 @@ class MySQLPipelineSQLBuilderTest {
     }
     
     private DataRecord mockDataRecord(final String tableName) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 4);
-        result.setTableName(tableName);
+        DataRecord result = new DataRecord(IngestDataChangeType.INSERT, tableName, new PlaceholderPosition(), 4);
         result.addColumn(new Column("id", "", false, true));
         result.addColumn(new Column("sc", "", false, false));
         result.addColumn(new Column("c1", "", true, false));
diff --git a/kernel/data-pipeline/dialect/opengauss/src/test/java/org/apache/shardingsphere/data/pipeline/opengauss/sqlbuilder/OpenGaussPipelineSQLBuilderTest.java b/kernel/data-pipeline/dialect/opengauss/src/test/java/org/apache/shardingsphere/data/pipeline/opengauss/sqlbuilder/OpenGaussPipelineSQLBuilderTest.java
index a134cf6d28f..4bdfccc27bf 100644
--- a/kernel/data-pipeline/dialect/opengauss/src/test/java/org/apache/shardingsphere/data/pipeline/opengauss/sqlbuilder/OpenGaussPipelineSQLBuilderTest.java
+++ b/kernel/data-pipeline/dialect/opengauss/src/test/java/org/apache/shardingsphere/data/pipeline/opengauss/sqlbuilder/OpenGaussPipelineSQLBuilderTest.java
@@ -20,6 +20,7 @@ package org.apache.shardingsphere.data.pipeline.opengauss.sqlbuilder;
 import org.apache.shardingsphere.data.pipeline.api.ingest.position.PlaceholderPosition;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.Column;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.DataRecord;
+import org.apache.shardingsphere.data.pipeline.core.ingest.IngestDataChangeType;
 import org.junit.jupiter.api.Test;
 
 import java.util.Optional;
@@ -39,8 +40,7 @@ class OpenGaussPipelineSQLBuilderTest {
     }
     
     private DataRecord mockDataRecord(final String tableName) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 4);
-        result.setTableName(tableName);
+        DataRecord result = new DataRecord(IngestDataChangeType.INSERT, tableName, new PlaceholderPosition(), 4);
         result.addColumn(new Column("id", "", false, true));
         result.addColumn(new Column("c0", "", false, false));
         result.addColumn(new Column("c1", "", true, false));
diff --git a/kernel/data-pipeline/dialect/postgresql/src/main/java/org/apache/shardingsphere/data/pipeline/postgresql/ingest/wal/WALEventConverter.java b/kernel/data-pipeline/dialect/postgresql/src/main/java/org/apache/shardingsphere/data/pipeline/postgresql/ingest/wal/WALEventConverter.java
index 00cb9e6da3c..1968de02f07 100644
--- a/kernel/data-pipeline/dialect/postgresql/src/main/java/org/apache/shardingsphere/data/pipeline/postgresql/ingest/wal/WALEventConverter.java
+++ b/kernel/data-pipeline/dialect/postgresql/src/main/java/org/apache/shardingsphere/data/pipeline/postgresql/ingest/wal/WALEventConverter.java
@@ -96,15 +96,13 @@ public final class WALEventConverter {
     }
     
     private DataRecord handleWriteRowEvent(final WriteRowEvent writeRowEvent, final PipelineTableMetaData tableMetaData) {
-        DataRecord result = createDataRecord(writeRowEvent, writeRowEvent.getAfterRow().size());
-        result.setType(IngestDataChangeType.INSERT);
+        DataRecord result = createDataRecord(IngestDataChangeType.INSERT, writeRowEvent, writeRowEvent.getAfterRow().size());
         putColumnsIntoDataRecord(result, tableMetaData, writeRowEvent.getTableName(), writeRowEvent.getAfterRow());
         return result;
     }
     
     private DataRecord handleUpdateRowEvent(final UpdateRowEvent updateRowEvent, final PipelineTableMetaData tableMetaData) {
-        DataRecord result = createDataRecord(updateRowEvent, updateRowEvent.getAfterRow().size());
-        result.setType(IngestDataChangeType.UPDATE);
+        DataRecord result = createDataRecord(IngestDataChangeType.UPDATE, updateRowEvent, updateRowEvent.getAfterRow().size());
         String actualTableName = updateRowEvent.getTableName();
         putColumnsIntoDataRecord(result, tableMetaData, actualTableName, updateRowEvent.getAfterRow());
         return result;
@@ -112,8 +110,7 @@ public final class WALEventConverter {
     
     private DataRecord handleDeleteRowEvent(final DeleteRowEvent event, final PipelineTableMetaData tableMetaData) {
         // TODO completion columns
-        DataRecord result = createDataRecord(event, event.getPrimaryKeys().size());
-        result.setType(IngestDataChangeType.DELETE);
+        DataRecord result = createDataRecord(IngestDataChangeType.DELETE, event, event.getPrimaryKeys().size());
         // TODO Unique key may be a column within unique index
         List<String> primaryKeyColumns = tableMetaData.getPrimaryKeyColumns();
         for (int i = 0; i < event.getPrimaryKeys().size(); i++) {
@@ -122,9 +119,9 @@ public final class WALEventConverter {
         return result;
     }
     
-    private DataRecord createDataRecord(final AbstractRowEvent rowsEvent, final int columnCount) {
-        DataRecord result = new DataRecord(new WALPosition(rowsEvent.getLogSequenceNumber()), columnCount);
-        result.setTableName(dumperConfig.getLogicTableName(rowsEvent.getTableName()).getOriginal());
+    private DataRecord createDataRecord(final String type, final AbstractRowEvent rowsEvent, final int columnCount) {
+        String tableName = dumperConfig.getLogicTableName(rowsEvent.getTableName()).getOriginal();
+        DataRecord result = new DataRecord(type, tableName, new WALPosition(rowsEvent.getLogSequenceNumber()), columnCount);
         result.setCsn(rowsEvent.getCsn());
         return result;
     }
diff --git a/kernel/data-pipeline/dialect/postgresql/src/test/java/org/apache/shardingsphere/data/pipeline/postgresql/sqlbuilder/PostgreSQLPipelineSQLBuilderTest.java b/kernel/data-pipeline/dialect/postgresql/src/test/java/org/apache/shardingsphere/data/pipeline/postgresql/sqlbuilder/PostgreSQLPipelineSQLBuilderTest.java
index 1ea59d6693e..21f19f05742 100644
--- a/kernel/data-pipeline/dialect/postgresql/src/test/java/org/apache/shardingsphere/data/pipeline/postgresql/sqlbuilder/PostgreSQLPipelineSQLBuilderTest.java
+++ b/kernel/data-pipeline/dialect/postgresql/src/test/java/org/apache/shardingsphere/data/pipeline/postgresql/sqlbuilder/PostgreSQLPipelineSQLBuilderTest.java
@@ -19,6 +19,7 @@ package org.apache.shardingsphere.data.pipeline.postgresql.sqlbuilder;
 
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.Column;
 import org.apache.shardingsphere.data.pipeline.api.ingest.record.DataRecord;
+import org.apache.shardingsphere.data.pipeline.core.ingest.IngestDataChangeType;
 import org.apache.shardingsphere.data.pipeline.postgresql.ingest.wal.WALPosition;
 import org.apache.shardingsphere.data.pipeline.postgresql.ingest.wal.decode.PostgreSQLLogSequenceNumber;
 import org.junit.jupiter.api.Test;
@@ -42,8 +43,7 @@ class PostgreSQLPipelineSQLBuilderTest {
     }
     
     private DataRecord mockDataRecord() {
-        DataRecord result = new DataRecord(new WALPosition(new PostgreSQLLogSequenceNumber(LogSequenceNumber.valueOf(100L))), 2);
-        result.setTableName("t_order");
+        DataRecord result = new DataRecord(IngestDataChangeType.INSERT, "t_order", new WALPosition(new PostgreSQLLogSequenceNumber(LogSequenceNumber.valueOf(100L))), 2);
         result.addColumn(new Column("order_id", 1, true, true));
         result.addColumn(new Column("user_id", 2, true, false));
         result.addColumn(new Column("status", "ok", true, false));
diff --git a/kernel/data-pipeline/scenario/migration/src/main/java/org/apache/shardingsphere/data/pipeline/scenario/migration/api/impl/MigrationJobAPI.java b/kernel/data-pipeline/scenario/migration/src/main/java/org/apache/shardingsphere/data/pipeline/scenario/migration/api/impl/MigrationJobAPI.java
index fc21c681542..c48848abf4c 100644
--- a/kernel/data-pipeline/scenario/migration/src/main/java/org/apache/shardingsphere/data/pipeline/scenario/migration/api/impl/MigrationJobAPI.java
+++ b/kernel/data-pipeline/scenario/migration/src/main/java/org/apache/shardingsphere/data/pipeline/scenario/migration/api/impl/MigrationJobAPI.java
@@ -415,7 +415,6 @@ public final class MigrationJobAPI extends AbstractInventoryIncrementalJobAPIImp
                 }
             }
         }
-        refreshTableMetadata(jobId, jobConfig.getTargetDatabaseName());
     }
     
     @Override
@@ -424,6 +423,8 @@ public final class MigrationJobAPI extends AbstractInventoryIncrementalJobAPIImp
         final long startTimeMillis = System.currentTimeMillis();
         dropCheckJobs(jobId);
         stop(jobId);
+        MigrationJobConfiguration jobConfig = getJobConfiguration(jobId);
+        refreshTableMetadata(jobId, jobConfig.getTargetDatabaseName());
         dropJob(jobId);
         log.info("Commit cost {} ms", System.currentTimeMillis() - startTimeMillis);
     }
diff --git a/kernel/data-pipeline/scenario/migration/src/main/java/org/apache/shardingsphere/data/pipeline/scenario/migration/prepare/MigrationJobPreparer.java b/kernel/data-pipeline/scenario/migration/src/main/java/org/apache/shardingsphere/data/pipeline/scenario/migration/prepare/MigrationJobPreparer.java
index 14404df2ba5..be3ff4883b6 100644
--- a/kernel/data-pipeline/scenario/migration/src/main/java/org/apache/shardingsphere/data/pipeline/scenario/migration/prepare/MigrationJobPreparer.java
+++ b/kernel/data-pipeline/scenario/migration/src/main/java/org/apache/shardingsphere/data/pipeline/scenario/migration/prepare/MigrationJobPreparer.java
@@ -166,7 +166,6 @@ public final class MigrationJobPreparer {
         ShardingSphereMetaData metaData = PipelineContextManager.getContext(PipelineJobIdUtils.parseContextKey(jobConfig.getJobId())).getContextManager().getMetaDataContexts().getMetaData();
         SQLParserEngine sqlParserEngine = PipelineJobPreparerUtils.getSQLParserEngine(metaData, jobConfig.getTargetDatabaseName());
         PipelineJobPreparerUtils.prepareTargetTables(targetDatabaseType, new PrepareTargetTablesParameter(createTableConfig, dataSourceManager, sqlParserEngine));
-        jobAPI.refreshTableMetadata(jobConfig.getJobId(), jobConfig.getTargetDatabaseName());
     }
     
     private void prepareIncremental(final MigrationJobItemContext jobItemContext) {
diff --git a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/NewMetaDataPersistService.java b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/NewMetaDataPersistService.java
index 373b3722943..dafa7bf4a68 100644
--- a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/NewMetaDataPersistService.java
+++ b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/NewMetaDataPersistService.java
@@ -27,11 +27,11 @@ import org.apache.shardingsphere.infra.datasource.props.DataSourcePropertiesCrea
 import org.apache.shardingsphere.infra.rule.ShardingSphereRule;
 import org.apache.shardingsphere.metadata.persist.data.ShardingSphereDataPersistService;
 import org.apache.shardingsphere.metadata.persist.service.config.database.NewDataSourcePersistService;
+import org.apache.shardingsphere.metadata.persist.service.config.database.NewDatabaseRulePersistService;
+import org.apache.shardingsphere.metadata.persist.service.config.global.NewGlobalRulePersistService;
+import org.apache.shardingsphere.metadata.persist.service.config.global.NewPropertiesPersistService;
 import org.apache.shardingsphere.metadata.persist.service.database.DatabaseMetaDataPersistService;
 import org.apache.shardingsphere.metadata.persist.service.version.MetaDataVersionPersistService;
-import org.apache.shardingsphere.metadata.persist.service.config.database.DatabaseRulePersistService;
-import org.apache.shardingsphere.metadata.persist.service.config.global.GlobalRulePersistService;
-import org.apache.shardingsphere.metadata.persist.service.config.global.PropertiesPersistService;
 import org.apache.shardingsphere.mode.spi.PersistRepository;
 
 import javax.sql.DataSource;
@@ -55,11 +55,11 @@ public final class NewMetaDataPersistService implements MetaDataBasedPersistServ
     
     private final DatabaseMetaDataPersistService databaseMetaDataService;
     
-    private final DatabaseRulePersistService databaseRulePersistService;
+    private final NewDatabaseRulePersistService databaseRulePersistService;
     
-    private final GlobalRulePersistService globalRuleService;
+    private final NewGlobalRulePersistService globalRuleService;
     
-    private final PropertiesPersistService propsService;
+    private final NewPropertiesPersistService propsService;
     
     private final MetaDataVersionPersistService metaDataVersionPersistService;
     
@@ -69,9 +69,9 @@ public final class NewMetaDataPersistService implements MetaDataBasedPersistServ
         this.repository = repository;
         dataSourceService = new NewDataSourcePersistService(repository);
         databaseMetaDataService = new DatabaseMetaDataPersistService(repository);
-        databaseRulePersistService = new DatabaseRulePersistService(repository);
-        globalRuleService = new GlobalRulePersistService(repository);
-        propsService = new PropertiesPersistService(repository);
+        databaseRulePersistService = new NewDatabaseRulePersistService(repository);
+        globalRuleService = new NewGlobalRulePersistService(repository);
+        propsService = new NewPropertiesPersistService(repository);
         metaDataVersionPersistService = new MetaDataVersionPersistService(repository);
         shardingSphereDataPersistService = new ShardingSphereDataPersistService(repository);
     }
diff --git a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/node/NewDatabaseMetaDataNode.java b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/node/NewDatabaseMetaDataNode.java
index 11601b52683..1317c48205e 100644
--- a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/node/NewDatabaseMetaDataNode.java
+++ b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/node/NewDatabaseMetaDataNode.java
@@ -41,103 +41,102 @@ public final class NewDatabaseMetaDataNode {
     private static final String VERSIONS = "versions";
     
     /**
-     * Get data Sources path.
+     * Get data Sources node.
      *
      * @param databaseName database name
-     * @return data sources path
+     * @return data sources node
      */
-    public static String getDataSourcesPath(final String databaseName) {
-        return String.join("/", getMetaDataNodePath(), DataSourceNodeConverter.getDataSourcesPath(databaseName));
+    public static String getDataSourcesNode(final String databaseName) {
+        return String.join("/", getMetaDataNodeNode(), DataSourceNodeConverter.getDataSourcesPath(databaseName));
     }
     
     /**
-     * Get data Source path.
+     * Get data Source node.
      *
      * @param databaseName database name
      * @param dataSourceName data source name
      * @param version version
-     * @return data source path
+     * @return data source node
      */
-    public static String getDataSourcePath(final String databaseName, final String dataSourceName, final String version) {
-        return String.join("/", getMetaDataNodePath(), DataSourceNodeConverter.getDataSourcePath(databaseName, dataSourceName, version));
+    public static String getDataSourceNode(final String databaseName, final String dataSourceName, final String version) {
+        return String.join("/", getMetaDataNodeNode(), DataSourceNodeConverter.getDataSourcePath(databaseName, dataSourceName, version));
     }
     
     /**
-     * Get data Source active version path.
+     * Get data Source active version node.
      *
      * @param databaseName database name
      * @param dataSourceName data source name
-     * @return data source active version path
+     * @return data source active version node
      */
-    public static String getDataSourceActiveVersionPath(final String databaseName, final String dataSourceName) {
-        return String.join("/", getMetaDataNodePath(), DataSourceNodeConverter.getActiveVersionPath(databaseName, dataSourceName));
+    public static String getDataSourceActiveVersionNode(final String databaseName, final String dataSourceName) {
+        return String.join("/", getMetaDataNodeNode(), DataSourceNodeConverter.getActiveVersionPath(databaseName, dataSourceName));
     }
     
     /**
-     * Get database rule active version path.
+     * Get database rule active version node.
      *
      * @param databaseName database name
      * @param ruleName rule name
      * @param key key
-     * @return database rule active version path
+     * @return database rule active version node
      */
-    public static String getDatabaseRuleActiveVersionPath(final String databaseName, final String ruleName, final String key) {
-        return String.join("/", getDatabaseRulePath(databaseName, ruleName), key, ACTIVE_VERSION);
+    public static String getDatabaseRuleActiveVersionNode(final String databaseName, final String ruleName, final String key) {
+        return String.join("/", getDatabaseRuleNode(databaseName, ruleName), key, ACTIVE_VERSION);
     }
     
     /**
-     * Get database rule versions path.
+     * Get database rule versions node.
      *
      * @param databaseName database name
      * @param ruleName rule name
      * @param key key
-     * @return database rule versions path
+     * @return database rule versions node
      */
-    public static String getDatabaseRuleVersionsPath(final String databaseName, final String ruleName, final String key) {
-        return String.join("/", getDatabaseRulePath(databaseName, ruleName), key, VERSIONS);
+    public static String getDatabaseRuleVersionsNode(final String databaseName, final String ruleName, final String key) {
+        return String.join("/", getDatabaseRuleNode(databaseName, ruleName), key, VERSIONS);
     }
     
     /**
-     * Get database rule version path.
+     * Get database rule version node.
      *
      * @param databaseName database name
      * @param ruleName rule name
      * @param key key
-     * @param nextVersion next version
+     * @param version version
      * @return database rule next version
      */
-    public static String getDatabaseRuleVersionPath(final String databaseName, final String ruleName, final String key, final String nextVersion) {
-        return String.join("/", getDatabaseRulePath(databaseName, ruleName), key, VERSIONS, nextVersion);
+    public static String getDatabaseRuleVersionNode(final String databaseName, final String ruleName, final String key, final String version) {
+        return String.join("/", getDatabaseRuleNode(databaseName, ruleName), key, VERSIONS, version);
+    }
+    
+    private static String getDatabaseRuleNode(final String databaseName, final String ruleName) {
+        return String.join("/", getRulesNode(databaseName), ruleName);
     }
     
     /**
-     * Get database rule path.
+     * Get database rules node.
      *
      * @param databaseName database name
-     * @param ruleName rule name
-     * @return database rule path
+     * @return database rules node
      */
-    public static String getDatabaseRulePath(final String databaseName, final String ruleName) {
-        return String.join("/", getRulesPath(databaseName), ruleName);
+    public static String getRulesNode(final String databaseName) {
+        return String.join("/", getMetaDataNodeNode(), databaseName, RULE_NODE);
     }
     
     /**
-     * Get database name by path.
+     * Get database name by node.
      *
      * @param path config path
      * @return database name
      */
-    public static Optional<String> getDatabaseNameByPath(final String path) {
-        Pattern pattern = Pattern.compile(getMetaDataNodePath() + "/([\\w\\-]+)?", Pattern.CASE_INSENSITIVE);
+    public static Optional<String> getDatabaseNameByNode(final String path) {
+        Pattern pattern = Pattern.compile(getMetaDataNodeNode() + "/([\\w\\-]+)?", Pattern.CASE_INSENSITIVE);
         Matcher matcher = pattern.matcher(path);
         return matcher.find() ? Optional.of(matcher.group(1)) : Optional.empty();
     }
     
-    private static String getRulesPath(final String databaseName) {
-        return String.join("/", getMetaDataNodePath(), databaseName, RULE_NODE);
-    }
-    
-    private static String getMetaDataNodePath() {
+    private static String getMetaDataNodeNode() {
         return String.join("/", "", ROOT_NODE);
     }
 }
diff --git a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/node/NewGlobalNode.java b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/node/NewGlobalNode.java
new file mode 100644
index 00000000000..9067d2252eb
--- /dev/null
+++ b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/node/NewGlobalNode.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.metadata.persist.node;
+
+import lombok.AccessLevel;
+import lombok.NoArgsConstructor;
+
+/**
+ * TODO Rename GlobalNode when metadata structure adjustment completed. #25485
+ * Global node.
+ */
+@NoArgsConstructor(access = AccessLevel.PRIVATE)
+public final class NewGlobalNode {
+    
+    private static final String RULE_NODE = "rules";
+    
+    private static final String PROPS_NODE = "props";
+    
+    private static final String ACTIVE_VERSION = "active_version";
+    
+    private static final String VERSIONS = "versions";
+    
+    /**
+     * Get global rule active version node.
+     *
+     * @param ruleName rule name
+     * @return global rule active version node
+     */
+    public static String getGlobalRuleActiveVersionNode(final String ruleName) {
+        return String.join("/", getGlobalRuleRootNode(), ruleName, ACTIVE_VERSION);
+    }
+    
+    /**
+     * Get global rule version node.
+     *
+     * @param ruleName rule name
+     * @param version version
+     * @return global rule version node
+     */
+    public static String getGlobalRuleVersionNode(final String ruleName, final String version) {
+        return String.join("/", getGlobalRuleRootNode(), ruleName, VERSIONS, version);
+    }
+    
+    /**
+     * Get global rule root node.
+     *
+     * @return global rule root node
+     */
+    public static String getGlobalRuleRootNode() {
+        return String.join("/", "", RULE_NODE);
+    }
+    
+    /**
+     * Get properties active version node.
+     *
+     * @return properties active version node
+     */
+    public static String getPropsActiveVersionNode() {
+        return String.join("/", getPropsRootNode(), ACTIVE_VERSION);
+    }
+    
+    /**
+     * Get properties version node.
+     *
+     * @param version version
+     * @return properties version node
+     */
+    public static String getPropsVersionNode(final String version) {
+        return String.join("/", getPropsRootNode(), VERSIONS, version);
+    }
+    
+    private static String getPropsRootNode() {
+        return String.join("/", "", PROPS_NODE);
+    }
+}
diff --git a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDataSourcePersistService.java b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDataSourcePersistService.java
index 479b697be74..ddc8d105b92 100644
--- a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDataSourcePersistService.java
+++ b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDataSourcePersistService.java
@@ -47,9 +47,9 @@ public final class NewDataSourcePersistService implements DatabaseBasedPersistSe
         for (Entry<String, DataSourceProperties> entry : dataSourceConfigs.entrySet()) {
             String activeVersion = getDatabaseActiveVersion(databaseName, entry.getKey());
             if (Strings.isNullOrEmpty(activeVersion)) {
-                repository.persist(NewDatabaseMetaDataNode.getDataSourceActiveVersionPath(databaseName, entry.getKey()), DEFAULT_VERSION);
+                repository.persist(NewDatabaseMetaDataNode.getDataSourceActiveVersionNode(databaseName, entry.getKey()), DEFAULT_VERSION);
             }
-            repository.persist(NewDatabaseMetaDataNode.getDataSourcePath(databaseName, entry.getKey(), DEFAULT_VERSION),
+            repository.persist(NewDatabaseMetaDataNode.getDataSourceNode(databaseName, entry.getKey(), DEFAULT_VERSION),
                     YamlEngine.marshal(new YamlDataSourceConfigurationSwapper().swapToMap(entry.getValue())));
         }
     }
@@ -57,7 +57,7 @@ public final class NewDataSourcePersistService implements DatabaseBasedPersistSe
     @Override
     public Map<String, DataSourceProperties> load(final String databaseName) {
         Map<String, DataSourceProperties> result = new LinkedHashMap<>();
-        for (String each : repository.getChildrenKeys(NewDatabaseMetaDataNode.getDataSourcesPath(databaseName))) {
+        for (String each : repository.getChildrenKeys(NewDatabaseMetaDataNode.getDataSourcesNode(databaseName))) {
             result.put(each, getDataSourceProps(databaseName, each));
         }
         return result;
@@ -70,12 +70,12 @@ public final class NewDataSourcePersistService implements DatabaseBasedPersistSe
     }
     
     private DataSourceProperties getDataSourceProps(final String databaseName, final String dataSourceName) {
-        String result = repository.getDirectly(NewDatabaseMetaDataNode.getDataSourcePath(databaseName, getDatabaseActiveVersion(databaseName, dataSourceName), dataSourceName));
+        String result = repository.getDirectly(NewDatabaseMetaDataNode.getDataSourceNode(databaseName, getDatabaseActiveVersion(databaseName, dataSourceName), dataSourceName));
         Preconditions.checkState(!Strings.isNullOrEmpty(result), "Not found `%s` data source config in `%s` database", dataSourceName, databaseName);
         return YamlEngine.unmarshal(result, DataSourceProperties.class);
     }
     
     private String getDatabaseActiveVersion(final String databaseName, final String dataSourceName) {
-        return repository.getDirectly(NewDatabaseMetaDataNode.getDataSourceActiveVersionPath(databaseName, dataSourceName));
+        return repository.getDirectly(NewDatabaseMetaDataNode.getDataSourceActiveVersionNode(databaseName, dataSourceName));
     }
 }
diff --git a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDatabaseRuleBasedPersistService.java b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDatabaseRuleBasedPersistService.java
index 086ec06f705..7e6ffce1e80 100644
--- a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDatabaseRuleBasedPersistService.java
+++ b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDatabaseRuleBasedPersistService.java
@@ -29,7 +29,7 @@ import java.util.Map;
  *
  * @param <T> type of configuration
  */
-public interface NewDatabaseRuleBasedPersistService<T> extends NewDatabaseBasedPersistService<T> {
+public interface NewDatabaseRuleBasedPersistService<T> extends DatabaseBasedPersistService<T> {
     
     /**
      * Persist configurations.
diff --git a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDatabaseRulePersistService.java b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDatabaseRulePersistService.java
index 16c259deee6..2c30505c446 100644
--- a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDatabaseRulePersistService.java
+++ b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/database/NewDatabaseRulePersistService.java
@@ -33,6 +33,7 @@ import java.util.List;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Map.Entry;
 
 /**
  * TODO Rename DatabaseRulePersistService when metadata structure adjustment completed. #25485
@@ -55,7 +56,7 @@ public final class NewDatabaseRulePersistService implements NewDatabaseRuleBased
     @Override
     public void persist(final String databaseName, final Collection<RuleConfiguration> configs) {
         Map<RuleConfiguration, NewYamlRuleConfigurationSwapper> yamlConfigs = new NewYamlRuleConfigurationSwapperEngine().swapToYamlRuleConfigurations(configs);
-        for (Map.Entry<RuleConfiguration, NewYamlRuleConfigurationSwapper> entry : yamlConfigs.entrySet()) {
+        for (Entry<RuleConfiguration, NewYamlRuleConfigurationSwapper> entry : yamlConfigs.entrySet()) {
             Collection<YamlDataNode> dataNodes = entry.getValue().swapToDataNodes(entry.getKey());
             if (dataNodes.isEmpty()) {
                 continue;
@@ -66,34 +67,38 @@ public final class NewDatabaseRulePersistService implements NewDatabaseRuleBased
     
     private void persistDataNodes(final String databaseName, final String ruleName, final Collection<YamlDataNode> dataNodes) {
         for (YamlDataNode each : dataNodes) {
-            if (Strings.isNullOrEmpty(repository.getDirectly(each.getKey()))) {
-                repository.persist(NewDatabaseMetaDataNode.getDatabaseRuleActiveVersionPath(databaseName, ruleName, each.getKey()), DEFAULT_VERSION);
+            if (Strings.isNullOrEmpty(NewDatabaseMetaDataNode.getDatabaseRuleActiveVersionNode(databaseName, ruleName, each.getKey()))) {
+                repository.persist(NewDatabaseMetaDataNode.getDatabaseRuleActiveVersionNode(databaseName, ruleName, each.getKey()), DEFAULT_VERSION);
             }
-            List<String> versions = repository.getChildrenKeys(NewDatabaseMetaDataNode.getDatabaseRuleVersionsPath(databaseName, ruleName, each.getKey()));
-            repository.persist(NewDatabaseMetaDataNode.getDatabaseRuleVersionPath(databaseName, ruleName, each.getKey(), versions.isEmpty()
-                    ? DEFAULT_VERSION
-                    : String.valueOf(Integer.parseInt(versions.get(0)) + 1)), each.getValue());
+            repository.persist(NewDatabaseMetaDataNode.getDatabaseRuleVersionNode(databaseName, ruleName, each.getKey(), DEFAULT_VERSION), each.getValue());
         }
     }
     
     @Override
-    public Collection<RuleConfiguration> load(final String databaseName, final String ruleName) {
+    public Collection<RuleConfiguration> load(final String databaseName) {
         Collection<String> result = new LinkedHashSet<>();
-        getAllKeys(result, NewDatabaseMetaDataNode.getDatabaseRulePath(databaseName, ruleName));
+        getAllNodes(result, NewDatabaseMetaDataNode.getRulesNode(databaseName));
         if (1 == result.size()) {
             return Collections.emptyList();
         }
-        return new NewYamlRuleConfigurationSwapperEngine().swapToRuleConfigurations(ruleName, getDataNodes(result));
+        return new NewYamlRuleConfigurationSwapperEngine().swapToRuleConfigurations(getDataNodes(result));
     }
     
-    private void getAllKeys(final Collection<String> keys, final String path) {
+    @Deprecated
+    @Override
+    public Collection<RuleConfiguration> load(final String databaseName, final String version) {
+        // TODO Remove this method when metadata structure adjustment completed. #25485
+        return Collections.emptyList();
+    }
+    
+    private void getAllNodes(final Collection<String> keys, final String path) {
         keys.add(path);
         List<String> childrenKeys = repository.getChildrenKeys(path);
         if (childrenKeys.isEmpty()) {
             return;
         }
         for (String each : childrenKeys) {
-            getAllKeys(keys, String.join("/", "", path, each));
+            getAllNodes(keys, String.join("/", "", path, each));
         }
     }
     
diff --git a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/global/NewGlobalRulePersistService.java b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/global/NewGlobalRulePersistService.java
new file mode 100644
index 00000000000..9137d33fa5c
--- /dev/null
+++ b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/global/NewGlobalRulePersistService.java
@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.metadata.persist.service.config.global;
+
+import com.google.common.base.Strings;
+import lombok.RequiredArgsConstructor;
+import org.apache.shardingsphere.authority.config.AuthorityRuleConfiguration;
+import org.apache.shardingsphere.infra.config.rule.RuleConfiguration;
+import org.apache.shardingsphere.infra.metadata.user.ShardingSphereUser;
+import org.apache.shardingsphere.infra.util.yaml.datanode.YamlDataNode;
+import org.apache.shardingsphere.infra.yaml.config.swapper.rule.NewYamlRuleConfigurationSwapper;
+import org.apache.shardingsphere.infra.yaml.config.swapper.rule.NewYamlRuleConfigurationSwapperEngine;
+import org.apache.shardingsphere.metadata.persist.node.NewGlobalNode;
+import org.apache.shardingsphere.mode.spi.PersistRepository;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.List;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+
+/**
+ * TODO Rename GlobalRulePersistService when metadata structure adjustment completed. #25485
+ * New Global rule persist service.
+ */
+@RequiredArgsConstructor
+public final class NewGlobalRulePersistService implements GlobalPersistService<Collection<RuleConfiguration>> {
+    
+    private static final String DEFAULT_VERSION = "0";
+    
+    private final PersistRepository repository;
+    
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    public void persist(final Collection<RuleConfiguration> globalRuleConfigs) {
+        Map<RuleConfiguration, NewYamlRuleConfigurationSwapper> yamlConfigs = new NewYamlRuleConfigurationSwapperEngine().swapToYamlRuleConfigurations(globalRuleConfigs);
+        for (Entry<RuleConfiguration, NewYamlRuleConfigurationSwapper> entry : yamlConfigs.entrySet()) {
+            Collection<YamlDataNode> dataNodes = entry.getValue().swapToDataNodes(entry.getKey());
+            if (dataNodes.isEmpty()) {
+                continue;
+            }
+            persistDataNodes(dataNodes);
+        }
+    }
+    
+    private void persistDataNodes(final Collection<YamlDataNode> dataNodes) {
+        for (YamlDataNode each : dataNodes) {
+            if (Strings.isNullOrEmpty(NewGlobalNode.getGlobalRuleActiveVersionNode(each.getKey()))) {
+                repository.persist(NewGlobalNode.getGlobalRuleActiveVersionNode(each.getKey()), DEFAULT_VERSION);
+            }
+            repository.persist(NewGlobalNode.getGlobalRuleVersionNode(each.getKey(), DEFAULT_VERSION), each.getValue());
+        }
+    }
+    
+    @Override
+    @SuppressWarnings("unchecked")
+    public Collection<RuleConfiguration> load() {
+        Collection<String> result = new LinkedHashSet<>();
+        getAllNodes(result, NewGlobalNode.getGlobalRuleRootNode());
+        if (1 == result.size()) {
+            return Collections.emptyList();
+        }
+        return new NewYamlRuleConfigurationSwapperEngine().swapToRuleConfigurations(getDataNodes(result));
+    }
+    
+    // TODO Consider merge NewGlobalRulePersistService and NewDatabaseRulePersistService load method.
+    private void getAllNodes(final Collection<String> keys, final String path) {
+        keys.add(path);
+        List<String> childrenKeys = repository.getChildrenKeys(path);
+        if (childrenKeys.isEmpty()) {
+            return;
+        }
+        for (String each : childrenKeys) {
+            getAllNodes(keys, String.join("/", "", path, each));
+        }
+    }
+    
+    private Collection<YamlDataNode> getDataNodes(final Collection<String> keys) {
+        Collection<YamlDataNode> result = new LinkedHashSet<>();
+        for (String each : keys) {
+            result.add(new YamlDataNode(each, repository.getDirectly(each)));
+        }
+        return result;
+    }
+    
+    /**
+     * Load all users.
+     * 
+     * @return collection of user
+     */
+    @Override
+    public Collection<ShardingSphereUser> loadUsers() {
+        Optional<AuthorityRuleConfiguration> authorityRuleConfig = load().stream()
+                .filter(AuthorityRuleConfiguration.class::isInstance).map(AuthorityRuleConfiguration.class::cast).findFirst();
+        return authorityRuleConfig.isPresent() ? authorityRuleConfig.get().getUsers() : Collections.emptyList();
+    }
+}
diff --git a/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/global/NewPropertiesPersistService.java b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/global/NewPropertiesPersistService.java
new file mode 100644
index 00000000000..26537b1eb6a
--- /dev/null
+++ b/kernel/metadata/core/src/main/java/org/apache/shardingsphere/metadata/persist/service/config/global/NewPropertiesPersistService.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.metadata.persist.service.config.global;
+
+import com.google.common.base.Strings;
+import lombok.RequiredArgsConstructor;
+import org.apache.shardingsphere.infra.util.yaml.YamlEngine;
+import org.apache.shardingsphere.metadata.persist.node.NewGlobalNode;
+import org.apache.shardingsphere.mode.spi.PersistRepository;
+
+import java.util.Properties;
+
+/**
+ * TODO Rename PropertiesPersistService when metadata structure adjustment completed. #25485
+ * Properties persist service.
+ */
+@RequiredArgsConstructor
+public final class NewPropertiesPersistService implements GlobalPersistService<Properties> {
+    
+    private static final String DEFAULT_VERSION = "0";
+    
+    private final PersistRepository repository;
+    
+    @Override
+    public void persist(final Properties props) {
+        if (Strings.isNullOrEmpty(repository.getDirectly(NewGlobalNode.getPropsActiveVersionNode()))) {
+            repository.persist(NewGlobalNode.getPropsActiveVersionNode(), DEFAULT_VERSION);
+        }
+        repository.persist(NewGlobalNode.getPropsVersionNode(DEFAULT_VERSION), YamlEngine.marshal(props));
+    }
+    
+    @Override
+    public Properties load() {
+        // TODO
+        return new Properties();
+    }
+}
diff --git a/kernel/metadata/core/src/test/java/org/apache/shardingsphere/metadata/persist/node/NewDatabaseMetaDataNodeTest.java b/kernel/metadata/core/src/test/java/org/apache/shardingsphere/metadata/persist/node/NewDatabaseMetaDataNodeTest.java
index bfafe7fa08c..57a5164a9af 100644
--- a/kernel/metadata/core/src/test/java/org/apache/shardingsphere/metadata/persist/node/NewDatabaseMetaDataNodeTest.java
+++ b/kernel/metadata/core/src/test/java/org/apache/shardingsphere/metadata/persist/node/NewDatabaseMetaDataNodeTest.java
@@ -30,27 +30,27 @@ class NewDatabaseMetaDataNodeTest {
     
     @Test
     void assertGetMetaDataDataSourcesPath() {
-        assertThat(NewDatabaseMetaDataNode.getDataSourcesPath("foo_db"), is("/metadata/foo_db/data_sources"));
+        assertThat(NewDatabaseMetaDataNode.getDataSourcesNode("foo_db"), is("/metadata/foo_db/data_sources"));
     }
     
     @Test
     void assertGetMetaDataDataSourcePath() {
-        assertThat(NewDatabaseMetaDataNode.getDataSourcePath("foo_db", "foo_ds", "0"), is("/metadata/foo_db/data_sources/foo_ds/versions/0"));
+        assertThat(NewDatabaseMetaDataNode.getDataSourceNode("foo_db", "foo_ds", "0"), is("/metadata/foo_db/data_sources/foo_ds/versions/0"));
     }
     
     @Test
     void assertGetDatabaseRuleActiveVersionPath() {
-        assertThat(NewDatabaseMetaDataNode.getDatabaseRuleActiveVersionPath("foo_db", "foo_rule", "foo_tables"), is("/metadata/foo_db/rules/foo_rule/foo_tables/active_version"));
+        assertThat(NewDatabaseMetaDataNode.getDatabaseRuleActiveVersionNode("foo_db", "foo_rule", "foo_tables"), is("/metadata/foo_db/rules/foo_rule/foo_tables/active_version"));
     }
     
     @Test
     void assertGetDatabaseRuleVersionPath() {
-        assertThat(NewDatabaseMetaDataNode.getDatabaseRuleVersionPath("foo_db", "foo_rule", "foo_tables", "1"), is("/metadata/foo_db/rules/foo_rule/foo_tables/versions/1"));
+        assertThat(NewDatabaseMetaDataNode.getDatabaseRuleVersionNode("foo_db", "foo_rule", "foo_tables", "1"), is("/metadata/foo_db/rules/foo_rule/foo_tables/versions/1"));
     }
     
     @Test
     void assertGetDatabaseNameByPath() {
-        Optional<String> actual = NewDatabaseMetaDataNode.getDatabaseNameByPath("/metadata/foo_db/readwrite_splitting");
+        Optional<String> actual = NewDatabaseMetaDataNode.getDatabaseNameByNode("/metadata/foo_db/readwrite_splitting");
         assertTrue(actual.isPresent());
         assertThat(actual.get(), is("foo_db"));
     }
diff --git a/kernel/metadata/core/src/test/java/org/apache/shardingsphere/metadata/persist/node/NewGlobalNodeTest.java b/kernel/metadata/core/src/test/java/org/apache/shardingsphere/metadata/persist/node/NewGlobalNodeTest.java
new file mode 100644
index 00000000000..6fefcbd1297
--- /dev/null
+++ b/kernel/metadata/core/src/test/java/org/apache/shardingsphere/metadata/persist/node/NewGlobalNodeTest.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.metadata.persist.node;
+
+import org.junit.jupiter.api.Test;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+// TODO Rename GlobalNodeTest when metadata structure adjustment completed. #25485
+class NewGlobalNodeTest {
+    
+    @Test
+    void assertGetGlobalRuleRootNode() {
+        assertThat(NewGlobalNode.getGlobalRuleRootNode(), is("/rules"));
+    }
+    
+    @Test
+    void assertGetPropsActiveVersionNode() {
+        assertThat(NewGlobalNode.getPropsActiveVersionNode(), is("/props/active_version"));
+    }
+    
+    @Test
+    void assertGetPropsVersionNode() {
+        assertThat(NewGlobalNode.getPropsVersionNode("0"), is("/props/versions/0"));
+    }
+    
+    @Test
+    void assertGetGlobalRuleActiveVersionNode() {
+        assertThat(NewGlobalNode.getGlobalRuleActiveVersionNode("transaction"), is("/rules/transaction/active_version"));
+    }
+    
+    @Test
+    void assertGetGlobalRuleVersionNode() {
+        assertThat(NewGlobalNode.getGlobalRuleVersionNode("transaction", "0"), is("/rules/transaction/versions/0"));
+    }
+}
diff --git a/kernel/single/core/pom.xml b/kernel/single/core/pom.xml
index 5e14d1999ff..e8b08a37d2a 100644
--- a/kernel/single/core/pom.xml
+++ b/kernel/single/core/pom.xml
@@ -33,6 +33,11 @@
             <artifactId>shardingsphere-single-api</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.shardingsphere</groupId>
+            <artifactId>shardingsphere-sql-federation-api</artifactId>
+            <version>${project.version}</version>
+        </dependency>
         
         <dependency>
             <groupId>org.apache.shardingsphere</groupId>
diff --git a/kernel/single/core/src/main/java/org/apache/shardingsphere/single/decider/SingleSQLFederationDecider.java b/kernel/single/core/src/main/java/org/apache/shardingsphere/single/decider/SingleSQLFederationDecider.java
index a9e3a0d9a22..66813c6d1a7 100644
--- a/kernel/single/core/src/main/java/org/apache/shardingsphere/single/decider/SingleSQLFederationDecider.java
+++ b/kernel/single/core/src/main/java/org/apache/shardingsphere/single/decider/SingleSQLFederationDecider.java
@@ -17,7 +17,6 @@
 
 package org.apache.shardingsphere.single.decider;
 
-import org.apache.shardingsphere.infra.binder.decider.SQLFederationDecider;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
 import org.apache.shardingsphere.infra.binder.type.IndexAvailable;
@@ -31,6 +30,7 @@ import org.apache.shardingsphere.infra.metadata.database.schema.util.IndexMetaDa
 import org.apache.shardingsphere.single.constant.SingleOrder;
 import org.apache.shardingsphere.single.rule.SingleRule;
 import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;
+import org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider;
 
 import java.util.Collection;
 import java.util.HashSet;
diff --git a/kernel/single/core/src/main/java/org/apache/shardingsphere/single/route/SingleSQLRouter.java b/kernel/single/core/src/main/java/org/apache/shardingsphere/single/route/SingleSQLRouter.java
index db64109fa6d..c989a1fe0a1 100644
--- a/kernel/single/core/src/main/java/org/apache/shardingsphere/single/route/SingleSQLRouter.java
+++ b/kernel/single/core/src/main/java/org/apache/shardingsphere/single/route/SingleSQLRouter.java
@@ -19,10 +19,8 @@ package org.apache.shardingsphere.single.route;
 
 import com.google.common.base.Preconditions;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
-import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
 import org.apache.shardingsphere.infra.binder.type.IndexAvailable;
 import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
-import org.apache.shardingsphere.infra.config.props.ConfigurationPropertyKey;
 import org.apache.shardingsphere.infra.connection.validator.ShardingSphereMetaDataValidateUtils;
 import org.apache.shardingsphere.infra.database.type.DatabaseType;
 import org.apache.shardingsphere.infra.database.type.DatabaseTypeEngine;
@@ -75,7 +73,7 @@ public final class SingleSQLRouter implements SQLRouter<SingleRule> {
             if (sqlStatement instanceof InsertStatement || sqlStatement instanceof DeleteStatement || sqlStatement instanceof UpdateStatement || sqlStatement instanceof SelectStatement) {
                 ShardingSphereMetaDataValidateUtils.validateTableExist(sqlStatementContext, database);
             }
-            validateSameDataSource(sqlStatementContext, rule, props, singleTableNames, result);
+            validateSameDataSource(rule, singleTableNames, result);
         }
         SingleRouteEngineFactory.newInstance(singleTableNames, sqlStatement).ifPresent(optional -> optional.route(result, rule));
         return result;
@@ -89,7 +87,7 @@ public final class SingleSQLRouter implements SQLRouter<SingleRule> {
         if (singleTableNames.isEmpty()) {
             return;
         }
-        validateSameDataSource(sqlStatementContext, rule, props, singleTableNames, routeContext);
+        validateSameDataSource(rule, singleTableNames, routeContext);
         SingleRouteEngineFactory.newInstance(singleTableNames, sqlStatementContext.getSqlStatement()).ifPresent(optional -> optional.route(routeContext, rule));
     }
     
@@ -121,13 +119,8 @@ public final class SingleSQLRouter implements SQLRouter<SingleRule> {
         return result;
     }
     
-    private void validateSameDataSource(final SQLStatementContext sqlStatementContext, final SingleRule rule,
-                                        final ConfigurationProperties props, final Collection<QualifiedTable> singleTableNames, final RouteContext routeContext) {
-        String sqlFederationType = props.getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE);
-        boolean allTablesInSameDataSource = "NONE".equals(sqlFederationType)
-                ? rule.isAllTablesInSameDataSource(routeContext, singleTableNames)
-                : sqlStatementContext instanceof SelectStatementContext || rule.isSingleTablesInSameDataSource(singleTableNames);
-        Preconditions.checkState(allTablesInSameDataSource, "All tables must be in the same datasource.");
+    private void validateSameDataSource(final SingleRule rule, final Collection<QualifiedTable> singleTableNames, final RouteContext routeContext) {
+        Preconditions.checkState(rule.isAllTablesInSameDataSource(routeContext, singleTableNames), "All tables must be in the same datasource.");
     }
     
     @Override
diff --git a/kernel/single/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider b/kernel/single/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider
new file mode 100644
index 00000000000..b7a4aa81be7
--- /dev/null
+++ b/kernel/single/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider
@@ -0,0 +1,18 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+org.apache.shardingsphere.single.decider.SingleSQLFederationDecider
diff --git a/kernel/sql-federation/api/src/main/java/org/apache/shardingsphere/sqlfederation/api/config/SQLFederationRuleConfiguration.java b/kernel/sql-federation/api/src/main/java/org/apache/shardingsphere/sqlfederation/api/config/SQLFederationRuleConfiguration.java
index c4e3eeab45f..e1c09e0d13a 100644
--- a/kernel/sql-federation/api/src/main/java/org/apache/shardingsphere/sqlfederation/api/config/SQLFederationRuleConfiguration.java
+++ b/kernel/sql-federation/api/src/main/java/org/apache/shardingsphere/sqlfederation/api/config/SQLFederationRuleConfiguration.java
@@ -18,19 +18,20 @@
 package org.apache.shardingsphere.sqlfederation.api.config;
 
 import lombok.Getter;
+import lombok.RequiredArgsConstructor;
 import lombok.Setter;
 import org.apache.shardingsphere.infra.config.rule.scope.GlobalRuleConfiguration;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
 
 /**
  * SQL federation rule configuration.
  */
 @Getter
 @Setter
+@RequiredArgsConstructor
 public final class SQLFederationRuleConfiguration implements GlobalRuleConfiguration {
     
-    private String sqlFederationType;
+    private final boolean sqlFederationEnabled;
     
-    public SQLFederationRuleConfiguration(final String sqlFederationType) {
-        this.sqlFederationType = sqlFederationType;
-    }
+    private final CacheOption executionPlanCache;
 }
diff --git a/kernel/sql-federation/api/src/main/java/org/apache/shardingsphere/sqlfederation/spi/SQLFederationDecider.java b/kernel/sql-federation/api/src/main/java/org/apache/shardingsphere/sqlfederation/spi/SQLFederationDecider.java
new file mode 100644
index 00000000000..4fb97b06ece
--- /dev/null
+++ b/kernel/sql-federation/api/src/main/java/org/apache/shardingsphere/sqlfederation/spi/SQLFederationDecider.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.spi;
+
+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
+import org.apache.shardingsphere.infra.datanode.DataNode;
+import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
+import org.apache.shardingsphere.infra.rule.ShardingSphereRule;
+import org.apache.shardingsphere.infra.util.spi.annotation.SingletonSPI;
+import org.apache.shardingsphere.infra.util.spi.type.ordered.OrderedSPI;
+
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * SQL federation decider.
+ * 
+ * @param <T> type of rule
+ */
+@SingletonSPI
+public interface SQLFederationDecider<T extends ShardingSphereRule> extends OrderedSPI<T> {
+    
+    /**
+     * Judge whether to use SQL federation.
+     *
+     * @param selectStatementContext select statement context
+     * @param parameters parameters
+     * @param globalRuleMetaData global rule meta data
+     * @param database database
+     * @param rule rule
+     * @param includedDataNodes included data nodes
+     * @return use SQL federation or not
+     */
+    boolean decide(SelectStatementContext selectStatementContext, List<Object> parameters,
+                   ShardingSphereRuleMetaData globalRuleMetaData, ShardingSphereDatabase database, T rule, Collection<DataNode> includedDataNodes);
+}
diff --git a/kernel/sql-federation/core/pom.xml b/kernel/sql-federation/core/pom.xml
index 3ddd7d8a1e9..6193f729643 100644
--- a/kernel/sql-federation/core/pom.xml
+++ b/kernel/sql-federation/core/pom.xml
@@ -108,6 +108,12 @@
             <version>${project.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.shardingsphere</groupId>
+            <artifactId>shardingsphere-test-util</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>javax.xml.bind</groupId>
             <artifactId>jaxb-api</artifactId>
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/decider/SQLFederationDecideEngine.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/decider/SQLFederationDecideEngine.java
new file mode 100644
index 00000000000..4f2b93206fa
--- /dev/null
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/decider/SQLFederationDecideEngine.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.decider;
+
+import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
+import org.apache.shardingsphere.infra.datanode.DataNode;
+import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
+import org.apache.shardingsphere.infra.metadata.database.schema.util.SystemSchemaUtils;
+import org.apache.shardingsphere.infra.rule.ShardingSphereRule;
+import org.apache.shardingsphere.infra.util.spi.type.ordered.OrderedSPILoader;
+import org.apache.shardingsphere.sqlfederation.rule.SQLFederationRule;
+import org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+/**
+ * SQL federation decide engine.
+ */
+public final class SQLFederationDecideEngine {
+    
+    @SuppressWarnings("rawtypes")
+    private final Map<ShardingSphereRule, SQLFederationDecider> deciders;
+    
+    public SQLFederationDecideEngine(final Collection<ShardingSphereRule> rules) {
+        deciders = OrderedSPILoader.getServices(SQLFederationDecider.class, rules);
+    }
+    
+    /**
+     * Decide use SQL federation or not.
+     * 
+     * @param sqlStatementContext SQL statement context
+     * @param parameters SQL parameters
+     * @param database ShardingSphere database
+     * @param globalRuleMetaData global rule meta data
+     * @return use SQL federation or not
+     */
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    public boolean decide(final SQLStatementContext sqlStatementContext, final List<Object> parameters,
+                          final ShardingSphereDatabase database, final ShardingSphereRuleMetaData globalRuleMetaData) {
+        // TODO BEGIN: move this logic to SQLFederationDecider implement class when we remove sql federation type
+        if (isQuerySystemSchema(sqlStatementContext, database)) {
+            return true;
+        }
+        // TODO END
+        boolean sqlFederationEnabled = globalRuleMetaData.getSingleRule(SQLFederationRule.class).getConfiguration().isSqlFederationEnabled();
+        if (!sqlFederationEnabled || !(sqlStatementContext instanceof SelectStatementContext)) {
+            return false;
+        }
+        Collection<DataNode> includedDataNodes = new HashSet<>();
+        for (Entry<ShardingSphereRule, SQLFederationDecider> entry : deciders.entrySet()) {
+            boolean isUseSQLFederation = entry.getValue().decide((SelectStatementContext) sqlStatementContext, parameters, globalRuleMetaData, database, entry.getKey(), includedDataNodes);
+            if (isUseSQLFederation) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+    private boolean isQuerySystemSchema(final SQLStatementContext sqlStatementContext, final ShardingSphereDatabase database) {
+        return sqlStatementContext instanceof SelectStatementContext
+                && SystemSchemaUtils.containsSystemSchema(sqlStatementContext.getDatabaseType(), sqlStatementContext.getTablesContext().getSchemaNames(), database);
+    }
+}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/AdvancedSQLFederationExecutor.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/AdvancedSQLFederationExecutor.java
new file mode 100644
index 00000000000..e943941dbba
--- /dev/null
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/AdvancedSQLFederationExecutor.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.executor;
+
+import com.google.common.base.Preconditions;
+import org.apache.calcite.adapter.enumerable.EnumerableInterpretable;
+import org.apache.calcite.adapter.enumerable.EnumerableRel;
+import org.apache.calcite.adapter.java.JavaTypeFactory;
+import org.apache.calcite.config.CalciteConnectionConfig;
+import org.apache.calcite.config.CalciteConnectionConfigImpl;
+import org.apache.calcite.jdbc.JavaTypeFactoryImpl;
+import org.apache.calcite.linq4j.Enumerator;
+import org.apache.calcite.plan.RelOptPlanner;
+import org.apache.calcite.prepare.CalciteCatalogReader;
+import org.apache.calcite.runtime.Bindable;
+import org.apache.calcite.schema.impl.AbstractSchema;
+import org.apache.calcite.sql.validate.SqlValidator;
+import org.apache.calcite.sql2rel.SqlToRelConverter;
+import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
+import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
+import org.apache.shardingsphere.infra.database.type.DatabaseType;
+import org.apache.shardingsphere.infra.executor.sql.execute.engine.driver.jdbc.JDBCExecutionUnit;
+import org.apache.shardingsphere.infra.executor.sql.execute.engine.driver.jdbc.JDBCExecutor;
+import org.apache.shardingsphere.infra.executor.sql.execute.engine.driver.jdbc.JDBCExecutorCallback;
+import org.apache.shardingsphere.infra.executor.sql.execute.result.ExecuteResult;
+import org.apache.shardingsphere.infra.executor.sql.prepare.driver.DriverExecutionPrepareEngine;
+import org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData;
+import org.apache.shardingsphere.infra.metadata.data.ShardingSphereData;
+import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
+import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereSchema;
+import org.apache.shardingsphere.sqlfederation.executor.resultset.SQLFederationResultSet;
+import org.apache.shardingsphere.sqlfederation.optimizer.SQLOptimizeContext;
+import org.apache.shardingsphere.sqlfederation.optimizer.SQLOptimizeEngine;
+import org.apache.shardingsphere.sqlfederation.optimizer.context.OptimizerContext;
+import org.apache.shardingsphere.sqlfederation.optimizer.context.OptimizerContextFactory;
+import org.apache.shardingsphere.sqlfederation.optimizer.context.parser.OptimizerParserContext;
+import org.apache.shardingsphere.sqlfederation.optimizer.executor.TableScanExecutor;
+import org.apache.shardingsphere.sqlfederation.optimizer.metadata.translatable.TranslatableSchema;
+import org.apache.shardingsphere.sqlfederation.optimizer.util.SQLFederationPlannerUtils;
+import org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutor;
+import org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutorContext;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Advanced SQL federation executor.
+ */
+public final class AdvancedSQLFederationExecutor implements SQLFederationExecutor {
+    
+    private static final JavaTypeFactory JAVA_TYPE_FACTORY = new JavaTypeFactoryImpl();
+    
+    private String databaseName;
+    
+    private String schemaName;
+    
+    private OptimizerContext optimizerContext;
+    
+    private ShardingSphereRuleMetaData globalRuleMetaData;
+    
+    private ConfigurationProperties props;
+    
+    private ShardingSphereData data;
+    
+    private JDBCExecutor jdbcExecutor;
+    
+    private ResultSet resultSet;
+    
+    @Override
+    public void init(final String databaseName, final String schemaName, final ShardingSphereMetaData metaData, final ShardingSphereData data, final JDBCExecutor jdbcExecutor) {
+        this.databaseName = databaseName;
+        this.schemaName = schemaName;
+        this.optimizerContext = OptimizerContextFactory.create(metaData.getDatabases(), metaData.getGlobalRuleMetaData());
+        this.globalRuleMetaData = metaData.getGlobalRuleMetaData();
+        this.props = metaData.getProps();
+        this.data = data;
+        this.jdbcExecutor = jdbcExecutor;
+    }
+    
+    @Override
+    public ResultSet executeQuery(final DriverExecutionPrepareEngine<JDBCExecutionUnit, Connection> prepareEngine,
+                                  final JDBCExecutorCallback<? extends ExecuteResult> callback, final SQLFederationExecutorContext federationContext) {
+        SQLStatementContext sqlStatementContext = federationContext.getQueryContext().getSqlStatementContext();
+        Preconditions.checkArgument(sqlStatementContext instanceof SelectStatementContext, "SQL statement context must be select statement context.");
+        ShardingSphereDatabase database = federationContext.getMetaData().getDatabase(databaseName);
+        ShardingSphereSchema schema = database.getSchema(schemaName);
+        AbstractSchema sqlFederationSchema = createSQLFederationSchema(prepareEngine, database.getProtocolType(), schema, callback, federationContext);
+        Map<String, Object> params = createParameters(federationContext.getQueryContext().getParameters());
+        resultSet = execute((SelectStatementContext) sqlStatementContext, schema, sqlFederationSchema, params);
+        return resultSet;
+    }
+    
+    private Map<String, Object> createParameters(final List<Object> params) {
+        Map<String, Object> result = new HashMap<>(params.size(), 1F);
+        int index = 0;
+        for (Object each : params) {
+            result.put("?" + index++, each);
+        }
+        return result;
+    }
+    
+    private AbstractSchema createSQLFederationSchema(final DriverExecutionPrepareEngine<JDBCExecutionUnit, Connection> prepareEngine, final DatabaseType protocolType,
+                                                     final ShardingSphereSchema schema,
+                                                     final JDBCExecutorCallback<? extends ExecuteResult> callback, final SQLFederationExecutorContext federationContext) {
+        TableScanExecutorContext executorContext = new TableScanExecutorContext(databaseName, schemaName, props, federationContext);
+        TableScanExecutor executor = new TranslatableTableScanExecutor(prepareEngine, jdbcExecutor, callback, optimizerContext, globalRuleMetaData, executorContext, data);
+        return new TranslatableSchema(schemaName, schema, protocolType, JAVA_TYPE_FACTORY, executor);
+    }
+    
+    @SuppressWarnings("unchecked")
+    private ResultSet execute(final SelectStatementContext selectStatementContext, final ShardingSphereSchema schema, final AbstractSchema sqlFederationSchema, final Map<String, Object> params) {
+        OptimizerParserContext parserContext = optimizerContext.getParserContext(databaseName);
+        CalciteConnectionConfig connectionConfig = new CalciteConnectionConfigImpl(parserContext.getDialectProps());
+        CalciteCatalogReader catalogReader = SQLFederationPlannerUtils.createCatalogReader(schemaName, sqlFederationSchema, JAVA_TYPE_FACTORY, connectionConfig);
+        SqlValidator validator = SQLFederationPlannerUtils.createSqlValidator(catalogReader, JAVA_TYPE_FACTORY, parserContext.getDatabaseType(), connectionConfig);
+        SqlToRelConverter converter = SQLFederationPlannerUtils.createSqlToRelConverter(catalogReader, validator,
+                SQLFederationPlannerUtils.createRelOptCluster(JAVA_TYPE_FACTORY), optimizerContext.getSqlParserRule(), parserContext.getDatabaseType(), true);
+        RelOptPlanner hepPlanner = optimizerContext.getPlannerContext(databaseName).getHepPlanner();
+        SQLOptimizeContext optimizeContext = new SQLOptimizeEngine(converter, hepPlanner).optimize(selectStatementContext.getSqlStatement());
+        Bindable<Object> executablePlan = EnumerableInterpretable.toBindable(Collections.emptyMap(), null, (EnumerableRel) optimizeContext.getBestPlan(), EnumerableRel.Prefer.ARRAY);
+        Enumerator<Object> enumerator = executablePlan.bind(new SQLFederationDataContext(validator, converter, params)).enumerator();
+        return new SQLFederationResultSet(enumerator, schema, sqlFederationSchema, selectStatementContext, optimizeContext.getValidatedNodeType());
+    }
+    
+    @Override
+    public ResultSet getResultSet() {
+        return resultSet;
+    }
+    
+    @Override
+    public void close() throws SQLException {
+        if (null != resultSet) {
+            resultSet.close();
+        }
+    }
+    
+    @Override
+    public boolean isDefault() {
+        return true;
+    }
+    
+    @Override
+    public String getType() {
+        return "ADVANCED";
+    }
+}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/FilterableTableScanExecutor.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/FilterableTableScanExecutor.java
deleted file mode 100644
index 017538a6509..00000000000
--- a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/FilterableTableScanExecutor.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.shardingsphere.sqlfederation.executor;
-
-import lombok.RequiredArgsConstructor;
-import lombok.SneakyThrows;
-import org.apache.calcite.adapter.java.JavaTypeFactory;
-import org.apache.calcite.config.CalciteConnectionConfig;
-import org.apache.calcite.config.CalciteConnectionConfigImpl;
-import org.apache.calcite.jdbc.JavaTypeFactoryImpl;
-import org.apache.calcite.linq4j.AbstractEnumerable;
-import org.apache.calcite.linq4j.Enumerable;
-import org.apache.calcite.linq4j.Enumerator;
-import org.apache.calcite.plan.RelOptCluster;
-import org.apache.calcite.prepare.CalciteCatalogReader;
-import org.apache.calcite.rel.RelNode;
-import org.apache.calcite.rel.core.RelFactories;
-import org.apache.calcite.rel.rel2sql.RelToSqlConverter;
-import org.apache.calcite.rex.RexBuilder;
-import org.apache.calcite.rex.RexNode;
-import org.apache.calcite.sql.SqlDialect;
-import org.apache.calcite.sql.util.SqlString;
-import org.apache.calcite.tools.RelBuilder;
-import org.apache.shardingsphere.infra.binder.SQLStatementContextFactory;
-import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
-import org.apache.shardingsphere.infra.connection.kernel.KernelProcessor;
-import org.apache.shardingsphere.infra.database.type.DatabaseType;
-import org.apache.shardingsphere.infra.database.type.DatabaseTypeEngine;
-import org.apache.shardingsphere.infra.executor.kernel.model.ExecutionGroup;
-import org.apache.shardingsphere.infra.executor.kernel.model.ExecutionGroupContext;
-import org.apache.shardingsphere.infra.executor.kernel.model.ExecutionGroupReportContext;
-import org.apache.shardingsphere.infra.executor.sql.context.ExecutionContext;
-import org.apache.shardingsphere.infra.executor.sql.execute.engine.driver.jdbc.JDBCExecutionUnit;
-import org.apache.shardingsphere.infra.executor.sql.execute.engine.driver.jdbc.JDBCExecutor;
-import org.apache.shardingsphere.infra.executor.sql.execute.engine.driver.jdbc.JDBCExecutorCallback;
-import org.apache.shardingsphere.infra.executor.sql.execute.result.ExecuteResult;
-import org.apache.shardingsphere.infra.executor.sql.execute.result.query.QueryResult;
-import org.apache.shardingsphere.infra.executor.sql.execute.result.query.QueryResultMetaData;
-import org.apache.shardingsphere.infra.executor.sql.execute.result.query.impl.driver.jdbc.type.memory.JDBCMemoryQueryResult;
-import org.apache.shardingsphere.infra.executor.sql.execute.result.query.impl.driver.jdbc.type.stream.JDBCStreamQueryResult;
-import org.apache.shardingsphere.infra.executor.sql.prepare.driver.DriverExecutionPrepareEngine;
-import org.apache.shardingsphere.infra.executor.sql.process.ProcessEngine;
-import org.apache.shardingsphere.infra.hint.HintValueContext;
-import org.apache.shardingsphere.infra.merge.MergeEngine;
-import org.apache.shardingsphere.infra.merge.result.MergedResult;
-import org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData;
-import org.apache.shardingsphere.infra.metadata.data.ShardingSphereData;
-import org.apache.shardingsphere.infra.metadata.data.ShardingSphereSchemaData;
-import org.apache.shardingsphere.infra.metadata.data.ShardingSphereTableData;
-import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
-import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
-import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereTable;
-import org.apache.shardingsphere.infra.parser.sql.SQLStatementParserEngine;
-import org.apache.shardingsphere.infra.session.connection.ConnectionContext;
-import org.apache.shardingsphere.infra.session.query.QueryContext;
-import org.apache.shardingsphere.infra.util.exception.external.sql.type.wrapper.SQLWrapperException;
-import org.apache.shardingsphere.sql.parser.sql.common.statement.SQLStatement;
-import org.apache.shardingsphere.sqlfederation.executor.row.EmptyRowEnumerator;
-import org.apache.shardingsphere.sqlfederation.executor.row.MemoryEnumerator;
-import org.apache.shardingsphere.sqlfederation.executor.row.SQLFederationRowEnumerator;
-import org.apache.shardingsphere.sqlfederation.optimizer.context.OptimizerContext;
-import org.apache.shardingsphere.sqlfederation.optimizer.executor.FilterableScanNodeExecutorContext;
-import org.apache.shardingsphere.sqlfederation.optimizer.executor.ScanNodeExecutorContext;
-import org.apache.shardingsphere.sqlfederation.optimizer.executor.TableScanExecutor;
-import org.apache.shardingsphere.sqlfederation.optimizer.metadata.filter.FilterableSchema;
-import org.apache.shardingsphere.sqlfederation.optimizer.util.SQLFederationPlannerUtils;
-import org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutorContext;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-import java.sql.Statement;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Optional;
-import java.util.stream.Collectors;
-
-/**
- * Filterable table scan executor.
- */
-@RequiredArgsConstructor
-public final class FilterableTableScanExecutor implements TableScanExecutor {
-    
-    private static final JavaTypeFactory JAVA_TYPE_FACTORY = new JavaTypeFactoryImpl();
-    
-    private final DriverExecutionPrepareEngine<JDBCExecutionUnit, Connection> prepareEngine;
-    
-    private final JDBCExecutor jdbcExecutor;
-    
-    private final JDBCExecutorCallback<? extends ExecuteResult> callback;
-    
-    private final OptimizerContext optimizerContext;
-    
-    private final ShardingSphereRuleMetaData globalRuleMetaData;
-    
-    private final TableScanExecutorContext executorContext;
-    
-    private final ShardingSphereData data;
-    
-    private final ProcessEngine processEngine = new ProcessEngine();
-    
-    @Override
-    public Enumerable<Object> executeScalar(final ShardingSphereTable table, final ScanNodeExecutorContext scanContext) {
-        return new AbstractEnumerable<Object>() {
-            
-            @Override
-            public Enumerator<Object> enumerator() {
-                return new EmptyRowEnumerator<>();
-            }
-        };
-    }
-    
-    @Override
-    public Enumerable<Object[]> execute(final ShardingSphereTable table, final ScanNodeExecutorContext scanContext) {
-        String databaseName = executorContext.getDatabaseName().toLowerCase();
-        String schemaName = executorContext.getSchemaName().toLowerCase();
-        DatabaseType databaseType = DatabaseTypeEngine.getTrunkDatabaseType(optimizerContext.getParserContext(databaseName).getDatabaseType().getType());
-        if (databaseType.getSystemSchemas().contains(schemaName)) {
-            return executeByShardingSphereData(databaseName, schemaName, table);
-        }
-        SqlString sqlString = createSQLString(table, (FilterableScanNodeExecutorContext) scanContext, SQLDialectFactory.getSQLDialect(databaseType.getType()));
-        SQLFederationExecutorContext federationContext = executorContext.getFederationContext();
-        QueryContext queryContext = createQueryContext(federationContext.getMetaData(), sqlString, databaseType, federationContext.getQueryContext().isUseCache());
-        ShardingSphereDatabase database = federationContext.getMetaData().getDatabase(databaseName);
-        // TODO need to get session context
-        ExecutionContext context = new KernelProcessor().generateExecutionContext(queryContext, database, globalRuleMetaData, executorContext.getProps(), new ConnectionContext());
-        if (federationContext.isPreview()) {
-            federationContext.getExecutionUnits().addAll(context.getExecutionUnits());
-            return createEmptyEnumerable();
-        }
-        return execute(databaseType, queryContext, database, context);
-    }
-    
-    private AbstractEnumerable<Object[]> execute(final DatabaseType databaseType, final QueryContext queryContext, final ShardingSphereDatabase database, final ExecutionContext context) {
-        try {
-            ExecutionGroupContext<JDBCExecutionUnit> executionGroupContext =
-                    prepareEngine.prepare(context.getRouteContext(), context.getExecutionUnits(), new ExecutionGroupReportContext(database.getName()));
-            setParameters(executionGroupContext.getInputGroups());
-            processEngine.executeSQL(executionGroupContext, context.getQueryContext());
-            List<QueryResult> queryResults = execute(executionGroupContext, databaseType);
-            // TODO need to get session context
-            MergeEngine mergeEngine = new MergeEngine(database, executorContext.getProps(), new ConnectionContext());
-            MergedResult mergedResult = mergeEngine.merge(queryResults, queryContext.getSqlStatementContext());
-            Collection<Statement> statements = getStatements(executionGroupContext.getInputGroups());
-            return createEnumerable(mergedResult, queryResults.get(0).getMetaData(), statements);
-        } catch (final SQLException ex) {
-            throw new SQLWrapperException(ex);
-        } finally {
-            processEngine.completeSQLExecution();
-        }
-    }
-    
-    private List<QueryResult> execute(final ExecutionGroupContext<JDBCExecutionUnit> executionGroupContext, final DatabaseType databaseType) throws SQLException {
-        Collection<QueryResult> queryResults = jdbcExecutor.execute(executionGroupContext, callback).stream().map(QueryResult.class::cast).collect(Collectors.toList());
-        List<QueryResult> result = new LinkedList<>();
-        for (QueryResult each : queryResults) {
-            QueryResult queryResult = each instanceof JDBCStreamQueryResult
-                    ? new JDBCMemoryQueryResult(((JDBCStreamQueryResult) each).getResultSet(), databaseType)
-                    : each;
-            result.add(queryResult);
-        }
-        return result;
-    }
-    
-    private Enumerable<Object[]> executeByShardingSphereData(final String databaseName, final String schemaName, final ShardingSphereTable table) {
-        Optional<ShardingSphereTableData> tableData = Optional.ofNullable(data.getDatabaseData().get(databaseName)).map(optional -> optional.getSchemaData().get(schemaName))
-                .map(ShardingSphereSchemaData::getTableData).map(shardingSphereData -> shardingSphereData.get(table.getName()));
-        return tableData.map(this::createMemoryEnumerator).orElseGet(this::createEmptyEnumerable);
-    }
-    
-    private Enumerable<Object[]> createMemoryEnumerator(final ShardingSphereTableData tableData) {
-        return new AbstractEnumerable<Object[]>() {
-            
-            @Override
-            public Enumerator<Object[]> enumerator() {
-                return new MemoryEnumerator<>(tableData.getRows());
-            }
-        };
-    }
-    
-    private Collection<Statement> getStatements(final Collection<ExecutionGroup<JDBCExecutionUnit>> inputGroups) {
-        Collection<Statement> result = new LinkedList<>();
-        for (ExecutionGroup<JDBCExecutionUnit> each : inputGroups) {
-            for (JDBCExecutionUnit executionUnit : each.getInputs()) {
-                result.add(executionUnit.getStorageResource());
-            }
-        }
-        return result;
-    }
-    
-    private SqlString createSQLString(final ShardingSphereTable table, final FilterableScanNodeExecutorContext scanContext, final SqlDialect sqlDialect) {
-        return new RelToSqlConverter(sqlDialect).visitRoot(createRelNode(table, scanContext)).asStatement().toSqlString(sqlDialect);
-    }
-    
-    private void setParameters(final Collection<ExecutionGroup<JDBCExecutionUnit>> inputGroups) {
-        for (ExecutionGroup<JDBCExecutionUnit> each : inputGroups) {
-            for (JDBCExecutionUnit executionUnit : each.getInputs()) {
-                if (!(executionUnit.getStorageResource() instanceof PreparedStatement)) {
-                    continue;
-                }
-                setParameters((PreparedStatement) executionUnit.getStorageResource(), executionUnit.getExecutionUnit().getSqlUnit().getParameters());
-            }
-        }
-    }
-    
-    @SneakyThrows(SQLException.class)
-    private void setParameters(final PreparedStatement preparedStatement, final List<Object> params) {
-        for (int i = 0; i < params.size(); i++) {
-            preparedStatement.setObject(i + 1, params.get(i));
-        }
-    }
-    
-    private RelNode createRelNode(final ShardingSphereTable table, final FilterableScanNodeExecutorContext scanContext) {
-        String databaseName = executorContext.getDatabaseName();
-        String schemaName = executorContext.getSchemaName();
-        CalciteConnectionConfig connectionConfig = new CalciteConnectionConfigImpl(optimizerContext.getParserContext(databaseName).getDialectProps());
-        ShardingSphereDatabase database = executorContext.getFederationContext().getMetaData().getDatabase(databaseName);
-        CalciteCatalogReader catalogReader = SQLFederationPlannerUtils.createCatalogReader(schemaName,
-                new FilterableSchema(schemaName, database.getSchema(schemaName), database.getProtocolType(), JAVA_TYPE_FACTORY, null), JAVA_TYPE_FACTORY, connectionConfig);
-        RelOptCluster relOptCluster = RelOptCluster.create(SQLFederationPlannerUtils.createVolcanoPlanner(), new RexBuilder(JAVA_TYPE_FACTORY));
-        RelBuilder builder = RelFactories.LOGICAL_BUILDER.create(relOptCluster, catalogReader).scan(table.getName()).filter(scanContext.getFilterValues());
-        if (null != scanContext.getProjects()) {
-            builder.project(createProjections(scanContext.getProjects(), builder, table.getColumnNames()));
-        }
-        return builder.build();
-    }
-    
-    private Collection<RexNode> createProjections(final int[] projects, final RelBuilder relBuilder, final List<String> columnNames) {
-        Collection<RexNode> result = new LinkedList<>();
-        for (int each : projects) {
-            result.add(relBuilder.field(columnNames.get(each)));
-        }
-        return result;
-    }
-    
-    private AbstractEnumerable<Object[]> createEnumerable(final MergedResult mergedResult, final QueryResultMetaData metaData, final Collection<Statement> statements) throws SQLException {
-        // TODO remove getRows when mergedResult support JDBC first method
-        Collection<Object[]> rows = getRows(mergedResult, metaData);
-        return new AbstractEnumerable<Object[]>() {
-            
-            @Override
-            public Enumerator<Object[]> enumerator() {
-                return new SQLFederationRowEnumerator<>(rows, statements);
-            }
-        };
-    }
-    
-    private Collection<Object[]> getRows(final MergedResult mergedResult, final QueryResultMetaData metaData) throws SQLException {
-        Collection<Object[]> result = new LinkedList<>();
-        while (mergedResult.next()) {
-            Object[] currentRow = new Object[metaData.getColumnCount()];
-            for (int i = 0; i < metaData.getColumnCount(); i++) {
-                currentRow[i] = mergedResult.getValue(i + 1, Object.class);
-            }
-            result.add(currentRow);
-        }
-        return result;
-    }
-    
-    private QueryContext createQueryContext(final ShardingSphereMetaData metaData, final SqlString sqlString, final DatabaseType databaseType, final boolean useCache) {
-        String sql = sqlString.getSql().replace("\n", " ");
-        SQLStatement sqlStatement = new SQLStatementParserEngine(databaseType.getType(),
-                optimizerContext.getSqlParserRule().getSqlStatementCache(), optimizerContext.getSqlParserRule().getParseTreeCache(),
-                optimizerContext.getSqlParserRule().isSqlCommentParseEnabled()).parse(sql, useCache);
-        List<Object> params = getParameters(sqlString.getDynamicParameters());
-        SQLStatementContext sqlStatementContext = SQLStatementContextFactory.newInstance(metaData, params, sqlStatement, executorContext.getDatabaseName());
-        return new QueryContext(sqlStatementContext, sql, params, new HintValueContext(), useCache);
-    }
-    
-    private List<Object> getParameters(final List<Integer> paramIndexes) {
-        if (null == paramIndexes) {
-            return Collections.emptyList();
-        }
-        List<Object> result = new ArrayList<>();
-        for (Integer each : paramIndexes) {
-            result.add(executorContext.getFederationContext().getQueryContext().getParameters().get(each));
-        }
-        return result;
-    }
-    
-    private AbstractEnumerable<Object[]> createEmptyEnumerable() {
-        return new AbstractEnumerable<Object[]>() {
-            
-            @Override
-            public Enumerator<Object[]> enumerator() {
-                return new EmptyRowEnumerator<>();
-            }
-        };
-    }
-}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/TranslatableTableScanExecutor.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/TranslatableTableScanExecutor.java
index 9d63426c5b3..6ff143b2868 100644
--- a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/TranslatableTableScanExecutor.java
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/executor/TranslatableTableScanExecutor.java
@@ -81,7 +81,7 @@ import org.apache.shardingsphere.sqlfederation.optimizer.context.OptimizerContex
 import org.apache.shardingsphere.sqlfederation.optimizer.executor.ScanNodeExecutorContext;
 import org.apache.shardingsphere.sqlfederation.optimizer.executor.TableScanExecutor;
 import org.apache.shardingsphere.sqlfederation.optimizer.executor.TranslatableScanNodeExecutorContext;
-import org.apache.shardingsphere.sqlfederation.optimizer.metadata.filter.FilterableSchema;
+import org.apache.shardingsphere.sqlfederation.optimizer.metadata.translatable.TranslatableSchema;
 import org.apache.shardingsphere.sqlfederation.optimizer.rexnode.StringToRexNodeUtils;
 import org.apache.shardingsphere.sqlfederation.optimizer.util.SQLFederationPlannerUtils;
 import org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutorContext;
@@ -319,7 +319,7 @@ public final class TranslatableTableScanExecutor implements TableScanExecutor {
         CalciteConnectionConfig connectionConfig = new CalciteConnectionConfigImpl(optimizerContext.getParserContext(databaseName).getDialectProps());
         ShardingSphereDatabase database = executorContext.getFederationContext().getMetaData().getDatabase(databaseName);
         CalciteCatalogReader catalogReader = SQLFederationPlannerUtils.createCatalogReader(schemaName,
-                new FilterableSchema(schemaName, database.getSchema(schemaName), database.getProtocolType(), JAVA_TYPE_FACTORY, null), JAVA_TYPE_FACTORY, connectionConfig);
+                new TranslatableSchema(schemaName, database.getSchema(schemaName), database.getProtocolType(), JAVA_TYPE_FACTORY, null), JAVA_TYPE_FACTORY, connectionConfig);
         RelOptCluster relOptCluster = RelOptCluster.create(SQLFederationPlannerUtils.createVolcanoPlanner(), new RexBuilder(JAVA_TYPE_FACTORY));
         RelBuilder builder = RelFactories.LOGICAL_BUILDER.create(relOptCluster, catalogReader).scan(table.getName());
         if (null != scanContext.getFilterValues()) {
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/converter/segment/window/WindowConverter.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/converter/segment/window/WindowConverter.java
new file mode 100644
index 00000000000..20345bb1354
--- /dev/null
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/converter/segment/window/WindowConverter.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.optimizer.converter.segment.window;
+
+import org.apache.calcite.sql.SqlIdentifier;
+import org.apache.calcite.sql.SqlLiteral;
+import org.apache.calcite.sql.SqlNodeList;
+import org.apache.calcite.sql.SqlWindow;
+import org.apache.calcite.sql.parser.SqlParserPos;
+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.WindowSegment;
+import org.apache.shardingsphere.sqlfederation.optimizer.converter.segment.SQLSegmentConverter;
+import org.apache.shardingsphere.sqlfederation.optimizer.converter.segment.expression.ExpressionConverter;
+
+import java.util.Collections;
+import java.util.Optional;
+
+/**
+ * Window converter.
+ */
+public final class WindowConverter implements SQLSegmentConverter<WindowSegment, SqlNodeList> {
+    
+    @Override
+    public Optional<SqlNodeList> convert(final WindowSegment segment) {
+        SqlIdentifier sqlIdentifier = new SqlIdentifier(segment.getIdentifierValue().getValue(), SqlParserPos.ZERO);
+        SqlNodeList partitionList = new SqlNodeList(Collections.singletonList(new ExpressionConverter().convert(segment.getSegments().iterator().next()).get()), SqlParserPos.ZERO);
+        SqlNodeList orderList = new SqlNodeList(SqlParserPos.ZERO);
+        SqlWindow sqlWindow = new SqlWindow(SqlParserPos.ZERO, sqlIdentifier, null, partitionList, orderList, SqlLiteral.createBoolean(false, SqlParserPos.ZERO), null, null, null);
+        SqlNodeList result = new SqlNodeList(Collections.singletonList(sqlWindow), SqlParserPos.ZERO);
+        return Optional.of(result);
+    }
+}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableDatabase.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableDatabase.java
deleted file mode 100644
index 79cf9ae515d..00000000000
--- a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableDatabase.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.shardingsphere.sqlfederation.optimizer.metadata.filter;
-
-import lombok.Getter;
-import org.apache.calcite.adapter.java.JavaTypeFactory;
-import org.apache.calcite.schema.Schema;
-import org.apache.calcite.schema.impl.AbstractSchema;
-import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
-import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereSchema;
-import org.apache.shardingsphere.sqlfederation.optimizer.executor.TableScanExecutor;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-
-/**
- * Filterable database.
- */
-@Getter
-public final class FilterableDatabase extends AbstractSchema {
-    
-    private final String name;
-    
-    private final Map<String, Schema> subSchemaMap;
-    
-    public FilterableDatabase(final ShardingSphereDatabase database, final JavaTypeFactory javaTypeFactory, final TableScanExecutor executor) {
-        name = database.getName();
-        subSchemaMap = createSubSchemaMap(database, javaTypeFactory, executor);
-    }
-    
-    private Map<String, Schema> createSubSchemaMap(final ShardingSphereDatabase database, final JavaTypeFactory javaTypeFactory, final TableScanExecutor executor) {
-        Map<String, Schema> result = new LinkedHashMap<>(database.getSchemas().size(), 1F);
-        for (Entry<String, ShardingSphereSchema> entry : database.getSchemas().entrySet()) {
-            result.put(entry.getKey(), new FilterableSchema(entry.getKey(), entry.getValue(), database.getProtocolType(), javaTypeFactory, executor));
-        }
-        return result;
-    }
-}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableSchema.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableSchema.java
deleted file mode 100644
index 0f9a1918b2f..00000000000
--- a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableSchema.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.shardingsphere.sqlfederation.optimizer.metadata.filter;
-
-import lombok.Getter;
-import org.apache.calcite.adapter.java.JavaTypeFactory;
-import org.apache.calcite.rel.type.RelDataType;
-import org.apache.calcite.rel.type.RelDataTypeImpl;
-import org.apache.calcite.schema.Table;
-import org.apache.calcite.schema.impl.AbstractSchema;
-import org.apache.calcite.schema.impl.ViewTable;
-import org.apache.shardingsphere.infra.database.type.DatabaseType;
-import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereSchema;
-import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereTable;
-import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereView;
-import org.apache.shardingsphere.sqlfederation.optimizer.executor.TableScanExecutor;
-import org.apache.shardingsphere.sqlfederation.optimizer.metadata.statistic.FederationStatistic;
-import org.apache.shardingsphere.sqlfederation.optimizer.util.SQLFederationDataTypeUtils;
-
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Filterable schema.
- */
-@Getter
-public final class FilterableSchema extends AbstractSchema {
-    
-    private final String name;
-    
-    private final Map<String, Table> tableMap;
-    
-    public FilterableSchema(final String schemaName, final ShardingSphereSchema schema, final DatabaseType protocolType, final JavaTypeFactory javaTypeFactory, final TableScanExecutor executor) {
-        name = schemaName;
-        tableMap = createTableMap(schema, protocolType, javaTypeFactory, executor);
-    }
-    
-    private Map<String, Table> createTableMap(final ShardingSphereSchema schema, final DatabaseType protocolType, final JavaTypeFactory javaTypeFactory, final TableScanExecutor executor) {
-        Map<String, Table> result = new LinkedHashMap<>(schema.getTables().size(), 1F);
-        for (ShardingSphereTable each : schema.getTables().values()) {
-            if (schema.containsView(each.getName())) {
-                result.put(each.getName(), getViewTable(schema, protocolType, each, javaTypeFactory));
-            } else {
-                // TODO implement table statistic logic after using custom operators
-                result.put(each.getName(), new FilterableTable(each, executor, new FederationStatistic(), protocolType));
-            }
-        }
-        return result;
-    }
-    
-    private ViewTable getViewTable(final ShardingSphereSchema schema, final DatabaseType protocolType, final ShardingSphereTable table, final JavaTypeFactory javaTypeFactory) {
-        RelDataType relDataType = SQLFederationDataTypeUtils.createRelDataType(table, protocolType, javaTypeFactory);
-        ShardingSphereView view = schema.getView(table.getName());
-        return new ViewTable(javaTypeFactory.getJavaClass(relDataType), RelDataTypeImpl.proto(relDataType), view.getViewDefinition(), Collections.emptyList(), Collections.emptyList());
-    }
-}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableTable.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableTable.java
deleted file mode 100644
index 2aead5dbeca..00000000000
--- a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/optimizer/metadata/filter/FilterableTable.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.shardingsphere.sqlfederation.optimizer.metadata.filter;
-
-import lombok.RequiredArgsConstructor;
-import org.apache.calcite.DataContext;
-import org.apache.calcite.linq4j.Enumerable;
-import org.apache.calcite.rel.type.RelDataType;
-import org.apache.calcite.rel.type.RelDataTypeFactory;
-import org.apache.calcite.rex.RexNode;
-import org.apache.calcite.schema.ProjectableFilterableTable;
-import org.apache.calcite.schema.Statistic;
-import org.apache.calcite.schema.impl.AbstractTable;
-import org.apache.shardingsphere.infra.database.type.DatabaseType;
-import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereTable;
-import org.apache.shardingsphere.sqlfederation.optimizer.executor.FilterableScanNodeExecutorContext;
-import org.apache.shardingsphere.sqlfederation.optimizer.executor.TableScanExecutor;
-import org.apache.shardingsphere.sqlfederation.optimizer.metadata.statistic.FederationStatistic;
-import org.apache.shardingsphere.sqlfederation.optimizer.util.SQLFederationDataTypeUtils;
-
-import java.util.List;
-
-/**
- * Filterable table.
- */
-@RequiredArgsConstructor
-public final class FilterableTable extends AbstractTable implements ProjectableFilterableTable {
-    
-    private final ShardingSphereTable table;
-    
-    private final TableScanExecutor executor;
-    
-    private final FederationStatistic statistic;
-    
-    private final DatabaseType protocolType;
-    
-    @Override
-    public RelDataType getRowType(final RelDataTypeFactory typeFactory) {
-        return SQLFederationDataTypeUtils.createRelDataType(table, protocolType, typeFactory);
-    }
-    
-    @Override
-    public Enumerable<Object[]> scan(final DataContext root, final List<RexNode> filters, final int[] projects) {
-        return executor.execute(table, new FilterableScanNodeExecutorContext(root, filters, projects));
-    }
-    
-    @Override
-    public Statistic getStatistic() {
-        return statistic;
-    }
-}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/SQLFederationRule.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/SQLFederationRule.java
index 4f37cdd3372..8436afa6875 100644
--- a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/SQLFederationRule.java
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/SQLFederationRule.java
@@ -17,16 +17,13 @@
 
 package org.apache.shardingsphere.sqlfederation.rule;
 
-import com.google.common.base.Preconditions;
 import lombok.Getter;
-import org.apache.shardingsphere.infra.config.props.ConfigurationPropertyKey;
 import org.apache.shardingsphere.infra.executor.sql.execute.engine.driver.jdbc.JDBCExecutor;
 import org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData;
 import org.apache.shardingsphere.infra.metadata.data.ShardingSphereData;
 import org.apache.shardingsphere.infra.rule.identifier.scope.GlobalRule;
 import org.apache.shardingsphere.infra.util.spi.type.typed.TypedSPILoader;
 import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
-import org.apache.shardingsphere.sqlfederation.enums.SQLFederationTypeEnum;
 import org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutor;
 
 /**
@@ -37,11 +34,8 @@ public final class SQLFederationRule implements GlobalRule {
     @Getter
     private final SQLFederationRuleConfiguration configuration;
     
-    private SQLFederationExecutor sqlFederationExecutor;
-    
     public SQLFederationRule(final SQLFederationRuleConfiguration ruleConfig) {
         configuration = ruleConfig;
-        sqlFederationExecutor = TypedSPILoader.getService(SQLFederationExecutor.class, configuration.getSqlFederationType());
     }
     
     /**
@@ -56,14 +50,9 @@ public final class SQLFederationRule implements GlobalRule {
      */
     public SQLFederationExecutor getSQLFederationExecutor(final String databaseName, final String schemaName, final ShardingSphereMetaData metaData, final ShardingSphereData shardingSphereData,
                                                           final JDBCExecutor jdbcExecutor) {
-        String sqlFederationType = metaData.getProps().getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE);
-        Preconditions.checkArgument(SQLFederationTypeEnum.isValidSQLFederationType(sqlFederationType), "%s is not a valid sqlFederationType.", sqlFederationType);
-        if (!configuration.getSqlFederationType().equals(sqlFederationType)) {
-            configuration.setSqlFederationType(sqlFederationType);
-            sqlFederationExecutor = TypedSPILoader.getService(SQLFederationExecutor.class, configuration.getSqlFederationType());
-        }
-        sqlFederationExecutor.init(databaseName, schemaName, metaData, shardingSphereData, jdbcExecutor);
-        return sqlFederationExecutor;
+        SQLFederationExecutor result = TypedSPILoader.getService(SQLFederationExecutor.class, "ADVANCED");
+        result.init(databaseName, schemaName, metaData, shardingSphereData, jdbcExecutor);
+        return result;
     }
     
     @Override
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/builder/DefaultSQLFederationRuleConfigurationBuilder.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/builder/DefaultSQLFederationRuleConfigurationBuilder.java
index 37b22d5dcfa..0aa2ceb669e 100644
--- a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/builder/DefaultSQLFederationRuleConfigurationBuilder.java
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/builder/DefaultSQLFederationRuleConfigurationBuilder.java
@@ -18,6 +18,7 @@
 package org.apache.shardingsphere.sqlfederation.rule.builder;
 
 import org.apache.shardingsphere.infra.rule.builder.global.DefaultGlobalRuleConfigurationBuilder;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
 import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
 import org.apache.shardingsphere.sqlfederation.constant.SQLFederationOrder;
 
@@ -26,9 +27,11 @@ import org.apache.shardingsphere.sqlfederation.constant.SQLFederationOrder;
  */
 public final class DefaultSQLFederationRuleConfigurationBuilder implements DefaultGlobalRuleConfigurationBuilder<SQLFederationRuleConfiguration, SQLFederationRuleBuilder> {
     
+    public static final CacheOption DEFAULT_EXECUTION_PLAN_CACHE_OPTION = new CacheOption(2000, 65535L);
+    
     @Override
     public SQLFederationRuleConfiguration build() {
-        return new SQLFederationRuleConfiguration("NONE");
+        return new SQLFederationRuleConfiguration(false, DEFAULT_EXECUTION_PLAN_CACHE_OPTION);
     }
     
     @Override
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/builder/SQLFederationRuleBuilder.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/builder/SQLFederationRuleBuilder.java
index b7e3fd90a13..0b956b365c1 100644
--- a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/builder/SQLFederationRuleBuilder.java
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/rule/builder/SQLFederationRuleBuilder.java
@@ -18,7 +18,6 @@
 package org.apache.shardingsphere.sqlfederation.rule.builder;
 
 import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
-import org.apache.shardingsphere.infra.config.props.ConfigurationPropertyKey;
 import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
 import org.apache.shardingsphere.infra.rule.builder.global.GlobalRuleBuilder;
 import org.apache.shardingsphere.infra.rule.identifier.scope.GlobalRule;
@@ -35,7 +34,6 @@ public final class SQLFederationRuleBuilder implements GlobalRuleBuilder<SQLFede
     
     @Override
     public GlobalRule build(final SQLFederationRuleConfiguration ruleConfig, final Map<String, ShardingSphereDatabase> databases, final ConfigurationProperties props) {
-        ruleConfig.setSqlFederationType(props.getValue(ConfigurationPropertyKey.SQL_FEDERATION_TYPE));
         return new SQLFederationRule(ruleConfig);
     }
     
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/config/YamlSQLFederationExecutionPlanCacheRuleConfiguration.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/config/YamlSQLFederationExecutionPlanCacheRuleConfiguration.java
new file mode 100644
index 00000000000..0aefe73b812
--- /dev/null
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/config/YamlSQLFederationExecutionPlanCacheRuleConfiguration.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.yaml.config;
+
+import lombok.Getter;
+import lombok.Setter;
+import org.apache.shardingsphere.infra.util.yaml.YamlConfiguration;
+
+/**
+ * SQL federation execution plan cache rule configuration for YAML.
+ */
+@Getter
+@Setter
+public final class YamlSQLFederationExecutionPlanCacheRuleConfiguration implements YamlConfiguration {
+    
+    private int initialCapacity;
+    
+    private long maximumSize;
+}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/config/YamlSQLFederationRuleConfiguration.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/config/YamlSQLFederationRuleConfiguration.java
new file mode 100644
index 00000000000..be390571b3c
--- /dev/null
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/config/YamlSQLFederationRuleConfiguration.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.yaml.config;
+
+import lombok.Getter;
+import lombok.Setter;
+import org.apache.shardingsphere.infra.yaml.config.pojo.rule.YamlGlobalRuleConfiguration;
+import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
+
+/**
+ * SQL federation rule configuration for YAML.
+ */
+@Getter
+@Setter
+public final class YamlSQLFederationRuleConfiguration implements YamlGlobalRuleConfiguration {
+    
+    private boolean sqlFederationEnabled;
+    
+    private YamlSQLFederationExecutionPlanCacheRuleConfiguration executionPlanCache;
+    
+    @Override
+    public Class<SQLFederationRuleConfiguration> getRuleConfigurationType() {
+        return SQLFederationRuleConfiguration.class;
+    }
+}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/swapper/YamlSQLFederationExecutionPlanCacheConfigurationSwapper.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/swapper/YamlSQLFederationExecutionPlanCacheConfigurationSwapper.java
new file mode 100644
index 00000000000..b021c018d78
--- /dev/null
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/swapper/YamlSQLFederationExecutionPlanCacheConfigurationSwapper.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.yaml.swapper;
+
+import org.apache.shardingsphere.infra.util.yaml.swapper.YamlConfigurationSwapper;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
+import org.apache.shardingsphere.sqlfederation.yaml.config.YamlSQLFederationExecutionPlanCacheRuleConfiguration;
+
+/**
+ * YAML SQL federation execution plan cache configuration swapper.
+ */
+public final class YamlSQLFederationExecutionPlanCacheConfigurationSwapper implements YamlConfigurationSwapper<YamlSQLFederationExecutionPlanCacheRuleConfiguration, CacheOption> {
+    
+    @Override
+    public YamlSQLFederationExecutionPlanCacheRuleConfiguration swapToYamlConfiguration(final CacheOption data) {
+        YamlSQLFederationExecutionPlanCacheRuleConfiguration result = new YamlSQLFederationExecutionPlanCacheRuleConfiguration();
+        result.setInitialCapacity(data.getInitialCapacity());
+        result.setMaximumSize(data.getMaximumSize());
+        return result;
+    }
+    
+    @Override
+    public CacheOption swapToObject(final YamlSQLFederationExecutionPlanCacheRuleConfiguration yamlConfig) {
+        return new CacheOption(yamlConfig.getInitialCapacity(), yamlConfig.getMaximumSize());
+    }
+}
diff --git a/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/swapper/YamlSQLFederationRuleConfigurationSwapper.java b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/swapper/YamlSQLFederationRuleConfigurationSwapper.java
new file mode 100644
index 00000000000..d1439c6d619
--- /dev/null
+++ b/kernel/sql-federation/core/src/main/java/org/apache/shardingsphere/sqlfederation/yaml/swapper/YamlSQLFederationRuleConfigurationSwapper.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.yaml.swapper;
+
+import org.apache.shardingsphere.infra.yaml.config.swapper.rule.YamlRuleConfigurationSwapper;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
+import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
+import org.apache.shardingsphere.sqlfederation.constant.SQLFederationOrder;
+import org.apache.shardingsphere.sqlfederation.yaml.config.YamlSQLFederationRuleConfiguration;
+
+/**
+ * YAML SQL federation rule configuration swapper.
+ */
+public final class YamlSQLFederationRuleConfigurationSwapper implements YamlRuleConfigurationSwapper<YamlSQLFederationRuleConfiguration, SQLFederationRuleConfiguration> {
+    
+    private final YamlSQLFederationExecutionPlanCacheConfigurationSwapper executionPlanCacheConfigSwapper = new YamlSQLFederationExecutionPlanCacheConfigurationSwapper();
+    
+    @Override
+    public YamlSQLFederationRuleConfiguration swapToYamlConfiguration(final SQLFederationRuleConfiguration data) {
+        YamlSQLFederationRuleConfiguration result = new YamlSQLFederationRuleConfiguration();
+        result.setSqlFederationEnabled(data.isSqlFederationEnabled());
+        result.setExecutionPlanCache(executionPlanCacheConfigSwapper.swapToYamlConfiguration(data.getExecutionPlanCache()));
+        return result;
+    }
+    
+    @Override
+    public SQLFederationRuleConfiguration swapToObject(final YamlSQLFederationRuleConfiguration yamlConfig) {
+        CacheOption executionPlanCacheConfig = executionPlanCacheConfigSwapper.swapToObject(yamlConfig.getExecutionPlanCache());
+        return new SQLFederationRuleConfiguration(yamlConfig.isSqlFederationEnabled(), executionPlanCacheConfig);
+    }
+    
+    @Override
+    public Class<SQLFederationRuleConfiguration> getTypeClass() {
+        return SQLFederationRuleConfiguration.class;
+    }
+    
+    @Override
+    public String getRuleTagName() {
+        return "SQL_FEDERATION";
+    }
+    
+    @Override
+    public int getOrder() {
+        return SQLFederationOrder.ORDER;
+    }
+}
diff --git a/kernel/sql-federation/core/src/main/resources/META-INF/services/org.apache.shardingsphere.infra.yaml.config.swapper.rule.YamlRuleConfigurationSwapper b/kernel/sql-federation/core/src/main/resources/META-INF/services/org.apache.shardingsphere.infra.yaml.config.swapper.rule.YamlRuleConfigurationSwapper
new file mode 100644
index 00000000000..b1f31235ee8
--- /dev/null
+++ b/kernel/sql-federation/core/src/main/resources/META-INF/services/org.apache.shardingsphere.infra.yaml.config.swapper.rule.YamlRuleConfigurationSwapper
@@ -0,0 +1,18 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+org.apache.shardingsphere.sqlfederation.yaml.swapper.YamlSQLFederationRuleConfigurationSwapper
diff --git a/kernel/sql-federation/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutor b/kernel/sql-federation/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutor
index 2f2bf7d5b24..3de4c495b37 100644
--- a/kernel/sql-federation/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutor
+++ b/kernel/sql-federation/core/src/main/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutor
@@ -15,4 +15,4 @@
 # limitations under the License.
 #
 
-org.apache.shardingsphere.sqlfederation.executor.resultset.AdvancedSQLFederationExecutor
+org.apache.shardingsphere.sqlfederation.executor.AdvancedSQLFederationExecutor
diff --git a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/engine/SQLFederationDecideEngineTest.java b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/engine/SQLFederationDecideEngineTest.java
new file mode 100644
index 00000000000..567637583af
--- /dev/null
+++ b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/engine/SQLFederationDecideEngineTest.java
@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.decider.engine;
+
+import org.apache.shardingsphere.infra.binder.statement.CommonSQLStatementContext;
+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
+import org.apache.shardingsphere.infra.database.DefaultDatabase;
+import org.apache.shardingsphere.infra.database.type.DatabaseType;
+import org.apache.shardingsphere.infra.database.type.dialect.MySQLDatabaseType;
+import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.resource.ShardingSphereResourceMetaData;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
+import org.apache.shardingsphere.infra.rule.ShardingSphereRule;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
+import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
+import org.apache.shardingsphere.sqlfederation.decider.SQLFederationDecideEngine;
+import org.apache.shardingsphere.sqlfederation.decider.fixture.rule.SQLFederationDeciderRuleMatchFixture;
+import org.apache.shardingsphere.sqlfederation.decider.fixture.rule.SQLFederationDeciderRuleNotMatchFixture;
+import org.apache.shardingsphere.sqlfederation.rule.SQLFederationRule;
+import org.junit.jupiter.api.Test;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+class SQLFederationDecideEngineTest {
+    
+    @Test
+    void assertDecideWhenSelectStatementContainsSystemSchema() {
+        SQLFederationDecideEngine engine = new SQLFederationDecideEngine(Collections.emptyList());
+        SelectStatementContext sqlStatementContext = mock(SelectStatementContext.class, RETURNS_DEEP_STUBS);
+        when(sqlStatementContext.getDatabaseType()).thenReturn(new MySQLDatabaseType());
+        when(sqlStatementContext.getTablesContext().getSchemaNames()).thenReturn(Collections.singletonList("information_schema"));
+        ShardingSphereDatabase database = new ShardingSphereDatabase(DefaultDatabase.LOGIC_NAME,
+                mock(DatabaseType.class), mock(ShardingSphereResourceMetaData.class, RETURNS_DEEP_STUBS), mock(ShardingSphereRuleMetaData.class), Collections.emptyMap());
+        assertTrue(engine.decide(sqlStatementContext, Collections.emptyList(), database, mock(ShardingSphereRuleMetaData.class)));
+    }
+    
+    @Test
+    void assertDecideWhenNotConfigSqlFederationEnabled() {
+        Collection<ShardingSphereRule> rules = Collections.singletonList(new SQLFederationRule(new SQLFederationRuleConfiguration(false, mock(CacheOption.class))));
+        SQLFederationDecideEngine engine = new SQLFederationDecideEngine(rules);
+        ShardingSphereDatabase database = new ShardingSphereDatabase(DefaultDatabase.LOGIC_NAME,
+                mock(DatabaseType.class), mock(ShardingSphereResourceMetaData.class, RETURNS_DEEP_STUBS), new ShardingSphereRuleMetaData(rules), Collections.emptyMap());
+        ShardingSphereRuleMetaData globalRuleMetaData = new ShardingSphereRuleMetaData(rules);
+        assertFalse(engine.decide(mock(CommonSQLStatementContext.class), Collections.emptyList(), database, globalRuleMetaData));
+    }
+    
+    @Test
+    void assertDecideWhenExecuteNotSelectStatement() {
+        Collection<ShardingSphereRule> rules = Collections.singletonList(new SQLFederationRule(new SQLFederationRuleConfiguration(true, mock(CacheOption.class))));
+        SQLFederationDecideEngine engine = new SQLFederationDecideEngine(rules);
+        ShardingSphereDatabase database = new ShardingSphereDatabase(DefaultDatabase.LOGIC_NAME,
+                mock(DatabaseType.class), mock(ShardingSphereResourceMetaData.class, RETURNS_DEEP_STUBS), new ShardingSphereRuleMetaData(rules), Collections.emptyMap());
+        ShardingSphereRuleMetaData globalRuleMetaData = new ShardingSphereRuleMetaData(rules);
+        assertFalse(engine.decide(mock(CommonSQLStatementContext.class), Collections.emptyList(), database, globalRuleMetaData));
+    }
+    
+    @Test
+    void assertDecideWhenConfigSingleMatchedRule() {
+        Collection<ShardingSphereRule> rules = Arrays.asList(new SQLFederationRule(new SQLFederationRuleConfiguration(true, mock(CacheOption.class))), new SQLFederationDeciderRuleMatchFixture());
+        SQLFederationDecideEngine engine = new SQLFederationDecideEngine(rules);
+        ShardingSphereDatabase database = new ShardingSphereDatabase(DefaultDatabase.LOGIC_NAME,
+                mock(DatabaseType.class), mock(ShardingSphereResourceMetaData.class, RETURNS_DEEP_STUBS), new ShardingSphereRuleMetaData(rules), Collections.emptyMap());
+        ShardingSphereRuleMetaData globalRuleMetaData = new ShardingSphereRuleMetaData(rules);
+        assertTrue(engine.decide(mock(SelectStatementContext.class, RETURNS_DEEP_STUBS), Collections.emptyList(), database, globalRuleMetaData));
+    }
+    
+    @Test
+    void assertDecideWhenConfigSingleNotMatchedRule() {
+        Collection<ShardingSphereRule> rules = Arrays.asList(new SQLFederationRule(new SQLFederationRuleConfiguration(true, mock(CacheOption.class))), new SQLFederationDeciderRuleNotMatchFixture());
+        SQLFederationDecideEngine engine = new SQLFederationDecideEngine(rules);
+        ShardingSphereDatabase database = new ShardingSphereDatabase(DefaultDatabase.LOGIC_NAME,
+                mock(DatabaseType.class), mock(ShardingSphereResourceMetaData.class, RETURNS_DEEP_STUBS), new ShardingSphereRuleMetaData(rules), Collections.emptyMap());
+        ShardingSphereRuleMetaData globalRuleMetaData = new ShardingSphereRuleMetaData(rules);
+        assertFalse(engine.decide(mock(SelectStatementContext.class, RETURNS_DEEP_STUBS), Collections.emptyList(), database, globalRuleMetaData));
+    }
+    
+    @Test
+    void assertDecideWhenConfigMultiRule() {
+        Collection<ShardingSphereRule> rules = Arrays.asList(new SQLFederationRule(new SQLFederationRuleConfiguration(true, mock(CacheOption.class))), new SQLFederationDeciderRuleNotMatchFixture(),
+                new SQLFederationDeciderRuleMatchFixture());
+        SQLFederationDecideEngine engine = new SQLFederationDecideEngine(rules);
+        ShardingSphereDatabase database = new ShardingSphereDatabase(DefaultDatabase.LOGIC_NAME,
+                mock(DatabaseType.class), mock(ShardingSphereResourceMetaData.class, RETURNS_DEEP_STUBS), new ShardingSphereRuleMetaData(rules), Collections.emptyMap());
+        ShardingSphereRuleMetaData globalRuleMetaData = new ShardingSphereRuleMetaData(rules);
+        assertTrue(engine.decide(mock(SelectStatementContext.class, RETURNS_DEEP_STUBS), Collections.emptyList(), database, globalRuleMetaData));
+    }
+}
diff --git a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/decider/SQLFederationDeciderMatchFixture.java b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/decider/SQLFederationDeciderMatchFixture.java
new file mode 100644
index 00000000000..83ea8483fab
--- /dev/null
+++ b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/decider/SQLFederationDeciderMatchFixture.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.decider.fixture.decider;
+
+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
+import org.apache.shardingsphere.infra.datanode.DataNode;
+import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
+import org.apache.shardingsphere.sqlfederation.decider.fixture.rule.SQLFederationDeciderRuleMatchFixture;
+import org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider;
+
+import java.util.Collection;
+import java.util.List;
+
+public final class SQLFederationDeciderMatchFixture implements SQLFederationDecider<SQLFederationDeciderRuleMatchFixture> {
+    
+    @Override
+    public boolean decide(final SelectStatementContext selectStatementContext, final List<Object> parameters, final ShardingSphereRuleMetaData globalRuleMetaData,
+                          final ShardingSphereDatabase database, final SQLFederationDeciderRuleMatchFixture rule, final Collection<DataNode> includedDataNodes) {
+        return true;
+    }
+    
+    @Override
+    public int getOrder() {
+        return 0;
+    }
+    
+    @Override
+    public Class<SQLFederationDeciderRuleMatchFixture> getTypeClass() {
+        return SQLFederationDeciderRuleMatchFixture.class;
+    }
+}
diff --git a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/decider/SQLFederationDeciderNotMatchFixture.java b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/decider/SQLFederationDeciderNotMatchFixture.java
new file mode 100644
index 00000000000..144ad281fbf
--- /dev/null
+++ b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/decider/SQLFederationDeciderNotMatchFixture.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.decider.fixture.decider;
+
+import org.apache.shardingsphere.sqlfederation.decider.fixture.rule.SQLFederationDeciderRuleNotMatchFixture;
+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
+import org.apache.shardingsphere.infra.datanode.DataNode;
+import org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
+import org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider;
+
+import java.util.Collection;
+import java.util.List;
+
+public final class SQLFederationDeciderNotMatchFixture implements SQLFederationDecider<SQLFederationDeciderRuleNotMatchFixture> {
+    
+    @Override
+    public boolean decide(final SelectStatementContext selectStatementContext, final List<Object> parameters, final ShardingSphereRuleMetaData globalRuleMetaData,
+                          final ShardingSphereDatabase database, final SQLFederationDeciderRuleNotMatchFixture rule, final Collection<DataNode> includedDataNodes) {
+        return false;
+    }
+    
+    @Override
+    public int getOrder() {
+        return 10;
+    }
+    
+    @Override
+    public Class<SQLFederationDeciderRuleNotMatchFixture> getTypeClass() {
+        return SQLFederationDeciderRuleNotMatchFixture.class;
+    }
+}
diff --git a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/rule/SQLFederationDeciderRuleMatchFixture.java b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/rule/SQLFederationDeciderRuleMatchFixture.java
new file mode 100644
index 00000000000..140182978ef
--- /dev/null
+++ b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/rule/SQLFederationDeciderRuleMatchFixture.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.decider.fixture.rule;
+
+import org.apache.shardingsphere.infra.config.rule.RuleConfiguration;
+import org.apache.shardingsphere.infra.rule.ShardingSphereRule;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
+import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
+
+import static org.mockito.Mockito.mock;
+
+public final class SQLFederationDeciderRuleMatchFixture implements ShardingSphereRule {
+    
+    @Override
+    public RuleConfiguration getConfiguration() {
+        return new SQLFederationRuleConfiguration(true, mock(CacheOption.class));
+    }
+    
+    @Override
+    public String getType() {
+        return SQLFederationDeciderRuleMatchFixture.class.getSimpleName();
+    }
+}
diff --git a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/rule/SQLFederationDeciderRuleNotMatchFixture.java b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/rule/SQLFederationDeciderRuleNotMatchFixture.java
new file mode 100644
index 00000000000..e20ae778db8
--- /dev/null
+++ b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/decider/fixture/rule/SQLFederationDeciderRuleNotMatchFixture.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.sqlfederation.decider.fixture.rule;
+
+import org.apache.shardingsphere.infra.config.rule.RuleConfiguration;
+import org.apache.shardingsphere.infra.rule.ShardingSphereRule;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
+import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
+
+import static org.mockito.Mockito.mock;
+
+public final class SQLFederationDeciderRuleNotMatchFixture implements ShardingSphereRule {
+    
+    @Override
+    public RuleConfiguration getConfiguration() {
+        return new SQLFederationRuleConfiguration(false, mock(CacheOption.class));
+    }
+    
+    @Override
+    public String getType() {
+        return SQLFederationDeciderRuleNotMatchFixture.class.getSimpleName();
+    }
+}
diff --git a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/executor/FilterableTableScanExecutorTest.java b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/executor/FilterableTableScanExecutorTest.java
index 84f4837dafb..d6c6b70c0ca 100644
--- a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/executor/FilterableTableScanExecutorTest.java
+++ b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/executor/FilterableTableScanExecutorTest.java
@@ -58,11 +58,12 @@ class FilterableTableScanExecutorTest {
         when(schemaData.getTableData().get("test")).thenReturn(tableData);
         ShardingSphereTable shardingSphereTable = mock(ShardingSphereTable.class);
         when(shardingSphereTable.getName()).thenReturn("test");
-        Enumerable<Object[]> enumerable = new FilterableTableScanExecutor(null, null, null, optimizerContext, null, executorContext, shardingSphereData)
+        Enumerable<Object[]> enumerable = new TranslatableTableScanExecutor(null, null, null, optimizerContext, null, executorContext, shardingSphereData)
                 .execute(shardingSphereTable, Mockito.mock(ScanNodeExecutorContext.class));
-        Enumerator<Object[]> actual = enumerable.enumerator();
-        actual.moveNext();
-        Object[] row = actual.current();
-        assertThat(row[0], is(1));
+        try (Enumerator<Object[]> actual = enumerable.enumerator()) {
+            actual.moveNext();
+            Object[] row = actual.current();
+            assertThat(row[0], is(1));
+        }
     }
 }
diff --git a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/executor/result/SQLFederationResultSetTest.java b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/executor/result/SQLFederationResultSetTest.java
index 67f137f469f..a5a50c60c1a 100644
--- a/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/executor/result/SQLFederationResultSetTest.java
+++ b/kernel/sql-federation/core/src/test/java/org/apache/shardingsphere/sqlfederation/executor/result/SQLFederationResultSetTest.java
@@ -25,7 +25,7 @@ import org.apache.shardingsphere.infra.binder.segment.table.TablesContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
 import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereSchema;
 import org.apache.shardingsphere.sqlfederation.executor.resultset.SQLFederationResultSet;
-import org.apache.shardingsphere.sqlfederation.optimizer.metadata.filter.FilterableSchema;
+import org.apache.shardingsphere.sqlfederation.optimizer.metadata.translatable.TranslatableSchema;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
@@ -69,8 +69,7 @@ class SQLFederationResultSetTest {
     @BeforeEach
     void setUp() {
         enumerator = createEnumerator();
-        federationResultSet =
-                new SQLFederationResultSet(enumerator, mock(ShardingSphereSchema.class), Mockito.mock(FilterableSchema.class), createSelectStatementContext(), Mockito.mock(RelDataType.class));
+        federationResultSet = new SQLFederationResultSet(enumerator, mock(ShardingSphereSchema.class), mock(TranslatableSchema.class), createSelectStatementContext(), mock(RelDataType.class));
     }
     
     private SelectStatementContext createSelectStatementContext() {
diff --git a/kernel/sql-federation/core/src/test/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider b/kernel/sql-federation/core/src/test/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider
new file mode 100644
index 00000000000..ee4e53ac1e9
--- /dev/null
+++ b/kernel/sql-federation/core/src/test/resources/META-INF/services/org.apache.shardingsphere.sqlfederation.spi.SQLFederationDecider
@@ -0,0 +1,19 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+org.apache.shardingsphere.sqlfederation.decider.fixture.decider.SQLFederationDeciderMatchFixture
+org.apache.shardingsphere.sqlfederation.decider.fixture.decider.SQLFederationDeciderNotMatchFixture
diff --git a/mode/type/cluster/core/src/main/java/org/apache/shardingsphere/mode/manager/cluster/coordinator/registry/metadata/watcher/NewMetaDataChangedWatcher.java b/mode/type/cluster/core/src/main/java/org/apache/shardingsphere/mode/manager/cluster/coordinator/registry/metadata/watcher/NewMetaDataChangedWatcher.java
index 74e81e9b50d..3918cd4d0d6 100644
--- a/mode/type/cluster/core/src/main/java/org/apache/shardingsphere/mode/manager/cluster/coordinator/registry/metadata/watcher/NewMetaDataChangedWatcher.java
+++ b/mode/type/cluster/core/src/main/java/org/apache/shardingsphere/mode/manager/cluster/coordinator/registry/metadata/watcher/NewMetaDataChangedWatcher.java
@@ -57,7 +57,7 @@ public final class NewMetaDataChangedWatcher implements NewGovernanceWatcher<Gov
     
     // TODO Change to map to avoid loops.
     private Optional<GovernanceEvent> createRuleEvent(final DataChangedEvent event) {
-        Optional<String> databaseName = NewDatabaseMetaDataNode.getDatabaseNameByPath(event.getKey());
+        Optional<String> databaseName = NewDatabaseMetaDataNode.getDatabaseNameByNode(event.getKey());
         if (!databaseName.isPresent()) {
             return Optional.empty();
         }
diff --git a/parser/sql/dialect/oracle/src/main/antlr4/imports/oracle/Literals.g4 b/parser/sql/dialect/oracle/src/main/antlr4/imports/oracle/Literals.g4
index 0c6bab17d54..f7b377bf107 100644
--- a/parser/sql/dialect/oracle/src/main/antlr4/imports/oracle/Literals.g4
+++ b/parser/sql/dialect/oracle/src/main/antlr4/imports/oracle/Literals.g4
@@ -20,7 +20,7 @@ lexer grammar Literals;
 import Alphabet, Symbol;
 
 IDENTIFIER_
-    : [A-Za-z\u0080-\uFFFF]+[A-Za-z_$#0-9\u0080-\uFFFF]*
+    : [A-Za-z\u0080-\uFF0B\uFF0D-\uFFFF]+[A-Za-z_$#0-9\u0080-\uFF0B\uFF0D-\uFFFF]*
     |  DQ_ ~'"'+ DQ_
     ;
 
diff --git a/parser/sql/dialect/oracle/src/main/antlr4/imports/oracle/Symbol.g4 b/parser/sql/dialect/oracle/src/main/antlr4/imports/oracle/Symbol.g4
index 23b44adf82d..4b3ebb9255a 100644
--- a/parser/sql/dialect/oracle/src/main/antlr4/imports/oracle/Symbol.g4
+++ b/parser/sql/dialect/oracle/src/main/antlr4/imports/oracle/Symbol.g4
@@ -50,7 +50,7 @@ LBE_:                '{';
 RBE_:                '}';
 LBT_:                '[';
 RBT_:                ']';
-COMMA_:              ',';
+COMMA_:              ',' | '\uFF0C';
 DQ_:                 '"';
 SQ_ :                '\'';
 BQ_:                 '`';
diff --git a/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/config/ProxyConfigurationLoader.java b/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/config/ProxyConfigurationLoader.java
index c4376ba43f4..ea285a65f3f 100644
--- a/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/config/ProxyConfigurationLoader.java
+++ b/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/config/ProxyConfigurationLoader.java
@@ -103,6 +103,9 @@ public final class ProxyConfigurationLoader {
         if (null != serverConfiguration.getLogging()) {
             serverConfiguration.getRules().add(serverConfiguration.getLogging());
         }
+        if (null != serverConfiguration.getSqlFederation()) {
+            serverConfiguration.getRules().add(serverConfiguration.getSqlFederation());
+        }
         return serverConfiguration;
     }
     
diff --git a/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/config/yaml/YamlProxyServerConfiguration.java b/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/config/yaml/YamlProxyServerConfiguration.java
index 2c2b268aca1..8556031b144 100644
--- a/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/config/yaml/YamlProxyServerConfiguration.java
+++ b/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/config/yaml/YamlProxyServerConfiguration.java
@@ -26,6 +26,7 @@ import org.apache.shardingsphere.infra.yaml.config.pojo.mode.YamlModeConfigurati
 import org.apache.shardingsphere.infra.yaml.config.pojo.rule.YamlRuleConfiguration;
 import org.apache.shardingsphere.logging.yaml.config.YamlLoggingRuleConfiguration;
 import org.apache.shardingsphere.parser.yaml.config.YamlSQLParserRuleConfiguration;
+import org.apache.shardingsphere.sqlfederation.yaml.config.YamlSQLFederationRuleConfiguration;
 import org.apache.shardingsphere.sqltranslator.yaml.config.YamlSQLTranslatorRuleConfiguration;
 import org.apache.shardingsphere.traffic.yaml.config.YamlTrafficRuleConfiguration;
 import org.apache.shardingsphere.transaction.yaml.config.YamlTransactionRuleConfiguration;
@@ -57,6 +58,8 @@ public final class YamlProxyServerConfiguration implements YamlConfiguration {
     
     private YamlGlobalClockRuleConfiguration globalClock;
     
+    private YamlSQLFederationRuleConfiguration sqlFederation;
+    
     private Collection<YamlRuleConfiguration> rules = new LinkedList<>();
     
     private Properties props = new Properties();
diff --git a/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/connector/DatabaseConnector.java b/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/connector/DatabaseConnector.java
index 154b95fa9f7..17c8acbdefc 100644
--- a/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/connector/DatabaseConnector.java
+++ b/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/connector/DatabaseConnector.java
@@ -20,7 +20,7 @@ package org.apache.shardingsphere.proxy.backend.connector;
 import com.google.common.base.Preconditions;
 import org.apache.shardingsphere.dialect.SQLExceptionTransformEngine;
 import org.apache.shardingsphere.infra.binder.aware.CursorDefinitionAware;
-import org.apache.shardingsphere.infra.binder.decider.SQLFederationDecideEngine;
+import org.apache.shardingsphere.sqlfederation.decider.SQLFederationDecideEngine;
 import org.apache.shardingsphere.infra.binder.segment.insert.keygen.GeneratedKeyContext;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.ddl.CloseStatementContext;
@@ -202,7 +202,7 @@ public final class DatabaseConnector implements DatabaseBackendHandler {
     @Override
     public ResponseHeader execute() throws SQLException {
         MetaDataContexts metaDataContexts = ProxyContext.getInstance().getContextManager().getMetaDataContexts();
-        if (new SQLFederationDecideEngine(database.getRuleMetaData().getRules(), metaDataContexts.getMetaData().getProps())
+        if (new SQLFederationDecideEngine(database.getRuleMetaData().getRules())
                 .decide(queryContext.getSqlStatementContext(), queryContext.getParameters(), database, metaDataContexts.getMetaData().getGlobalRuleMetaData())) {
             prepareFederationExecutor();
             ResultSet resultSet = doExecuteFederation(queryContext, metaDataContexts);
diff --git a/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/handler/distsql/rul/sql/PreviewExecutor.java b/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/handler/distsql/rul/sql/PreviewExecutor.java
index 26b50950878..aa3fac5897d 100644
--- a/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/handler/distsql/rul/sql/PreviewExecutor.java
+++ b/proxy/backend/core/src/main/java/org/apache/shardingsphere/proxy/backend/handler/distsql/rul/sql/PreviewExecutor.java
@@ -24,7 +24,7 @@ import org.apache.shardingsphere.dialect.exception.syntax.database.UnknownDataba
 import org.apache.shardingsphere.distsql.parser.statement.rul.sql.PreviewStatement;
 import org.apache.shardingsphere.infra.binder.SQLStatementContextFactory;
 import org.apache.shardingsphere.infra.binder.aware.CursorDefinitionAware;
-import org.apache.shardingsphere.infra.binder.decider.SQLFederationDecideEngine;
+import org.apache.shardingsphere.sqlfederation.decider.SQLFederationDecideEngine;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.ddl.CursorStatementContext;
 import org.apache.shardingsphere.infra.binder.type.CursorAvailable;
@@ -103,7 +103,7 @@ public final class PreviewExecutor implements ConnectionSessionRequiredRULExecut
         ShardingSphereDatabase database = ProxyContext.getInstance().getDatabase(connectionSession.getDatabaseName());
         ShardingSpherePreconditions.checkState(database.isComplete(), () -> new RuleNotExistedException(connectionSession.getDatabaseName()));
         ConfigurationProperties props = metaDataContexts.getMetaData().getProps();
-        Collection<ExecutionUnit> executionUnits = isUseFederation(queryContext, database, metaDataContexts, props, connectionSession)
+        Collection<ExecutionUnit> executionUnits = isUseFederation(queryContext, database, metaDataContexts, connectionSession)
                 ? getFederationExecutionUnits(queryContext, databaseName, metaDataContexts, connectionSession)
                 : kernelProcessor.generateExecutionContext(queryContext, database, globalRuleMetaData, props, connectionSession.getConnectionContext()).getExecutionUnits();
         return executionUnits.stream().map(this::buildRow).collect(Collectors.toList());
@@ -119,9 +119,9 @@ public final class PreviewExecutor implements ConnectionSessionRequiredRULExecut
         ((CursorDefinitionAware) sqlStatementContext).setUpCursorDefinition(cursorStatementContext);
     }
     
-    private boolean isUseFederation(final QueryContext queryContext, final ShardingSphereDatabase database, final MetaDataContexts metaDataContexts, final ConfigurationProperties props,
+    private boolean isUseFederation(final QueryContext queryContext, final ShardingSphereDatabase database, final MetaDataContexts metaDataContexts,
                                     final ConnectionSession connectionSession) {
-        SQLFederationDecideEngine engine = new SQLFederationDecideEngine(database.getRuleMetaData().getRules(), props);
+        SQLFederationDecideEngine engine = new SQLFederationDecideEngine(database.getRuleMetaData().getRules());
         return engine.decide(queryContext.getSqlStatementContext(), queryContext.getParameters(),
                 metaDataContexts.getMetaData().getDatabase(connectionSession.getDatabaseName()), metaDataContexts.getMetaData().getGlobalRuleMetaData());
     }
diff --git a/proxy/backend/core/src/test/java/org/apache/shardingsphere/proxy/backend/connector/DatabaseConnectorTest.java b/proxy/backend/core/src/test/java/org/apache/shardingsphere/proxy/backend/connector/DatabaseConnectorTest.java
index cb22893d472..36418de2b50 100644
--- a/proxy/backend/core/src/test/java/org/apache/shardingsphere/proxy/backend/connector/DatabaseConnectorTest.java
+++ b/proxy/backend/core/src/test/java/org/apache/shardingsphere/proxy/backend/connector/DatabaseConnectorTest.java
@@ -18,7 +18,6 @@
 package org.apache.shardingsphere.proxy.backend.connector;
 
 import lombok.SneakyThrows;
-import org.apache.shardingsphere.infra.session.query.QueryContext;
 import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;
 import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;
 import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
@@ -40,10 +39,13 @@ import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSp
 import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereTable;
 import org.apache.shardingsphere.infra.metadata.database.schema.util.SystemSchemaUtils;
 import org.apache.shardingsphere.infra.rule.ShardingSphereRule;
+import org.apache.shardingsphere.infra.session.query.QueryContext;
 import org.apache.shardingsphere.infra.util.spi.type.typed.TypedSPILoader;
 import org.apache.shardingsphere.metadata.persist.MetaDataPersistService;
 import org.apache.shardingsphere.mode.manager.ContextManager;
 import org.apache.shardingsphere.mode.metadata.MetaDataContexts;
+import org.apache.shardingsphere.parser.config.SQLParserRuleConfiguration;
+import org.apache.shardingsphere.parser.rule.SQLParserRule;
 import org.apache.shardingsphere.proxy.backend.connector.jdbc.executor.callback.ProxyJDBCExecutorCallback;
 import org.apache.shardingsphere.proxy.backend.connector.jdbc.fixture.QueryHeaderBuilderFixture;
 import org.apache.shardingsphere.proxy.backend.connector.jdbc.statement.JDBCBackendStatement;
@@ -52,7 +54,9 @@ import org.apache.shardingsphere.proxy.backend.response.data.QueryResponseRow;
 import org.apache.shardingsphere.proxy.backend.response.header.query.QueryHeaderBuilder;
 import org.apache.shardingsphere.proxy.backend.response.header.query.QueryHeaderBuilderEngine;
 import org.apache.shardingsphere.sharding.rule.ShardingRule;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
 import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
+import org.apache.shardingsphere.sqlfederation.optimizer.context.parser.dialect.OptimizerSQLDialectBuilder;
 import org.apache.shardingsphere.sqlfederation.rule.SQLFederationRule;
 import org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutor;
 import org.apache.shardingsphere.sqlfederation.spi.SQLFederationExecutorContext;
@@ -72,6 +76,7 @@ import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.sql.Types;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -115,7 +120,9 @@ class DatabaseConnectorTest {
     }
     
     private ContextManager mockContextManager() {
-        ShardingSphereRuleMetaData globalRuleMetaData = new ShardingSphereRuleMetaData(Collections.singleton(new SQLFederationRule(new SQLFederationRuleConfiguration("ORIGINAL"))));
+        ShardingSphereRuleMetaData globalRuleMetaData =
+                new ShardingSphereRuleMetaData(Arrays.asList(new SQLParserRule(new SQLParserRuleConfiguration(false, mock(CacheOption.class), mock(CacheOption.class))),
+                        new SQLFederationRule(new SQLFederationRuleConfiguration(true, mock(CacheOption.class)))));
         MetaDataContexts metaDataContexts = new MetaDataContexts(mock(MetaDataPersistService.class),
                 new ShardingSphereMetaData(mockDatabases(), globalRuleMetaData, new ConfigurationProperties(new Properties())));
         ContextManager result = mock(ContextManager.class, RETURNS_DEEP_STUBS);
@@ -143,12 +150,14 @@ class DatabaseConnectorTest {
         SQLFederationExecutor federationExecutor = mock(SQLFederationExecutor.class);
         when(SystemSchemaUtils.containsSystemSchema(any(DatabaseType.class), any(), any(ShardingSphereDatabase.class))).thenReturn(true);
         try (MockedStatic<TypedSPILoader> typedSPILoader = mockStatic(TypedSPILoader.class)) {
+            typedSPILoader.when(() -> TypedSPILoader.getService(SQLFederationExecutor.class, "ADVANCED")).thenReturn(federationExecutor);
+            typedSPILoader.when(() -> TypedSPILoader.getService(QueryHeaderBuilder.class, "H2")).thenReturn(new QueryHeaderBuilderFixture());
+            typedSPILoader.when(() -> TypedSPILoader.getService(OptimizerSQLDialectBuilder.class, "MySQL")).thenReturn(mock(OptimizerSQLDialectBuilder.class));
+            typedSPILoader.when(() -> TypedSPILoader.getService(DatabaseType.class, "H2")).thenReturn(new MySQLDatabaseType());
             when(federationExecutor.executeQuery(any(DriverExecutionPrepareEngine.class), any(ProxyJDBCExecutorCallback.class), any(SQLFederationExecutorContext.class))).thenReturn(resultSet);
             when(resultSet.getMetaData().getColumnCount()).thenReturn(1);
             when(resultSet.next()).thenReturn(true, false);
             when(resultSet.getObject(1)).thenReturn(Integer.MAX_VALUE);
-            typedSPILoader.when(() -> TypedSPILoader.getService(SQLFederationExecutor.class, "NONE")).thenReturn(federationExecutor);
-            typedSPILoader.when(() -> TypedSPILoader.getService(QueryHeaderBuilder.class, "H2")).thenReturn(new QueryHeaderBuilderFixture());
             engine.execute();
         }
         assertTrue(engine.next());
diff --git a/proxy/backend/core/src/test/java/org/apache/shardingsphere/proxy/backend/handler/distsql/ral/queryable/ShowDistVariablesExecutorTest.java b/proxy/backend/core/src/test/java/org/apache/shardingsphere/proxy/backend/handler/distsql/ral/queryable/ShowDistVariablesExecutorTest.java
index dba70c81fff..c7e4fa5a746 100644
--- a/proxy/backend/core/src/test/java/org/apache/shardingsphere/proxy/backend/handler/distsql/ral/queryable/ShowDistVariablesExecutorTest.java
+++ b/proxy/backend/core/src/test/java/org/apache/shardingsphere/proxy/backend/handler/distsql/ral/queryable/ShowDistVariablesExecutorTest.java
@@ -63,7 +63,7 @@ class ShowDistVariablesExecutorTest {
         when(metaData.getGlobalRuleMetaData()).thenReturn(new ShardingSphereRuleMetaData(Collections.singleton(new LoggingRule(new DefaultLoggingRuleConfigurationBuilder().build()))));
         ShowDistVariablesExecutor executor = new ShowDistVariablesExecutor();
         Collection<LocalDataQueryResultRow> actual = executor.getRows(metaData, connectionSession, mock(ShowDistVariablesStatement.class));
-        assertThat(actual.size(), is(21));
+        assertThat(actual.size(), is(20));
         LocalDataQueryResultRow row = actual.iterator().next();
         assertThat(row.getCell(1), is("agent_plugins_enabled"));
         assertThat(row.getCell(2), is("true"));
@@ -76,9 +76,8 @@ class ShowDistVariablesExecutorTest {
         when(metaData.getGlobalRuleMetaData()).thenReturn(new ShardingSphereRuleMetaData(Collections.singleton(new LoggingRule(new DefaultLoggingRuleConfigurationBuilder().build()))));
         ShowDistVariablesExecutor executor = new ShowDistVariablesExecutor();
         Collection<LocalDataQueryResultRow> actual = executor.getRows(metaData, connectionSession, new ShowDistVariablesStatement("sql_%"));
-        assertThat(actual.size(), is(3));
+        assertThat(actual.size(), is(2));
         Iterator<LocalDataQueryResultRow> iterator = actual.iterator();
-        assertThat(iterator.next().getCell(1), is("sql_federation_type"));
         assertThat(iterator.next().getCell(1), is("sql_show"));
         assertThat(iterator.next().getCell(1), is("sql_simple"));
     }
diff --git a/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussAdminExecutorCreator.java b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussAdminExecutorCreator.java
index 6fd41372ee3..9cd59d4e757 100644
--- a/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussAdminExecutorCreator.java
+++ b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussAdminExecutorCreator.java
@@ -38,14 +38,17 @@ public final class OpenGaussAdminExecutorCreator implements DatabaseAdminExecuto
     
     private static final Set<String> SYSTEM_CATALOG_QUERY_EXPRESSIONS = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
     
+    private static final Set<String> SYSTEM_CATALOG_TABLES = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+    
     static {
         SYSTEM_CATALOG_QUERY_EXPRESSIONS.add("VERSION()");
         SYSTEM_CATALOG_QUERY_EXPRESSIONS.add("intervaltonum(gs_password_deadline())");
         SYSTEM_CATALOG_QUERY_EXPRESSIONS.add("gs_password_notifytime()");
+        SYSTEM_CATALOG_TABLES.add("pg_database");
+        SYSTEM_CATALOG_TABLES.add("pg_tables");
+        SYSTEM_CATALOG_TABLES.add("pg_roles");
     }
     
-    private static final String OG_DATABASE = "pg_database";
-    
     private final PostgreSQLAdminExecutorCreator delegated = new PostgreSQLAdminExecutorCreator();
     
     @Override
@@ -62,7 +65,7 @@ public final class OpenGaussAdminExecutorCreator implements DatabaseAdminExecuto
     }
     
     private boolean isSystemCatalogQuery(final SQLStatementContext sqlStatementContext) {
-        if (sqlStatementContext.getTablesContext().getTableNames().contains(OG_DATABASE)) {
+        if (sqlStatementContext.getTablesContext().getTableNames().stream().anyMatch(SYSTEM_CATALOG_TABLES::contains)) {
             return true;
         }
         if (!(sqlStatementContext.getSqlStatement() instanceof SelectStatement)) {
diff --git a/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutor.java b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutor.java
index d8e3f034fa5..94eecefd513 100644
--- a/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutor.java
+++ b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutor.java
@@ -21,15 +21,20 @@ import lombok.Getter;
 import org.apache.calcite.adapter.java.ReflectiveSchema;
 import org.apache.calcite.jdbc.CalciteConnection;
 import org.apache.calcite.schema.impl.ScalarFunctionImpl;
+import org.apache.shardingsphere.authority.rule.AuthorityRule;
 import org.apache.shardingsphere.infra.autogen.version.ShardingSphereVersion;
 import org.apache.shardingsphere.infra.executor.sql.execute.result.query.QueryResultMetaData;
 import org.apache.shardingsphere.infra.executor.sql.execute.result.query.impl.driver.jdbc.metadata.JDBCQueryResultMetaData;
 import org.apache.shardingsphere.infra.executor.sql.execute.result.query.impl.driver.jdbc.type.memory.JDBCMemoryQueryResult;
 import org.apache.shardingsphere.infra.merge.result.MergedResult;
+import org.apache.shardingsphere.infra.metadata.database.schema.builder.SystemSchemaBuilderRule;
+import org.apache.shardingsphere.infra.metadata.database.schema.model.ShardingSphereSchema;
 import org.apache.shardingsphere.proxy.backend.context.ProxyContext;
 import org.apache.shardingsphere.proxy.backend.handler.admin.executor.DatabaseAdminQueryExecutor;
 import org.apache.shardingsphere.proxy.backend.opengauss.handler.admin.schema.OpenGaussDatabase;
+import org.apache.shardingsphere.proxy.backend.opengauss.handler.admin.schema.OpenGaussRoles;
 import org.apache.shardingsphere.proxy.backend.opengauss.handler.admin.schema.OpenGaussSystemCatalog;
+import org.apache.shardingsphere.proxy.backend.opengauss.handler.admin.schema.OpenGaussTables;
 import org.apache.shardingsphere.proxy.backend.session.ConnectionSession;
 import org.apache.shardingsphere.sharding.merge.common.IteratorStreamMergedResult;
 import org.apache.shardingsphere.sql.parser.sql.common.util.SQLUtils;
@@ -41,6 +46,10 @@ import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.stream.Collectors;
 
 /**
  * Select database executor for openGauss.
@@ -88,11 +97,23 @@ public final class OpenGaussSystemCatalogAdminQueryExecutor implements DatabaseA
     private OpenGaussSystemCatalog constructOgCatalog() {
         Collection<String> allDatabaseNames = ProxyContext.getInstance().getAllDatabaseNames();
         OpenGaussDatabase[] openGaussDatabases = new OpenGaussDatabase[allDatabaseNames.size()];
-        int i = 0;
+        List<OpenGaussTables> openGaussTables = new LinkedList<>();
+        List<OpenGaussRoles> openGaussRoles = new LinkedList<>();
+        ProxyContext.getInstance().getContextManager().getMetaDataContexts().getMetaData().getGlobalRuleMetaData().getSingleRule(AuthorityRule.class)
+                .getConfiguration().getUsers().stream().map(user -> user.getGrantee().getUsername())
+                .forEach(userName -> openGaussRoles.add(new OpenGaussRoles(userName)));
+        int index = 0;
         for (String each : allDatabaseNames) {
-            openGaussDatabases[i++] = new OpenGaussDatabase(each, DAT_COMPATIBILITY);
+            for (Entry<String, ShardingSphereSchema> entry : ProxyContext.getInstance().getDatabase(each).getSchemas().entrySet()) {
+                for (String tableName : entry.getValue().getAllTableNames()) {
+                    openGaussTables.add(new OpenGaussTables(entry.getKey(), tableName));
+                }
+            }
+            openGaussDatabases[index++] = new OpenGaussDatabase(each, DAT_COMPATIBILITY);
         }
-        return new OpenGaussSystemCatalog(openGaussDatabases);
+        openGaussTables.addAll(SystemSchemaBuilderRule.OPEN_GAUSS_PG_CATALOG.getTables().stream().map(tableName -> new OpenGaussTables(PG_CATALOG, tableName)).collect(Collectors.toSet()));
+        openGaussTables.addAll(SystemSchemaBuilderRule.POSTGRESQL_PG_CATALOG.getTables().stream().map(tableName -> new OpenGaussTables(PG_CATALOG, tableName)).collect(Collectors.toSet()));
+        return new OpenGaussSystemCatalog(openGaussDatabases, openGaussTables.toArray(new OpenGaussTables[0]), openGaussRoles.toArray(new OpenGaussRoles[0]));
     }
     
     /**
diff --git a/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussRoles.java b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussRoles.java
new file mode 100644
index 00000000000..e8bdd04d34a
--- /dev/null
+++ b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussRoles.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.proxy.backend.opengauss.handler.admin.schema;
+
+import lombok.EqualsAndHashCode;
+import lombok.RequiredArgsConstructor;
+
+/**
+ * System table which maintains tables in openGauss system catalog schema.
+ */
+@EqualsAndHashCode
+@RequiredArgsConstructor
+public final class OpenGaussRoles {
+    
+    // CHECKSTYLE:OFF
+    public final String rolname;
+    // CHECKSTYLE:ON
+}
diff --git a/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussSystemCatalog.java b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussSystemCatalog.java
index 73e01f61bd0..5912bd4c247 100644
--- a/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussSystemCatalog.java
+++ b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussSystemCatalog.java
@@ -28,5 +28,9 @@ public final class OpenGaussSystemCatalog {
     
     // CHECKSTYLE:OFF
     public final OpenGaussDatabase[] pg_database;
+    
+    public final OpenGaussTables[] pg_tables;
+    
+    public final OpenGaussRoles[] pg_roles;
     // CHECKSTYLE:ON
 }
diff --git a/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussTables.java b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussTables.java
new file mode 100644
index 00000000000..fb853ff2579
--- /dev/null
+++ b/proxy/backend/type/opengauss/src/main/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/schema/OpenGaussTables.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.proxy.backend.opengauss.handler.admin.schema;
+
+import lombok.RequiredArgsConstructor;
+
+/**
+ * System table which maintains tables in openGauss system catalog schema.
+ */
+@RequiredArgsConstructor
+public final class OpenGaussTables {
+    
+    // CHECKSTYLE:OFF
+    public final String schemaname;
+    
+    public final String tablename;
+    // CHECKSTYLE:ON
+}
diff --git a/proxy/backend/type/opengauss/src/test/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussAdminExecutorCreatorTest.java b/proxy/backend/type/opengauss/src/test/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussAdminExecutorCreatorTest.java
index 857b2024df1..d3dda3fd624 100644
--- a/proxy/backend/type/opengauss/src/test/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussAdminExecutorCreatorTest.java
+++ b/proxy/backend/type/opengauss/src/test/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussAdminExecutorCreatorTest.java
@@ -39,13 +39,33 @@ class OpenGaussAdminExecutorCreatorTest {
     @Test
     void assertCreateExecutorForSelectDatabase() {
         SelectStatementContext selectStatementContext = mock(SelectStatementContext.class, RETURNS_DEEP_STUBS);
-        when(selectStatementContext.getTablesContext().getTableNames().contains("pg_database")).thenReturn(true);
+        when(selectStatementContext.getTablesContext().getTableNames()).thenReturn(Collections.singletonList("pg_database"));
         Optional<DatabaseAdminExecutor> actual = new OpenGaussAdminExecutorCreator()
                 .create(selectStatementContext, "select datname, datcompatibility from pg_database where datname = 'sharding_db'", "postgres", Collections.emptyList());
         assertTrue(actual.isPresent());
         assertThat(actual.get(), instanceOf(OpenGaussSystemCatalogAdminQueryExecutor.class));
     }
     
+    @Test
+    void assertCreateExecutorForSelectTables() {
+        SelectStatementContext selectStatementContext = mock(SelectStatementContext.class, RETURNS_DEEP_STUBS);
+        when(selectStatementContext.getTablesContext().getTableNames()).thenReturn(Collections.singletonList("pg_tables"));
+        Optional<DatabaseAdminExecutor> actual = new OpenGaussAdminExecutorCreator()
+                .create(selectStatementContext, "select schemaname, tablename from pg_tables where schemaname = 'sharding_db'", "postgres", Collections.emptyList());
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), instanceOf(OpenGaussSystemCatalogAdminQueryExecutor.class));
+    }
+    
+    @Test
+    void assertCreateExecutorForSelectRoles() {
+        SelectStatementContext selectStatementContext = mock(SelectStatementContext.class, RETURNS_DEEP_STUBS);
+        when(selectStatementContext.getTablesContext().getTableNames()).thenReturn(Collections.singletonList("pg_roles"));
+        Optional<DatabaseAdminExecutor> actual = new OpenGaussAdminExecutorCreator()
+                .create(selectStatementContext, "select rolname from pg_roles", "postgres", Collections.emptyList());
+        assertTrue(actual.isPresent());
+        assertThat(actual.get(), instanceOf(OpenGaussSystemCatalogAdminQueryExecutor.class));
+    }
+    
     @Test
     void assertCreateExecutorForSelectVersion() {
         SelectStatementContext selectStatementContext = mock(SelectStatementContext.class, RETURNS_DEEP_STUBS);
diff --git a/proxy/backend/type/opengauss/src/test/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutorTest.java b/proxy/backend/type/opengauss/src/test/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutorTest.java
index c1d28a3a6fc..7959b39c333 100644
--- a/proxy/backend/type/opengauss/src/test/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutorTest.java
+++ b/proxy/backend/type/opengauss/src/test/java/org/apache/shardingsphere/proxy/backend/opengauss/handler/admin/OpenGaussSystemCatalogAdminQueryExecutorTest.java
@@ -17,9 +17,12 @@
 
 package org.apache.shardingsphere.proxy.backend.opengauss.handler.admin;
 
+import org.apache.shardingsphere.authority.config.AuthorityRuleConfiguration;
+import org.apache.shardingsphere.authority.rule.AuthorityRule;
 import org.apache.shardingsphere.infra.database.type.dialect.OpenGaussDatabaseType;
 import org.apache.shardingsphere.infra.executor.sql.execute.result.query.QueryResultMetaData;
 import org.apache.shardingsphere.infra.merge.result.MergedResult;
+import org.apache.shardingsphere.infra.metadata.database.rule.ShardingSphereRuleMetaData;
 import org.apache.shardingsphere.proxy.backend.context.ProxyContext;
 import org.apache.shardingsphere.proxy.backend.session.ConnectionSession;
 import org.apache.shardingsphere.test.mock.AutoMockExtension;
@@ -47,9 +50,13 @@ class OpenGaussSystemCatalogAdminQueryExecutorTest {
     void assertExecuteSelectFromPgDatabase() throws SQLException {
         when(ProxyContext.getInstance()).thenReturn(mock(ProxyContext.class, RETURNS_DEEP_STUBS));
         when(ProxyContext.getInstance().getAllDatabaseNames()).thenReturn(Arrays.asList("foo", "bar", "sharding_db", "other_db"));
-        OpenGaussSystemCatalogAdminQueryExecutor executor = new OpenGaussSystemCatalogAdminQueryExecutor("select datname, datcompatibility from pg_database where datname = 'sharding_db'");
         ConnectionSession connectionSession = mock(ConnectionSession.class);
         when(connectionSession.getProtocolType()).thenReturn(new OpenGaussDatabaseType());
+        ShardingSphereRuleMetaData shardingSphereRuleMetaData = mock(ShardingSphereRuleMetaData.class);
+        when(ProxyContext.getInstance().getContextManager().getMetaDataContexts().getMetaData().getGlobalRuleMetaData()).thenReturn(shardingSphereRuleMetaData);
+        when(shardingSphereRuleMetaData.getSingleRule(AuthorityRule.class)).thenReturn(mock(AuthorityRule.class));
+        when(shardingSphereRuleMetaData.getSingleRule(AuthorityRule.class).getConfiguration()).thenReturn(mock(AuthorityRuleConfiguration.class));
+        OpenGaussSystemCatalogAdminQueryExecutor executor = new OpenGaussSystemCatalogAdminQueryExecutor("select datname, datcompatibility from pg_database where datname = 'sharding_db'");
         executor.execute(connectionSession);
         QueryResultMetaData actualMetaData = executor.getQueryResultMetaData();
         assertThat(actualMetaData.getColumnCount(), is(2));
@@ -64,6 +71,10 @@ class OpenGaussSystemCatalogAdminQueryExecutorTest {
     @Test
     void assertExecuteSelectVersion() throws SQLException {
         when(ProxyContext.getInstance()).thenReturn(mock(ProxyContext.class, RETURNS_DEEP_STUBS));
+        ShardingSphereRuleMetaData shardingSphereRuleMetaData = mock(ShardingSphereRuleMetaData.class);
+        when(ProxyContext.getInstance().getContextManager().getMetaDataContexts().getMetaData().getGlobalRuleMetaData()).thenReturn(shardingSphereRuleMetaData);
+        when(shardingSphereRuleMetaData.getSingleRule(AuthorityRule.class)).thenReturn(mock(AuthorityRule.class));
+        when(shardingSphereRuleMetaData.getSingleRule(AuthorityRule.class).getConfiguration()).thenReturn(mock(AuthorityRuleConfiguration.class));
         OpenGaussSystemCatalogAdminQueryExecutor executor = new OpenGaussSystemCatalogAdminQueryExecutor("select VERSION()");
         ConnectionSession connectionSession = mock(ConnectionSession.class);
         when(connectionSession.getProtocolType()).thenReturn(new OpenGaussDatabaseType());
@@ -79,6 +90,10 @@ class OpenGaussSystemCatalogAdminQueryExecutorTest {
     @Test
     void assertExecuteSelectGsPasswordDeadlineAndIntervalToNum() throws SQLException {
         when(ProxyContext.getInstance()).thenReturn(mock(ProxyContext.class, RETURNS_DEEP_STUBS));
+        ShardingSphereRuleMetaData shardingSphereRuleMetaData = mock(ShardingSphereRuleMetaData.class);
+        when(ProxyContext.getInstance().getContextManager().getMetaDataContexts().getMetaData().getGlobalRuleMetaData()).thenReturn(shardingSphereRuleMetaData);
+        when(shardingSphereRuleMetaData.getSingleRule(AuthorityRule.class)).thenReturn(mock(AuthorityRule.class));
+        when(shardingSphereRuleMetaData.getSingleRule(AuthorityRule.class).getConfiguration()).thenReturn(mock(AuthorityRuleConfiguration.class));
         OpenGaussSystemCatalogAdminQueryExecutor executor = new OpenGaussSystemCatalogAdminQueryExecutor("select intervaltonum(gs_password_deadline())");
         ConnectionSession connectionSession = mock(ConnectionSession.class);
         when(connectionSession.getProtocolType()).thenReturn(new OpenGaussDatabaseType());
@@ -94,6 +109,10 @@ class OpenGaussSystemCatalogAdminQueryExecutorTest {
     @Test
     void assertExecuteSelectGsPasswordNotifyTime() throws SQLException {
         when(ProxyContext.getInstance()).thenReturn(mock(ProxyContext.class, RETURNS_DEEP_STUBS));
+        ShardingSphereRuleMetaData shardingSphereRuleMetaData = mock(ShardingSphereRuleMetaData.class);
+        when(ProxyContext.getInstance().getContextManager().getMetaDataContexts().getMetaData().getGlobalRuleMetaData()).thenReturn(shardingSphereRuleMetaData);
+        when(shardingSphereRuleMetaData.getSingleRule(AuthorityRule.class)).thenReturn(mock(AuthorityRule.class));
+        when(shardingSphereRuleMetaData.getSingleRule(AuthorityRule.class).getConfiguration()).thenReturn(mock(AuthorityRuleConfiguration.class));
         OpenGaussSystemCatalogAdminQueryExecutor executor = new OpenGaussSystemCatalogAdminQueryExecutor("select gs_password_notifytime()");
         ConnectionSession connectionSession = mock(ConnectionSession.class);
         when(connectionSession.getProtocolType()).thenReturn(new OpenGaussDatabaseType());
diff --git a/proxy/backend/type/postgresql/src/main/java/org/apache/shardingsphere/proxy/backend/postgresql/handler/admin/PostgreSQLAdminExecutorCreator.java b/proxy/backend/type/postgresql/src/main/java/org/apache/shardingsphere/proxy/backend/postgresql/handler/admin/PostgreSQLAdminExecutorCreator.java
index f984b511609..77774d592db 100644
--- a/proxy/backend/type/postgresql/src/main/java/org/apache/shardingsphere/proxy/backend/postgresql/handler/admin/PostgreSQLAdminExecutorCreator.java
+++ b/proxy/backend/type/postgresql/src/main/java/org/apache/shardingsphere/proxy/backend/postgresql/handler/admin/PostgreSQLAdminExecutorCreator.java
@@ -55,6 +55,8 @@ public final class PostgreSQLAdminExecutorCreator implements DatabaseAdminExecut
     
     private static final String PG_CLASS = "pg_class";
     
+    private static final String PG_ROLES = "pg_roles";
+    
     private static final String PG_PREFIX = "pg_";
     
     private static final String PG_NAMESPACE = "pg_namespace";
diff --git a/proxy/bootstrap/src/main/resources/conf/server.yaml b/proxy/bootstrap/src/main/resources/conf/server.yaml
index 759e4aba29d..9b0c5cd34f3 100644
--- a/proxy/bootstrap/src/main/resources/conf/server.yaml
+++ b/proxy/bootstrap/src/main/resources/conf/server.yaml
@@ -63,6 +63,12 @@
 #    props:
 #      enable: false
 #
+#sqlFederation:
+#  sqlFederationEnabled: false
+#  executionPlanCache:
+#    initialCapacity: 2000
+#    maximumSize: 65535
+#
 #props:
 #  system-log-level: INFO
 #  max-connections-size-per-query: 1
@@ -76,8 +82,6 @@
 #  proxy-backend-query-fetch-size: -1
 #  proxy-frontend-executor-size: 0 # Proxy frontend executor size. The default value is 0, which means let Netty decide.
 #  proxy-frontend-max-connections: 0 # Less than or equal to 0 means no limitation.
-#    # Available sql federation type: NONE (default), ORIGINAL, ADVANCED
-#  sql-federation-type: NONE
 #  proxy-default-port: 3307 # Proxy default port.
 #  proxy-netty-backlog: 1024 # Proxy netty backlog.
 #  cdc-server-port: 33071 # CDC server port
diff --git a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/MySQLMigrationGeneralE2EIT.java b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/MySQLMigrationGeneralE2EIT.java
index 811a4f41609..9a1325ab135 100644
--- a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/MySQLMigrationGeneralE2EIT.java
+++ b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/MySQLMigrationGeneralE2EIT.java
@@ -81,6 +81,7 @@ class MySQLMigrationGeneralE2EIT extends AbstractMigrationE2EIT {
                     new E2EIncrementalTask(containerComposer.getSourceDataSource(), SOURCE_TABLE_NAME, new SnowflakeKeyGenerateAlgorithm(), containerComposer.getDatabaseType(), 30));
             TimeUnit.SECONDS.timedJoin(containerComposer.getIncreaseTaskThread(), 30);
             containerComposer.sourceExecuteWithLog(String.format("INSERT INTO %s (order_id, user_id, status) VALUES (10000, 1, 'OK')", SOURCE_TABLE_NAME));
+            containerComposer.proxyExecuteWithLog("REFRESH TABLE METADATA", 1);
             containerComposer.assertProxyOrderRecordExist("t_order", 10000);
             assertMigrationSuccessById(containerComposer, orderJobId, "DATA_MATCH");
             String orderItemJobId = getJobIdByTableName(containerComposer, "ds_0.t_order_item");
diff --git a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/PostgreSQLMigrationGeneralE2EIT.java b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/PostgreSQLMigrationGeneralE2EIT.java
index 23433d3f252..b493e05f015 100644
--- a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/PostgreSQLMigrationGeneralE2EIT.java
+++ b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/PostgreSQLMigrationGeneralE2EIT.java
@@ -84,6 +84,7 @@ class PostgreSQLMigrationGeneralE2EIT extends AbstractMigrationE2EIT {
                     containerComposer.getDatabaseType(), 20));
             TimeUnit.SECONDS.timedJoin(containerComposer.getIncreaseTaskThread(), 30);
             containerComposer.sourceExecuteWithLog(String.format("INSERT INTO %s (order_id, user_id, status) VALUES (10000, 1, 'OK')", schemaTableName));
+            containerComposer.proxyExecuteWithLog("REFRESH TABLE METADATA", 1);
             containerComposer.assertProxyOrderRecordExist(schemaTableName, 10000);
             checkOrderMigration(containerComposer, jobId);
             checkOrderItemMigration(containerComposer);
diff --git a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/RulesMigrationE2EIT.java b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/RulesMigrationE2EIT.java
index 37f5c2aba35..57a27c7e217 100644
--- a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/RulesMigrationE2EIT.java
+++ b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/general/RulesMigrationE2EIT.java
@@ -87,6 +87,7 @@ class RulesMigrationE2EIT extends AbstractMigrationE2EIT {
         containerComposer.waitIncrementTaskFinished(String.format("SHOW MIGRATION STATUS '%s'", jobId));
         assertCheckMigrationSuccess(containerComposer, jobId, "DATA_MATCH");
         commitMigrationByJobId(containerComposer, jobId);
+        containerComposer.proxyExecuteWithLog("REFRESH TABLE METADATA", 1);
         assertThat(containerComposer.getTargetTableRecordsCount(SOURCE_TABLE_NAME), is(PipelineContainerComposer.TABLE_INIT_ROW_COUNT));
     }
     
diff --git a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/primarykey/IndexesMigrationE2EIT.java b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/primarykey/IndexesMigrationE2EIT.java
index bfc53d1a0cd..d28f37f5fed 100644
--- a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/primarykey/IndexesMigrationE2EIT.java
+++ b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/primarykey/IndexesMigrationE2EIT.java
@@ -167,6 +167,7 @@ class IndexesMigrationE2EIT extends AbstractMigrationE2EIT {
             assertMigrationSuccess(containerComposer, sql, "user_id", keyGenerateAlgorithm, consistencyCheckAlgorithmType, () -> {
                 insertOneOrder(containerComposer, uniqueKey);
                 doCreateUpdateDelete(containerComposer, keyGenerateAlgorithm.generateKey());
+                containerComposer.proxyExecuteWithLog("REFRESH TABLE METADATA", 1);
                 containerComposer.assertProxyOrderRecordExist("t_order", uniqueKey);
                 return null;
             });
@@ -191,6 +192,7 @@ class IndexesMigrationE2EIT extends AbstractMigrationE2EIT {
             assertMigrationSuccess(containerComposer, sql, "user_id", keyGenerateAlgorithm, consistencyCheckAlgorithmType, () -> {
                 insertOneOrder(containerComposer, uniqueKey);
                 doCreateUpdateDelete(containerComposer, keyGenerateAlgorithm.generateKey());
+                containerComposer.proxyExecuteWithLog("REFRESH TABLE METADATA", 1);
                 containerComposer.assertProxyOrderRecordExist("t_order", uniqueKey);
                 return null;
             });
@@ -216,6 +218,7 @@ class IndexesMigrationE2EIT extends AbstractMigrationE2EIT {
             byte[] uniqueKey = new byte[]{-1, 0, 1};
             assertMigrationSuccess(containerComposer, sql, "order_id", keyGenerateAlgorithm, consistencyCheckAlgorithmType, () -> {
                 insertOneOrder(containerComposer, uniqueKey);
+                containerComposer.proxyExecuteWithLog("REFRESH TABLE METADATA", 1);
                 // TODO Select by byte[] from proxy doesn't work, so unhex function is used for now
                 containerComposer.assertProxyOrderRecordExist(String.format("SELECT 1 FROM t_order WHERE order_id=UNHEX('%s')", Hex.encodeHexString(uniqueKey)));
                 return null;
@@ -242,6 +245,7 @@ class IndexesMigrationE2EIT extends AbstractMigrationE2EIT {
             assertCheckMigrationSuccess(containerComposer, jobId, consistencyCheckAlgorithmType);
         }
         commitMigrationByJobId(containerComposer, jobId);
+        containerComposer.proxyExecuteWithLog("REFRESH TABLE METADATA", 1);
         assertThat(containerComposer.getTargetTableRecordsCount(SOURCE_TABLE_NAME), is(PipelineContainerComposer.TABLE_INIT_ROW_COUNT + 1));
         List<String> lastJobIds = listJobId(containerComposer);
         assertTrue(lastJobIds.isEmpty());
diff --git a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/primarykey/MariaDBMigrationE2EIT.java b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/primarykey/MariaDBMigrationE2EIT.java
index 47264856beb..e7dc4789f5f 100644
--- a/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/primarykey/MariaDBMigrationE2EIT.java
+++ b/test/e2e/operation/pipeline/src/test/java/org/apache/shardingsphere/test/e2e/data/pipeline/cases/migration/primarykey/MariaDBMigrationE2EIT.java
@@ -53,7 +53,7 @@ class MariaDBMigrationE2EIT extends AbstractMigrationE2EIT {
     @ParameterizedTest(name = "{0}")
     @EnabledIf("isEnabled")
     @ArgumentsSource(PipelineE2ETestCaseArgumentsProvider.class)
-    void assertMigrationSuccess(final PipelineTestParameter testParam) throws SQLException {
+    void assertMigrationSuccess(final PipelineTestParameter testParam) throws SQLException, InterruptedException {
         try (PipelineContainerComposer containerComposer = new PipelineContainerComposer(testParam, new MigrationJobType())) {
             String sqlPattern = "CREATE TABLE `%s` (`order_id` VARCHAR(64) NOT NULL, `user_id` INT NOT NULL, `status` varchar(255), PRIMARY KEY (`order_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4";
             containerComposer.sourceExecuteWithLog(String.format(sqlPattern, SOURCE_TABLE_NAME));
@@ -69,6 +69,7 @@ class MariaDBMigrationE2EIT extends AbstractMigrationE2EIT {
             String jobId = listJobId(containerComposer).get(0);
             containerComposer.waitJobPrepareSuccess(String.format("SHOW MIGRATION STATUS '%s'", jobId));
             containerComposer.sourceExecuteWithLog("INSERT INTO t_order (order_id, user_id, status) VALUES ('a1', 1, 'OK')");
+            containerComposer.proxyExecuteWithLog("REFRESH TABLE METADATA", 1);
             containerComposer.assertProxyOrderRecordExist("t_order", "a1");
             containerComposer.waitIncrementTaskFinished(String.format("SHOW MIGRATION STATUS '%s'", jobId));
             assertCheckMigrationSuccess(containerComposer, jobId, "CRC32_MATCH");
diff --git a/test/e2e/operation/pipeline/src/test/resources/env/mysql/server-5.yaml b/test/e2e/operation/pipeline/src/test/resources/env/mysql/server-5.yaml
index b0589d5d196..6bc76b7af71 100644
--- a/test/e2e/operation/pipeline/src/test/resources/env/mysql/server-5.yaml
+++ b/test/e2e/operation/pipeline/src/test/resources/env/mysql/server-5.yaml
@@ -34,11 +34,16 @@ authority:
   privilege:
     type: ALL_PERMITTED
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
   proxy-frontend-flush-threshold: 128  # The default value is 128.
   sql-show: false
-  sql-federation-type: ADVANCED
   cdc-server-port: 33071 # CDC server port
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/operation/pipeline/src/test/resources/env/mysql/server-8.yaml b/test/e2e/operation/pipeline/src/test/resources/env/mysql/server-8.yaml
index b0589d5d196..6bc76b7af71 100644
--- a/test/e2e/operation/pipeline/src/test/resources/env/mysql/server-8.yaml
+++ b/test/e2e/operation/pipeline/src/test/resources/env/mysql/server-8.yaml
@@ -34,11 +34,16 @@ authority:
   privilege:
     type: ALL_PERMITTED
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
   proxy-frontend-flush-threshold: 128  # The default value is 128.
   sql-show: false
-  sql-federation-type: ADVANCED
   cdc-server-port: 33071 # CDC server port
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/operation/pipeline/src/test/resources/env/opengauss/server.yaml b/test/e2e/operation/pipeline/src/test/resources/env/opengauss/server.yaml
index 30b5b3638fb..f88604d80b6 100644
--- a/test/e2e/operation/pipeline/src/test/resources/env/opengauss/server.yaml
+++ b/test/e2e/operation/pipeline/src/test/resources/env/opengauss/server.yaml
@@ -42,8 +42,6 @@ props:
   check-table-metadata-enabled: false
   proxy-backend-query-fetch-size: -1
   proxy-frontend-max-connections: 0 # Less than or equal to 0 means no limitation.
-  # Available sql federation type: NONE (default), ORIGINAL, ADVANCED
-  sql-federation-type: NONE
   proxy-frontend-database-protocol-type: openGauss
   cdc-server-port: 33071 # CDC server port
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/operation/pipeline/src/test/resources/env/postgresql/server.yaml b/test/e2e/operation/pipeline/src/test/resources/env/postgresql/server.yaml
index 90e89776444..d31879dbfd5 100644
--- a/test/e2e/operation/pipeline/src/test/resources/env/postgresql/server.yaml
+++ b/test/e2e/operation/pipeline/src/test/resources/env/postgresql/server.yaml
@@ -45,8 +45,6 @@ props:
   proxy-backend-query-fetch-size: -1
   proxy-frontend-executor-size: 0 # Proxy frontend executor size. The default value is 0, which means let Netty decide.
   proxy-frontend-max-connections: 0 # Less than or equal to 0 means no limitation.
-  # Available sql federation type: NONE (default), ORIGINAL, ADVANCED
-  sql-federation-type: NONE
   proxy-frontend-database-protocol-type: PostgreSQL
   cdc-server-port: 33071 # CDC server port
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/operation/showprocesslist/src/test/resources/env/common/cluster/proxy/zookeeper/conf/server.yaml b/test/e2e/operation/showprocesslist/src/test/resources/env/common/cluster/proxy/zookeeper/conf/server.yaml
index e44c23b7035..f71efe772b1 100644
--- a/test/e2e/operation/showprocesslist/src/test/resources/env/common/cluster/proxy/zookeeper/conf/server.yaml
+++ b/test/e2e/operation/showprocesslist/src/test/resources/env/common/cluster/proxy/zookeeper/conf/server.yaml
@@ -34,10 +34,15 @@ authority:
   privilege:
     type: ALL_PERMITTED
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
   proxy-frontend-flush-threshold: 128  # The default value is 128.
   sql-show: false
-  sql-federation-type: ADVANCED
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/operation/showprocesslist/src/test/resources/env/common/standalone/proxy/conf/server.yaml b/test/e2e/operation/showprocesslist/src/test/resources/env/common/standalone/proxy/conf/server.yaml
index bd37ca8a514..68ee1192a18 100644
--- a/test/e2e/operation/showprocesslist/src/test/resources/env/common/standalone/proxy/conf/server.yaml
+++ b/test/e2e/operation/showprocesslist/src/test/resources/env/common/standalone/proxy/conf/server.yaml
@@ -22,10 +22,15 @@ authority:
   privilege:
     type: ALL_PERMITTED
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
   proxy-frontend-flush-threshold: 128  # The default value is 128.
   sql-show: false
-  sql-federation-type: ADVANCED
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-local.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-local.yaml
index 81ebd8eb6d3..11c07390f89 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-local.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-local.yaml
@@ -96,6 +96,11 @@ rules:
 transaction:
   defaultType: LOCAL
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-xa-atomikos.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-xa-atomikos.yaml
index 93652dccd26..48b7126a525 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-xa-atomikos.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-xa-atomikos.yaml
@@ -97,6 +97,11 @@ transaction:
   defaultType: XA
   providerType: Atomikos
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-xa-bitronix.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-xa-bitronix.yaml
index 6541f19031a..6eb2d9bf103 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-xa-bitronix.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/mysql/config-sharding-xa-bitronix.yaml
@@ -97,6 +97,11 @@ transaction:
   defaultType: XA
   providerType: Bitronix
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-local.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-local.yaml
index 81ebd8eb6d3..11c07390f89 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-local.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-local.yaml
@@ -96,6 +96,11 @@ rules:
 transaction:
   defaultType: LOCAL
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-atomikos.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-atomikos.yaml
index 93652dccd26..48b7126a525 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-atomikos.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-atomikos.yaml
@@ -97,6 +97,11 @@ transaction:
   defaultType: XA
   providerType: Atomikos
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-bitronix.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-bitronix.yaml
index 6541f19031a..6eb2d9bf103 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-bitronix.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-bitronix.yaml
@@ -97,6 +97,11 @@ transaction:
   defaultType: XA
   providerType: Bitronix
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-narayana.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-narayana.yaml
index 169e1b429b5..d89628cac82 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-narayana.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/opengauss/config-sharding-xa-narayana.yaml
@@ -97,6 +97,11 @@ transaction:
   defaultType: XA
   providerType: Narayana
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-local.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-local.yaml
index 81ebd8eb6d3..11c07390f89 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-local.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-local.yaml
@@ -96,6 +96,11 @@ rules:
 transaction:
   defaultType: LOCAL
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-atomikos.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-atomikos.yaml
index 93652dccd26..48b7126a525 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-atomikos.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-atomikos.yaml
@@ -97,6 +97,11 @@ transaction:
   defaultType: XA
   providerType: Atomikos
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-bitronix.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-bitronix.yaml
index 6541f19031a..6eb2d9bf103 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-bitronix.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-bitronix.yaml
@@ -97,6 +97,11 @@ transaction:
   defaultType: XA
   providerType: Bitronix
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-narayana.yaml b/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-narayana.yaml
index 169e1b429b5..d89628cac82 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-narayana.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/jdbc/postgresql/config-sharding-xa-narayana.yaml
@@ -97,6 +97,11 @@ transaction:
   defaultType: XA
   providerType: Narayana
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   sql-show: true
-  sql-federation-type: ADVANCED
diff --git a/test/e2e/operation/transaction/src/test/resources/env/mysql/server.yaml b/test/e2e/operation/transaction/src/test/resources/env/mysql/server.yaml
index a692fc13c06..2986d1cfd88 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/mysql/server.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/mysql/server.yaml
@@ -34,10 +34,15 @@ authority:
   privilege:
     type: ALL_PERMITTED
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
   proxy-frontend-flush-threshold: 128  # The default value is 128.
   sql-show: true
-  sql-federation-type: ADVANCED
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/operation/transaction/src/test/resources/env/opengauss/server.yaml b/test/e2e/operation/transaction/src/test/resources/env/opengauss/server.yaml
index 7aa63fd99f4..fe2f9af239a 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/opengauss/server.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/opengauss/server.yaml
@@ -34,6 +34,12 @@ authority:
   privilege:
     type: ALL_PERMITTED
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
@@ -42,6 +48,5 @@ props:
   check-table-metadata-enabled: false
   proxy-backend-query-fetch-size: -1
   proxy-frontend-max-connections: 0 # Less than or equal to 0 means no limitation.
-  sql-federation-type: ADVANCED
   proxy-frontend-database-protocol-type: openGauss
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/operation/transaction/src/test/resources/env/postgresql/server.yaml b/test/e2e/operation/transaction/src/test/resources/env/postgresql/server.yaml
index 174f8e3be4f..a3914225211 100644
--- a/test/e2e/operation/transaction/src/test/resources/env/postgresql/server.yaml
+++ b/test/e2e/operation/transaction/src/test/resources/env/postgresql/server.yaml
@@ -34,6 +34,12 @@ authority:
   privilege:
     type: ALL_PERMITTED
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
@@ -45,6 +51,5 @@ props:
   proxy-backend-query-fetch-size: -1
   proxy-frontend-executor-size: 0 # Proxy frontend executor size. The default value is 0, which means let Netty decide.
   proxy-frontend-max-connections: 0 # Less than or equal to 0 means no limitation.
-  sql-federation-type: ADVANCED
   proxy-frontend-database-protocol-type: PostgreSQL
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/sql/src/test/resources/cases/dql/dql-integration-select-sub-query.xml b/test/e2e/sql/src/test/resources/cases/dql/dql-integration-select-sub-query.xml
index 14f569faa2b..928c0eabcfd 100644
--- a/test/e2e/sql/src/test/resources/cases/dql/dql-integration-select-sub-query.xml
+++ b/test/e2e/sql/src/test/resources/cases/dql/dql-integration-select-sub-query.xml
@@ -83,4 +83,24 @@
                scenario-comments="Test single table's LIKE operator underscore wildcard in subquery select statement when use sharding feature.|Test encrypt table's LIKE operator underscore wildcard in subquery select statement when use encrypt feature.">
         <assertion expected-data-source-name="read_dataset" />
     </test-case>
+    
+    <test-case sql="SELECT business_code, telephone, (SELECT password FROM t_user LIMIT 1) AS password FROM t_merchant" db-types="MySQL,PostgreSQL,openGauss" scenario-types="encrypt"
+               scenario-comments="Test subquery projection contains encrypt column and config alias when use encrypt feature.">
+        <assertion expected-data-source-name="read_dataset" />
+    </test-case>
+    
+    <test-case sql="SELECT * FROM (SELECT business_code, telephone, (SELECT password FROM t_user LIMIT 1) AS password FROM t_merchant) AS temp" db-types="MySQL,PostgreSQL,openGauss" scenario-types="encrypt"
+               scenario-comments="Test shorthand expansion contains subquery projection and subquery projection contains encrypt column and config alias when use encrypt feature.">
+        <assertion expected-data-source-name="read_dataset" />
+    </test-case>
+
+    <test-case sql="SELECT m.business_code, m.telephone, u.user_id FROM t_merchant AS m INNER JOIN t_user AS u ON m.merchant_id = u.user_id" db-types="MySQL,PostgreSQL,openGauss" scenario-types="encrypt"
+               scenario-comments="Test join contains some encrypt columns in multi tables when use encrypt feature.">
+        <assertion expected-data-source-name="read_dataset" />
+    </test-case>
+
+    <test-case sql="SELECT * FROM (SELECT m.business_code, m.telephone, u.user_id FROM t_merchant AS m INNER JOIN t_user AS u ON m.merchant_id = u.user_id) AS temp" db-types="MySQL,PostgreSQL,openGauss" scenario-types="encrypt"
+               scenario-comments="Test shorthand expansion contains subquery join and join contains some encrypt columns in multi tables when use encrypt feature.">
+        <assertion expected-data-source-name="read_dataset" />
+    </test-case>
 </integration-test-cases>
diff --git a/test/e2e/sql/src/test/resources/cases/dql/dql-integration-select.xml b/test/e2e/sql/src/test/resources/cases/dql/dql-integration-select.xml
index 610ed5cb0ac..88807b090fb 100644
--- a/test/e2e/sql/src/test/resources/cases/dql/dql-integration-select.xml
+++ b/test/e2e/sql/src/test/resources/cases/dql/dql-integration-select.xml
@@ -17,6 +17,8 @@
   -->
 
 <integration-test-cases>
+    <test-case sql="SELECT 1 FROM dual" />
+
     <test-case sql="SELECT 1 as a" />
     
     <test-case sql="SELECT t_order.* FROM t_order t_order WHERE user_id = ? AND order_id = ?" scenario-types="db,tbl,dbtbl_with_readwrite_splitting,readwrite_splitting">
diff --git a/test/e2e/sql/src/test/resources/env/common/cluster/proxy/conf/server.yaml b/test/e2e/sql/src/test/resources/env/common/cluster/proxy/conf/server.yaml
index ab29902fa76..ce6d9ef96c9 100644
--- a/test/e2e/sql/src/test/resources/env/common/cluster/proxy/conf/server.yaml
+++ b/test/e2e/sql/src/test/resources/env/common/cluster/proxy/conf/server.yaml
@@ -43,10 +43,15 @@ sqlParser:
     initialCapacity: 128
     maximumSize: 1024
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
   proxy-frontend-flush-threshold: 128  # The default value is 128.
   sql-show: false
-  sql-federation-type: ADVANCED
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/sql/src/test/resources/env/common/standalone/proxy/conf/server.yaml b/test/e2e/sql/src/test/resources/env/common/standalone/proxy/conf/server.yaml
index 24356e0981a..3b97188335c 100644
--- a/test/e2e/sql/src/test/resources/env/common/standalone/proxy/conf/server.yaml
+++ b/test/e2e/sql/src/test/resources/env/common/standalone/proxy/conf/server.yaml
@@ -43,10 +43,15 @@ sqlParser:
     initialCapacity: 128
     maximumSize: 1024
 
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
+
 props:
   max-connections-size-per-query: 1
   kernel-executor-size: 16  # Infinite by default.
   proxy-frontend-flush-threshold: 128  # The default value is 128.
   sql-show: false
-  sql-federation-type: ADVANCED
   proxy-frontend-ssl-enabled: true
diff --git a/test/e2e/sql/src/test/resources/env/scenario/db/rules.yaml b/test/e2e/sql/src/test/resources/env/scenario/db/rules.yaml
index c06ad57dc94..b10a62550ff 100644
--- a/test/e2e/sql/src/test/resources/env/scenario/db/rules.yaml
+++ b/test/e2e/sql/src/test/resources/env/scenario/db/rules.yaml
@@ -84,5 +84,8 @@ rules:
     auditor_constant:
       type: IT.AUDITOR.FIXTURE
 
-props:
-  sql-federation-type: ADVANCED
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
diff --git a/test/e2e/sql/src/test/resources/env/scenario/dbtbl_with_readwrite_splitting/rules.yaml b/test/e2e/sql/src/test/resources/env/scenario/dbtbl_with_readwrite_splitting/rules.yaml
index fd9f1774eb7..ac7708d1315 100644
--- a/test/e2e/sql/src/test/resources/env/scenario/dbtbl_with_readwrite_splitting/rules.yaml
+++ b/test/e2e/sql/src/test/resources/env/scenario/dbtbl_with_readwrite_splitting/rules.yaml
@@ -151,5 +151,8 @@ rules:
     roundRobin:
       type: ROUND_ROBIN
 
-props:
-  sql-federation-type: ADVANCED
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
diff --git a/test/e2e/sql/src/test/resources/env/scenario/dbtbl_with_readwrite_splitting_and_encrypt/rules.yaml b/test/e2e/sql/src/test/resources/env/scenario/dbtbl_with_readwrite_splitting_and_encrypt/rules.yaml
index d24beba065c..50ad26af617 100644
--- a/test/e2e/sql/src/test/resources/env/scenario/dbtbl_with_readwrite_splitting_and_encrypt/rules.yaml
+++ b/test/e2e/sql/src/test/resources/env/scenario/dbtbl_with_readwrite_splitting_and_encrypt/rules.yaml
@@ -227,5 +227,8 @@ rules:
             name: cipher_pwd
             encryptorName: aes_encryptor
 
-props:
-  sql-federation-type: ADVANCED
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
diff --git a/test/e2e/sql/src/test/resources/env/scenario/encrypt_and_readwrite_splitting/rules.yaml b/test/e2e/sql/src/test/resources/env/scenario/encrypt_and_readwrite_splitting/rules.yaml
index 7be2963eedd..139628af864 100644
--- a/test/e2e/sql/src/test/resources/env/scenario/encrypt_and_readwrite_splitting/rules.yaml
+++ b/test/e2e/sql/src/test/resources/env/scenario/encrypt_and_readwrite_splitting/rules.yaml
@@ -74,5 +74,8 @@ rules:
             name: telephone_cipher
             encryptorName: aes_encryptor
 
-props:
-  sql-federation-type: ADVANCED
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
diff --git a/test/e2e/sql/src/test/resources/env/scenario/sharding_and_encrypt/rules.yaml b/test/e2e/sql/src/test/resources/env/scenario/sharding_and_encrypt/rules.yaml
index 937a5f32656..98a203218c5 100644
--- a/test/e2e/sql/src/test/resources/env/scenario/sharding_and_encrypt/rules.yaml
+++ b/test/e2e/sql/src/test/resources/env/scenario/sharding_and_encrypt/rules.yaml
@@ -185,5 +185,8 @@ rules:
             name: telephone_cipher
             encryptorName: aes_encryptor
 
-props:
-  sql-federation-type: ADVANCED
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
diff --git a/test/e2e/sql/src/test/resources/env/scenario/tbl/rules.yaml b/test/e2e/sql/src/test/resources/env/scenario/tbl/rules.yaml
index f5be26faf40..190b2b23baf 100644
--- a/test/e2e/sql/src/test/resources/env/scenario/tbl/rules.yaml
+++ b/test/e2e/sql/src/test/resources/env/scenario/tbl/rules.yaml
@@ -91,5 +91,8 @@ rules:
     auditor_constant:
       type: IT.AUDITOR.FIXTURE
 
-props:
-  sql-federation-type: ADVANCED
+sqlFederation:
+  sqlFederationEnabled: true
+  executionPlanCache:
+    initialCapacity: 2000
+    maximumSize: 65535
diff --git a/test/it/parser/src/main/resources/case/dml/select.xml b/test/it/parser/src/main/resources/case/dml/select.xml
index 17af6381dc4..0148e7c3fab 100644
--- a/test/it/parser/src/main/resources/case/dml/select.xml
+++ b/test/it/parser/src/main/resources/case/dml/select.xml
@@ -4967,4 +4967,15 @@
             <simple-table name="DUAL" start-index="88" stop-index="91" literal-start-index="91" literal-stop-index="94" />
         </from>
     </select>
+
+    <select sql-case-id="select_with_chinese_comma">
+        <projections start-index="7" stop-index="12" >
+            <expression-projection text="1" start-index="7" stop-index="7" />
+            <expression-projection text="2" start-index="10" stop-index="10" />
+            <expression-projection text="3" start-index="12" stop-index="12" />
+        </projections>
+        <from>
+            <simple-table name="DUAL" start-index="19" stop-index="22" />
+        </from>
+    </select>
 </sql-parser-test-cases>
diff --git a/test/it/parser/src/main/resources/sql/supported/dml/select.xml b/test/it/parser/src/main/resources/sql/supported/dml/select.xml
index 3d2035bff7e..1887fe0d229 100644
--- a/test/it/parser/src/main/resources/sql/supported/dml/select.xml
+++ b/test/it/parser/src/main/resources/sql/supported/dml/select.xml
@@ -162,4 +162,5 @@
     <sql-case id="select_string_constant_type_cast" value="SELECT int4 '1', money '2'" db-types="PostgreSQL,openGauss" />
     <sql-case id="select_constant_with_nested_type_cast" value="SELECT CAST(MONEY '1' AS VARCHAR)::CHAR(10)::VARCHAR::CHAR(4)" db-types="PostgreSQL,openGauss"  />
     <sql-case id="select_projection_with_parameter" value="SELECT 1 AS id, ? AS status, SYSDATE AS create_time, TRUNC(SYSDATE) AS create_date FROM DUAL" db-types="Oracle"  />
+    <sql-case id="select_with_chinese_comma" value="SELECT 1， 2，3 FROM DUAL" db-types="Oracle"  />
 </sql-cases>
diff --git a/test/it/pipeline/src/test/java/org/apache/shardingsphere/test/it/data/pipeline/core/importer/PipelineDataSourceSinkTest.java b/test/it/pipeline/src/test/java/org/apache/shardingsphere/test/it/data/pipeline/core/importer/PipelineDataSourceSinkTest.java
index 07ad96e23ea..67ef9ec0918 100644
--- a/test/it/pipeline/src/test/java/org/apache/shardingsphere/test/it/data/pipeline/core/importer/PipelineDataSourceSinkTest.java
+++ b/test/it/pipeline/src/test/java/org/apache/shardingsphere/test/it/data/pipeline/core/importer/PipelineDataSourceSinkTest.java
@@ -33,6 +33,7 @@ import org.apache.shardingsphere.data.pipeline.api.ingest.record.Record;
 import org.apache.shardingsphere.data.pipeline.api.metadata.LogicTableName;
 import org.apache.shardingsphere.data.pipeline.core.importer.SingleChannelConsumerImporter;
 import org.apache.shardingsphere.data.pipeline.core.importer.sink.PipelineDataSourceSink;
+import org.apache.shardingsphere.data.pipeline.core.ingest.IngestDataChangeType;
 import org.apache.shardingsphere.data.pipeline.spi.importer.sink.PipelineSink;
 import org.apache.shardingsphere.test.it.data.pipeline.core.fixture.FixtureInventoryIncrementalJobItemContext;
 import org.junit.jupiter.api.BeforeEach;
@@ -145,9 +146,7 @@ class PipelineDataSourceSinkTest {
     }
     
     private DataRecord getUpdatePrimaryKeyDataRecord() {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 3);
-        result.setTableName(TABLE_NAME);
-        result.setType("UPDATE");
+        DataRecord result = new DataRecord(IngestDataChangeType.UPDATE, TABLE_NAME, new PlaceholderPosition(), 3);
         result.addColumn(new Column("id", 1, 2, true, true));
         result.addColumn(new Column("user", 0, 10, true, false));
         result.addColumn(new Column("status", null, "UPDATE", true, false));
@@ -162,9 +161,6 @@ class PipelineDataSourceSinkTest {
     }
     
     private DataRecord getDataRecord(final String recordType) {
-        DataRecord result = new DataRecord(new PlaceholderPosition(), 3);
-        result.setTableName(TABLE_NAME);
-        result.setType(recordType);
         Integer idOldValue = null;
         Integer userOldValue = null;
         Integer idValue = null;
@@ -188,6 +184,7 @@ class PipelineDataSourceSinkTest {
             userOldValue = 10;
             statusOldValue = recordType;
         }
+        DataRecord result = new DataRecord(recordType, TABLE_NAME, new PlaceholderPosition(), 3);
         result.addColumn(new Column("id", idOldValue, idValue, false, true));
         result.addColumn(new Column("user", userOldValue, userValue, true, false));
         result.addColumn(new Column("status", statusOldValue, statusValue, true, false));
diff --git a/test/it/pipeline/src/test/java/org/apache/shardingsphere/test/it/data/pipeline/core/prepare/InventoryTaskSplitterTest.java b/test/it/pipeline/src/test/java/org/apache/shardingsphere/test/it/data/pipeline/core/prepare/InventoryTaskSplitterTest.java
index a6e76f8d71e..42d3e694fc2 100644
--- a/test/it/pipeline/src/test/java/org/apache/shardingsphere/test/it/data/pipeline/core/prepare/InventoryTaskSplitterTest.java
+++ b/test/it/pipeline/src/test/java/org/apache/shardingsphere/test/it/data/pipeline/core/prepare/InventoryTaskSplitterTest.java
@@ -110,7 +110,7 @@ class InventoryTaskSplitterTest {
         assertThat(actual.size(), is(1));
         assertThat(actual.get(0).getTaskId(), is("ds_0.t_order#0"));
         IntegerPrimaryKeyPosition keyPosition = (IntegerPrimaryKeyPosition) actual.get(0).getTaskProgress().getPosition();
-        assertThat(keyPosition.getBeginValue(), is(0L));
+        assertThat(keyPosition.getBeginValue(), is(1L));
         assertThat(keyPosition.getEndValue(), is(999L));
     }
     
diff --git a/test/it/rewriter/src/test/java/org/apache/shardingsphere/test/it/rewrite/engine/SQLRewriterIT.java b/test/it/rewriter/src/test/java/org/apache/shardingsphere/test/it/rewrite/engine/SQLRewriterIT.java
index efc10f2e867..c1c54980e93 100644
--- a/test/it/rewriter/src/test/java/org/apache/shardingsphere/test/it/rewrite/engine/SQLRewriterIT.java
+++ b/test/it/rewriter/src/test/java/org/apache/shardingsphere/test/it/rewrite/engine/SQLRewriterIT.java
@@ -18,7 +18,6 @@
 package org.apache.shardingsphere.test.it.rewrite.engine;
 
 import com.google.common.base.Preconditions;
-import org.apache.shardingsphere.infra.session.query.QueryContext;
 import org.apache.shardingsphere.infra.binder.SQLStatementContextFactory;
 import org.apache.shardingsphere.infra.binder.aware.CursorDefinitionAware;
 import org.apache.shardingsphere.infra.binder.aware.ParameterAware;
@@ -27,8 +26,6 @@ import org.apache.shardingsphere.infra.binder.statement.ddl.CursorStatementConte
 import org.apache.shardingsphere.infra.config.database.DatabaseConfiguration;
 import org.apache.shardingsphere.infra.config.database.impl.DataSourceProvidedDatabaseConfiguration;
 import org.apache.shardingsphere.infra.config.props.ConfigurationProperties;
-import org.apache.shardingsphere.infra.session.connection.ConnectionContext;
-import org.apache.shardingsphere.infra.session.connection.cursor.CursorConnectionContext;
 import org.apache.shardingsphere.infra.database.DefaultDatabase;
 import org.apache.shardingsphere.infra.database.type.DatabaseType;
 import org.apache.shardingsphere.infra.database.type.DatabaseTypeEngine;
@@ -48,6 +45,9 @@ import org.apache.shardingsphere.infra.route.context.RouteContext;
 import org.apache.shardingsphere.infra.route.engine.SQLRouteEngine;
 import org.apache.shardingsphere.infra.rule.ShardingSphereRule;
 import org.apache.shardingsphere.infra.rule.builder.database.DatabaseRulesBuilder;
+import org.apache.shardingsphere.infra.session.connection.ConnectionContext;
+import org.apache.shardingsphere.infra.session.connection.cursor.CursorConnectionContext;
+import org.apache.shardingsphere.infra.session.query.QueryContext;
 import org.apache.shardingsphere.infra.util.spi.type.typed.TypedSPILoader;
 import org.apache.shardingsphere.infra.yaml.config.pojo.YamlRootConfiguration;
 import org.apache.shardingsphere.infra.yaml.config.swapper.resource.YamlDataSourceConfigurationSwapper;
@@ -55,7 +55,10 @@ import org.apache.shardingsphere.infra.yaml.config.swapper.rule.YamlRuleConfigur
 import org.apache.shardingsphere.parser.config.SQLParserRuleConfiguration;
 import org.apache.shardingsphere.parser.rule.SQLParserRule;
 import org.apache.shardingsphere.parser.rule.builder.DefaultSQLParserRuleConfigurationBuilder;
+import org.apache.shardingsphere.sql.parser.api.CacheOption;
 import org.apache.shardingsphere.sql.parser.sql.common.statement.SQLStatement;
+import org.apache.shardingsphere.sqlfederation.api.config.SQLFederationRuleConfiguration;
+import org.apache.shardingsphere.sqlfederation.rule.SQLFederationRule;
 import org.apache.shardingsphere.sqltranslator.api.config.SQLTranslatorRuleConfiguration;
 import org.apache.shardingsphere.sqltranslator.rule.SQLTranslatorRule;
 import org.apache.shardingsphere.test.it.rewrite.engine.parameter.SQLRewriteEngineTestParameters;
@@ -75,6 +78,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
+import java.util.LinkedList;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Properties;
@@ -118,27 +122,27 @@ public abstract class SQLRewriterIT {
         Map<String, DatabaseType> storageTypes = createStorageTypes(databaseConfig, databaseType);
         when(resourceMetaData.getStorageTypes()).thenReturn(storageTypes);
         String schemaName = DatabaseTypeEngine.getDefaultSchemaName(databaseType, DefaultDatabase.LOGIC_NAME);
-        Collection<ShardingSphereRule> databaseRules = DatabaseRulesBuilder.build(DefaultDatabase.LOGIC_NAME, databaseConfig, mock(InstanceContext.class));
         SQLStatementParserEngine sqlStatementParserEngine = new SQLStatementParserEngine(testParams.getDatabaseType(),
                 sqlParserRule.getSqlStatementCache(), sqlParserRule.getParseTreeCache(), sqlParserRule.isSqlCommentParseEnabled());
         SQLStatement sqlStatement = sqlStatementParserEngine.parse(testParams.getInputSQL(), false);
-        mockRules(databaseRules, schemaName, sqlStatement);
-        databaseRules.add(sqlParserRule);
-        databaseRules.add(timestampServiceRule);
-        ShardingSphereDatabase database = new ShardingSphereDatabase(schemaName, databaseType, resourceMetaData, new ShardingSphereRuleMetaData(databaseRules), mockSchemas(schemaName));
+        Collection<ShardingSphereRule> databaseRules = createDatabaseRules(databaseConfig, schemaName, sqlStatement);
+        ShardingSphereRuleMetaData databaseRuleMetaData = new ShardingSphereRuleMetaData(databaseRules);
+        ShardingSphereDatabase database = new ShardingSphereDatabase(schemaName, databaseType, resourceMetaData, databaseRuleMetaData, mockSchemas(schemaName));
         Map<String, ShardingSphereDatabase> databases = new HashMap<>(2, 1F);
         databases.put(schemaName, database);
-        SQLStatementContext sqlStatementContext = SQLStatementContextFactory.newInstance(createShardingSphereMetaData(databases), sqlStatement, schemaName);
+        ShardingSphereRuleMetaData globalRuleMetaData = new ShardingSphereRuleMetaData(createGlobalRules());
+        ShardingSphereMetaData metaData = new ShardingSphereMetaData(databases, globalRuleMetaData, mock(ConfigurationProperties.class));
+        SQLStatementContext sqlStatementContext = SQLStatementContextFactory.newInstance(metaData, sqlStatement, schemaName);
         if (sqlStatementContext instanceof ParameterAware) {
             ((ParameterAware) sqlStatementContext).setUpParameters(testParams.getInputParameters());
         }
         if (sqlStatementContext instanceof CursorDefinitionAware) {
-            ((CursorDefinitionAware) sqlStatementContext).setUpCursorDefinition(createCursorDefinition(schemaName, databases, sqlStatementParserEngine));
+            ((CursorDefinitionAware) sqlStatementContext).setUpCursorDefinition(createCursorDefinition(schemaName, metaData, sqlStatementParserEngine));
         }
         QueryContext queryContext = new QueryContext(sqlStatementContext, testParams.getInputSQL(), testParams.getInputParameters());
         ConfigurationProperties props = new ConfigurationProperties(rootConfig.getProps());
-        RouteContext routeContext = new SQLRouteEngine(databaseRules, props).route(new ConnectionContext(), queryContext, mock(ShardingSphereRuleMetaData.class), database);
-        SQLRewriteEntry sqlRewriteEntry = new SQLRewriteEntry(database, new ShardingSphereRuleMetaData(Collections.singleton(new SQLTranslatorRule(new SQLTranslatorRuleConfiguration()))), props);
+        RouteContext routeContext = new SQLRouteEngine(databaseRules, props).route(new ConnectionContext(), queryContext, globalRuleMetaData, database);
+        SQLRewriteEntry sqlRewriteEntry = new SQLRewriteEntry(database, globalRuleMetaData, props);
         ConnectionContext connectionContext = mock(ConnectionContext.class);
         when(connectionContext.getCursorContext()).thenReturn(new CursorConnectionContext());
         SQLRewriteResult sqlRewriteResult = sqlRewriteEntry.rewrite(testParams.getInputSQL(), testParams.getInputParameters(), sqlStatementContext, routeContext, connectionContext);
@@ -147,8 +151,20 @@ public abstract class SQLRewriterIT {
                 : (((RouteSQLRewriteResult) sqlRewriteResult).getSqlRewriteUnits()).values();
     }
     
-    private ShardingSphereMetaData createShardingSphereMetaData(final Map<String, ShardingSphereDatabase> databases) {
-        return new ShardingSphereMetaData(databases, mock(ShardingSphereRuleMetaData.class), mock(ConfigurationProperties.class));
+    private Collection<ShardingSphereRule> createDatabaseRules(final DatabaseConfiguration databaseConfig, final String schemaName, final SQLStatement sqlStatement) {
+        Collection<ShardingSphereRule> result = DatabaseRulesBuilder.build(DefaultDatabase.LOGIC_NAME, databaseConfig, mock(InstanceContext.class));
+        mockRules(result, schemaName, sqlStatement);
+        result.add(sqlParserRule);
+        result.add(timestampServiceRule);
+        return result;
+    }
+    
+    private Collection<ShardingSphereRule> createGlobalRules() {
+        Collection<ShardingSphereRule> result = new LinkedList<>();
+        result.add(new SQLTranslatorRule(new SQLTranslatorRuleConfiguration()));
+        result.add(new SQLFederationRule(new SQLFederationRuleConfiguration(false, mock(CacheOption.class))));
+        result.add(new TimestampServiceRule(mock(TimestampServiceRuleConfiguration.class)));
+        return result;
     }
     
     private Map<String, DatabaseType> createStorageTypes(final DatabaseConfiguration databaseConfig, final DatabaseType databaseType) {
@@ -159,9 +175,9 @@ public abstract class SQLRewriterIT {
         return result;
     }
     
-    private CursorStatementContext createCursorDefinition(final String schemaName, final Map<String, ShardingSphereDatabase> databases, final SQLStatementParserEngine sqlStatementParserEngine) {
-        return (CursorStatementContext) SQLStatementContextFactory.newInstance(
-                createShardingSphereMetaData(databases), sqlStatementParserEngine.parse("CURSOR t_account_cursor FOR SELECT * FROM t_account WHERE account_id = 100", false), schemaName);
+    private CursorStatementContext createCursorDefinition(final String schemaName, final ShardingSphereMetaData metaData, final SQLStatementParserEngine sqlStatementParserEngine) {
+        return (CursorStatementContext) SQLStatementContextFactory.newInstance(metaData,
+                sqlStatementParserEngine.parse("CURSOR t_account_cursor FOR SELECT * FROM t_account WHERE account_id = 100", false), schemaName);
     }
     
     protected abstract void mockDataSource(Map<String, DataSource> dataSources) throws SQLException;
diff --git a/test/it/rewriter/src/test/resources/scenario/encrypt/case/query-with-cipher/dml/select/select-projection.xml b/test/it/rewriter/src/test/resources/scenario/encrypt/case/query-with-cipher/dml/select/select-projection.xml
index 74a7279ab37..2947fe90bef 100644
--- a/test/it/rewriter/src/test/resources/scenario/encrypt/case/query-with-cipher/dml/select/select-projection.xml
+++ b/test/it/rewriter/src/test/resources/scenario/encrypt/case/query-with-cipher/dml/select/select-projection.xml
@@ -19,7 +19,7 @@
 <rewrite-assertions yaml-rule="scenario/encrypt/config/query-with-cipher.yaml">
     <rewrite-assertion id="select_with_unqualified_shorthand_for_cipher" db-types="MySQL">
         <input sql="SELECT * FROM t_account_bak" />
-        <output sql="SELECT `t_account_bak`.`account_id`, `t_account_bak`.`cipher_certificate_number` AS `certificate_number`, `t_account_bak`.`cipher_password` AS `password`, `t_account_bak`.`cipher_amount` AS `amount` FROM t_account_bak" />
+        <output sql="SELECT t_account_bak.`account_id`, t_account_bak.`cipher_certificate_number` AS `certificate_number`, t_account_bak.`cipher_password` AS `password`, t_account_bak.`cipher_amount` AS `amount` FROM t_account_bak" />
     </rewrite-assertion>
     
     <rewrite-assertion id="select_with_qualified_shorthand_for_cipher" db-types="MySQL">
@@ -44,12 +44,12 @@
     
     <rewrite-assertion id="select_with_unqualified_shorthand_for_parameters" db-types="MySQL">
         <input sql="SELECT * FROM t_account WHERE certificate_number = ? AND certificate_number LIKE ?" parameters="1, 1" />
-        <output sql="SELECT `t_account`.`account_id`, `t_account`.`cipher_certificate_number` AS `certificate_number`, `t_account`.`cipher_password` AS `password`, `t_account`.`cipher_amount` AS `amount` FROM t_account WHERE assisted_query_certificate_number = ? AND like_query_certificate_number LIKE ?" parameters="assisted_query_1, like_query_1" />
+        <output sql="SELECT t_account.`account_id`, t_account.`cipher_certificate_number` AS `certificate_number`, t_account.`cipher_password` AS `password`, t_account.`cipher_amount` AS `amount` FROM t_account WHERE assisted_query_certificate_number = ? AND like_query_certificate_number LIKE ?" parameters="assisted_query_1, like_query_1" />
     </rewrite-assertion>
     
     <rewrite-assertion id="select_with_unqualified_shorthand_for_literals" db-types="MySQL">
         <input sql="SELECT * FROM t_account WHERE certificate_number = 1 AND certificate_number LIKE 1" />
-        <output sql="SELECT `t_account`.`account_id`, `t_account`.`cipher_certificate_number` AS `certificate_number`, `t_account`.`cipher_password` AS `password`, `t_account`.`cipher_amount` AS `amount` FROM t_account WHERE assisted_query_certificate_number = 'assisted_query_1' AND like_query_certificate_number LIKE 'like_query_1'" />
+        <output sql="SELECT t_account.`account_id`, t_account.`cipher_certificate_number` AS `certificate_number`, t_account.`cipher_password` AS `password`, t_account.`cipher_amount` AS `amount` FROM t_account WHERE assisted_query_certificate_number = 'assisted_query_1' AND like_query_certificate_number LIKE 'like_query_1'" />
     </rewrite-assertion>
     
     <rewrite-assertion id="select_with_qualified_shorthand" db-types="MySQL">
@@ -64,12 +64,12 @@
     
     <rewrite-assertion id="select_with_schema_name_in_shorthand_projection_for_parameters" db-types="MySQL">
         <input sql="SELECT logic_db.t_account.* FROM t_account WHERE account_id = ? AND certificate_number = ? AND certificate_number LIKE ?" parameters="100, 200, 300" />
-        <output sql="SELECT `t_account`.`account_id`, `t_account`.`cipher_certificate_number` AS `certificate_number`, `t_account`.`cipher_password` AS `password`, `t_account`.`cipher_amount` AS `amount` FROM t_account WHERE account_id = ? AND assisted_query_certificate_number = ? AND like_query_certificate_number LIKE ?" parameters="100, assisted_query_200, like_query_300" />
+        <output sql="SELECT t_account.`account_id`, t_account.`cipher_certificate_number` AS `certificate_number`, t_account.`cipher_password` AS `password`, t_account.`cipher_amount` AS `amount` FROM t_account WHERE account_id = ? AND assisted_query_certificate_number = ? AND like_query_certificate_number LIKE ?" parameters="100, assisted_query_200, like_query_300" />
     </rewrite-assertion>
     
     <rewrite-assertion id="select_with_schema_name_in_shorthand_projection_for_literals" db-types="MySQL">
         <input sql="SELECT logic_db.t_account.* FROM t_account WHERE account_id = 100 AND certificate_number = 200 AND certificate_number LIKE 300" />
-        <output sql="SELECT `t_account`.`account_id`, `t_account`.`cipher_certificate_number` AS `certificate_number`, `t_account`.`cipher_password` AS `password`, `t_account`.`cipher_amount` AS `amount` FROM t_account WHERE account_id = 100 AND assisted_query_certificate_number = 'assisted_query_200' AND like_query_certificate_number LIKE 'like_query_300'" />
+        <output sql="SELECT t_account.`account_id`, t_account.`cipher_certificate_number` AS `certificate_number`, t_account.`cipher_password` AS `password`, t_account.`cipher_amount` AS `amount` FROM t_account WHERE account_id = 100 AND assisted_query_certificate_number = 'assisted_query_200' AND like_query_certificate_number LIKE 'like_query_300'" />
     </rewrite-assertion>
     
     <rewrite-assertion id="select_with_schema_name_in_column_projection_for_parameters" db-types="MySQL">
diff --git a/test/it/rewriter/src/test/resources/scenario/encrypt/case/query-with-cipher/dml/select/select-subquery.xml b/test/it/rewriter/src/test/resources/scenario/encrypt/case/query-with-cipher/dml/select/select-subquery.xml
index 34cc55636b7..94b726421b8 100644
--- a/test/it/rewriter/src/test/resources/scenario/encrypt/case/query-with-cipher/dml/select/select-subquery.xml
+++ b/test/it/rewriter/src/test/resources/scenario/encrypt/case/query-with-cipher/dml/select/select-subquery.xml
@@ -44,12 +44,12 @@
 
     <rewrite-assertion id="select_not_nested_subquery_in_table_segment_with_shorthand_project_alias_quote" db-types="MySQL">
         <input sql="SELECT u.amount, u.password, o.certificate_number FROM (SELECT a.* FROM t_account `a`) o, t_account u WHERE o.certificate_number=u.certificate_number AND u.password=?" parameters="1" />
-        <output sql="SELECT u.cipher_amount AS amount, u.cipher_password AS password, o.cipher_certificate_number AS certificate_number FROM (SELECT `a`.`account_id`, `a`.`cipher_certificate_number`, `a`.`assisted_query_certificate_number`, `a`.`cipher_password`, `a`.`assisted_query_password`, `a`.`cipher_amount` FROM t_account `a`) o, t_account u WHERE o.assisted_query_certificate_number=u.assisted_query_certificate_number AND u.assisted_query_password=?" parameters="assisted_query_1" />
+        <output sql="SELECT u.cipher_amount AS amount, u.cipher_password AS password, o.cipher_certificate_number AS certificate_number FROM (SELECT a.`account_id`, a.`cipher_certificate_number`, a.`assisted_query_certificate_number`, a.`cipher_password`, a.`assisted_query_password`, a.`cipher_amount` FROM t_account `a`) o, t_account u WHERE o.assisted_query_certificate_number=u.assisted_query_certificate_number AND u.assisted_query_password=?" parameters="assisted_query_1" />
     </rewrite-assertion>
 
     <rewrite-assertion id="select_not_nested_subquery_in_table_segment_with_shorthand_project" db-types="MySQL">
         <input sql="SELECT u.amount, u.password, o.certificate_number FROM (SELECT * FROM t_account) o, t_account u WHERE o.certificate_number=u.certificate_number AND u.password=?" parameters="1" />
-        <output sql="SELECT u.cipher_amount AS amount, u.cipher_password AS password, o.cipher_certificate_number AS certificate_number FROM (SELECT `t_account`.`account_id`, `t_account`.`cipher_certificate_number`, `t_account`.`assisted_query_certificate_number`, `t_account`.`cipher_password`, `t_account`.`assisted_query_password`, `t_account`.`cipher_amount` FROM t_account) o, t_account u WHERE o.assisted_query_certificate_number=u.assisted_query_certificate_number AND u.assisted_query_password=?" parameters="assisted_query_1" />
+        <output sql="SELECT u.cipher_amount AS amount, u.cipher_password AS password, o.cipher_certificate_number AS certificate_number FROM (SELECT t_account.`account_id`, t_account.`cipher_certificate_number`, t_account.`assisted_query_certificate_number`, t_account.`cipher_password`, t_account.`assisted_query_password`, t_account.`cipher_amount` FROM t_account) o, t_account u WHERE o.assisted_query_certificate_number=u.assisted_query_certificate_number AND u.assisted_query_password=?" parameters="assisted_query_1" />
     </rewrite-assertion>
 
     <rewrite-assertion id="select_not_nested_subquery_in_predicate_right_equal_condition" db-types="MySQL">
diff --git a/test/it/rewriter/src/test/resources/scenario/mix/case/query-with-cipher/dml/select/select-projection.xml b/test/it/rewriter/src/test/resources/scenario/mix/case/query-with-cipher/dml/select/select-projection.xml
index 77166d49568..dd03c43cc7f 100644
--- a/test/it/rewriter/src/test/resources/scenario/mix/case/query-with-cipher/dml/select/select-projection.xml
+++ b/test/it/rewriter/src/test/resources/scenario/mix/case/query-with-cipher/dml/select/select-projection.xml
@@ -19,7 +19,7 @@
 <rewrite-assertions yaml-rule="scenario/mix/config/query-with-cipher.yaml">
     <rewrite-assertion id="select_with_unqualified_shorthand" db-types="MySQL">
         <input sql="SELECT * FROM t_account" />
-        <output sql="SELECT `t_account_0`.`account_id`, `t_account_0`.`cipher_password` AS `password`, `t_account_0`.`cipher_amount` AS `amount` FROM t_account_0 UNION ALL SELECT `t_account_1`.`account_id`, `t_account_1`.`cipher_password` AS `password`, `t_account_1`.`cipher_amount` AS `amount` FROM t_account_1" />
+        <output sql="SELECT t_account_0.`account_id`, t_account_0.`cipher_password` AS `password`, t_account_0.`cipher_amount` AS `amount` FROM t_account_0 UNION ALL SELECT t_account_1.`account_id`, t_account_1.`cipher_password` AS `password`, t_account_1.`cipher_amount` AS `amount` FROM t_account_1" />
     </rewrite-assertion>
     
     <rewrite-assertion id="select_with_qualified_shorthand" db-types="MySQL">
@@ -46,12 +46,12 @@
     
     <rewrite-assertion id="select_with_table_qualified_shorthand" db-types="MySQL">
         <input sql="SELECT t_account.* FROM t_account" />
-        <output sql="SELECT `t_account_0`.`account_id`, `t_account_0`.`cipher_password` AS `password`, `t_account_0`.`cipher_amount` AS `amount` FROM t_account_0 UNION ALL SELECT `t_account_1`.`account_id`, `t_account_1`.`cipher_password` AS `password`, `t_account_1`.`cipher_amount` AS `amount` FROM t_account_1" />
+        <output sql="SELECT t_account_0.`account_id`, t_account_0.`cipher_password` AS `password`, t_account_0.`cipher_amount` AS `amount` FROM t_account_0 UNION ALL SELECT t_account_1.`account_id`, t_account_1.`cipher_password` AS `password`, t_account_1.`cipher_amount` AS `amount` FROM t_account_1" />
     </rewrite-assertion>
     
     <rewrite-assertion id="select_with_schema_name_in_shorthand_projection" db-types="MySQL">
         <input sql="SELECT logic_db.t_account.* FROM t_account WHERE account_id = ?" parameters="100" />
-        <output sql="SELECT `t_account_0`.`account_id`, `t_account_0`.`cipher_password` AS `password`, `t_account_0`.`cipher_amount` AS `amount` FROM t_account_0 WHERE account_id = ?" parameters="100" />
+        <output sql="SELECT t_account_0.`account_id`, t_account_0.`cipher_password` AS `password`, t_account_0.`cipher_amount` AS `amount` FROM t_account_0 WHERE account_id = ?" parameters="100" />
     </rewrite-assertion>
     
     <rewrite-assertion id="select_with_schema_name_in_column_projection" db-types="MySQL">
