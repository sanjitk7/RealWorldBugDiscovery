


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CreatorCollector</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.deser.impl</a>
</div>

<h1>Coverage Summary for Class: CreatorCollector (com.fasterxml.jackson.databind.deser.impl)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CreatorCollector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/95)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CreatorCollector$Vanilla</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/109)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.deser.impl;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.reflect.Member;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.cfg.MapperConfig;
&nbsp;import com.fasterxml.jackson.databind.deser.CreatorProperty;
&nbsp;import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
&nbsp;import com.fasterxml.jackson.databind.deser.ValueInstantiator;
&nbsp;import com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;
&nbsp;import com.fasterxml.jackson.databind.introspect.*;
&nbsp;import com.fasterxml.jackson.databind.util.ClassUtil;
&nbsp;
&nbsp;/**
&nbsp; * Container class for storing information on creators (based on annotations,
&nbsp; * visibility), to be able to build actual instantiator later on.
&nbsp; */
&nbsp;public class CreatorCollector
&nbsp;{
&nbsp;    // Since 2.5
&nbsp;    protected final static int C_DEFAULT = 0;
&nbsp;    protected final static int C_STRING = 1;
&nbsp;    protected final static int C_INT = 2;
&nbsp;    protected final static int C_LONG = 3;
&nbsp;    protected final static int C_DOUBLE = 4;
&nbsp;    protected final static int C_BOOLEAN = 5;
&nbsp;    protected final static int C_DELEGATE = 6;
&nbsp;    protected final static int C_PROPS = 7;
&nbsp;    protected final static int C_ARRAY_DELEGATE = 8;
&nbsp;
<b class="nc">&nbsp;    protected final static String[] TYPE_DESCS = new String[] {</b>
&nbsp;        &quot;default&quot;,
&nbsp;        &quot;String&quot;, &quot;int&quot;, &quot;long&quot;, &quot;double&quot;, &quot;boolean&quot;,
&nbsp;        &quot;delegate&quot;, &quot;property-based&quot;
&nbsp;    };
&nbsp;
&nbsp;    /// Type of bean being created
&nbsp;    final protected BeanDescription _beanDesc;
&nbsp;
&nbsp;    final protected boolean _canFixAccess;
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.7
&nbsp;     */
&nbsp;    final protected boolean _forceAccess;
&nbsp;    
&nbsp;    /**
&nbsp;     * Set of creators we have collected so far
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
<b class="nc">&nbsp;    protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[9];</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Bitmask of creators that were explicitly marked as creators; false for auto-detected
&nbsp;     * (ones included base on naming and/or visibility, not annotation)
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
<b class="nc">&nbsp;    protected int _explicitCreators = 0;</b>
&nbsp;
<b class="nc">&nbsp;    protected boolean _hasNonDefaultCreator = false;</b>
&nbsp;
&nbsp;    // when there are injectable values along with delegate:
&nbsp;    protected SettableBeanProperty[] _delegateArgs;
&nbsp;
&nbsp;    protected SettableBeanProperty[] _arrayDelegateArgs;
&nbsp;
&nbsp;    protected SettableBeanProperty[] _propertyBasedArgs;
&nbsp;
&nbsp;    protected AnnotatedParameter _incompleteParameter;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Life-cycle
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    public CreatorCollector(BeanDescription beanDesc, MapperConfig&lt;?&gt; config)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        _beanDesc = beanDesc;</b>
<b class="nc">&nbsp;        _canFixAccess = config.canOverrideAccessModifiers();</b>
<b class="nc">&nbsp;        _forceAccess = config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);</b>
&nbsp;    }
&nbsp;
&nbsp;    public ValueInstantiator constructValueInstantiator(DeserializationConfig config)
&nbsp;    {
<b class="nc">&nbsp;        final JavaType delegateType = _computeDelegateType(_creators[C_DELEGATE], _delegateArgs);</b>
<b class="nc">&nbsp;        final JavaType arrayDelegateType = _computeDelegateType(_creators[C_ARRAY_DELEGATE], _arrayDelegateArgs);</b>
<b class="nc">&nbsp;        final JavaType type = _beanDesc.getType();</b>
&nbsp;
&nbsp;        // Any non-standard creator will prevent; with one exception: int-valued constructor
&nbsp;        // that standard containers have can be ignored
<b class="nc">&nbsp;        if (!_hasNonDefaultCreator) {</b>
&nbsp;            /* 10-May-2014, tatu: If we have nothing special, and we are dealing with one
&nbsp;             *   of &quot;well-known&quot; types, can create a non-reflection-based instantiator.
&nbsp;             */
<b class="nc">&nbsp;            final Class&lt;?&gt; rawType = type.getRawClass();</b>
<b class="nc">&nbsp;            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {</b>
<b class="nc">&nbsp;                return new Vanilla(Vanilla.TYPE_COLLECTION);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Map.class || rawType == LinkedHashMap.class) {</b>
<b class="nc">&nbsp;                return new Vanilla(Vanilla.TYPE_MAP);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == HashMap.class) {</b>
<b class="nc">&nbsp;                return new Vanilla(Vanilla.TYPE_HASH_MAP);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        StdValueInstantiator inst = new StdValueInstantiator(config, type);</b>
<b class="nc">&nbsp;        inst.configureFromObjectSettings(_creators[C_DEFAULT],</b>
&nbsp;                _creators[C_DELEGATE], delegateType, _delegateArgs,
&nbsp;                _creators[C_PROPS], _propertyBasedArgs);
<b class="nc">&nbsp;        inst.configureFromArraySettings(_creators[C_ARRAY_DELEGATE], arrayDelegateType, _arrayDelegateArgs);</b>
<b class="nc">&nbsp;        inst.configureFromStringCreator(_creators[C_STRING]);</b>
<b class="nc">&nbsp;        inst.configureFromIntCreator(_creators[C_INT]);</b>
<b class="nc">&nbsp;        inst.configureFromLongCreator(_creators[C_LONG]);</b>
<b class="nc">&nbsp;        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);</b>
<b class="nc">&nbsp;        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);</b>
<b class="nc">&nbsp;        inst.configureIncompleteParameter(_incompleteParameter);</b>
<b class="nc">&nbsp;        return inst;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Setters
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Method called to indicate the default creator: no-arguments
&nbsp;     * constructor or factory method that is called to instantiate
&nbsp;     * a value before populating it with data. Default creator is
&nbsp;     * only used if no other creators are indicated.
&nbsp;     * 
&nbsp;     * @param creator Creator method; no-arguments constructor or static
&nbsp;     *   factory method.
&nbsp;     */
&nbsp;    public void setDefaultCreator(AnnotatedWithParams creator) {
<b class="nc">&nbsp;        _creators[C_DEFAULT] = _fixAccess(creator);</b>
&nbsp;    }
&nbsp;    
&nbsp;    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {
<b class="nc">&nbsp;        verifyNonDup(creator, C_STRING, explicit);</b>
&nbsp;    }
&nbsp;    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {
<b class="nc">&nbsp;        verifyNonDup(creator, C_INT, explicit);</b>
&nbsp;    }
&nbsp;    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {
<b class="nc">&nbsp;        verifyNonDup(creator, C_LONG, explicit);</b>
&nbsp;    }
&nbsp;    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {
<b class="nc">&nbsp;        verifyNonDup(creator, C_DOUBLE, explicit);</b>
&nbsp;    }
&nbsp;    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {
<b class="nc">&nbsp;        verifyNonDup(creator, C_BOOLEAN, explicit);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,
&nbsp;            SettableBeanProperty[] injectables)
&nbsp;    {
<b class="nc">&nbsp;        if (creator.getParameterType(0).isCollectionLikeType()) {</b>
<b class="nc">&nbsp;            if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) {</b>
<b class="nc">&nbsp;                _arrayDelegateArgs = injectables;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            if (verifyNonDup(creator, C_DELEGATE, explicit)) {</b>
<b class="nc">&nbsp;                _delegateArgs = injectables;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,
&nbsp;            SettableBeanProperty[] properties)
&nbsp;    {
<b class="nc">&nbsp;        if (verifyNonDup(creator, C_PROPS, explicit)) {</b>
&nbsp;            // Better ensure we have no duplicate names either...
<b class="nc">&nbsp;            if (properties.length &gt; 1) {</b>
<b class="nc">&nbsp;                HashMap&lt;String,Integer&gt; names = new HashMap&lt;String,Integer&gt;();</b>
<b class="nc">&nbsp;                for (int i = 0, len = properties.length; i &lt; len; ++i) {</b>
<b class="nc">&nbsp;                    String name = properties[i].getName();</b>
&nbsp;                    /* [Issue-13]: Need to consider Injectables, which may not have
&nbsp;                     *   a name at all, and need to be skipped
&nbsp;                     */
<b class="nc">&nbsp;                    if (name.length() == 0 &amp;&amp; properties[i].getInjectableValueId() != null) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Integer old = names.put(name, Integer.valueOf(i));</b>
<b class="nc">&nbsp;                    if (old != null) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Duplicate creator property \&quot;&quot;+name+&quot;\&quot; (index &quot;+old+&quot; vs &quot;+i+&quot;)&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            _propertyBasedArgs = properties;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void addIncompeteParameter(AnnotatedParameter parameter) {
<b class="nc">&nbsp;        if (_incompleteParameter == null) {</b>
<b class="nc">&nbsp;            _incompleteParameter = parameter;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // Bunch of methods deprecated in 2.5, to be removed from 2.6 or later
&nbsp;    
&nbsp;    @Deprecated // since 2.5
&nbsp;    public void addStringCreator(AnnotatedWithParams creator) {
<b class="nc">&nbsp;        addStringCreator(creator, false);</b>
&nbsp;    }
&nbsp;    @Deprecated // since 2.5
&nbsp;    public void addIntCreator(AnnotatedWithParams creator) {
<b class="nc">&nbsp;        addBooleanCreator(creator, false);</b>
&nbsp;    }
&nbsp;    @Deprecated // since 2.5
&nbsp;    public void addLongCreator(AnnotatedWithParams creator) {
<b class="nc">&nbsp;        addBooleanCreator(creator, false);</b>
&nbsp;    }
&nbsp;    @Deprecated // since 2.5
&nbsp;    public void addDoubleCreator(AnnotatedWithParams creator) {
<b class="nc">&nbsp;        addBooleanCreator(creator, false);</b>
&nbsp;    }
&nbsp;    @Deprecated // since 2.5
&nbsp;    public void addBooleanCreator(AnnotatedWithParams creator) {
<b class="nc">&nbsp;        addBooleanCreator(creator, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated // since 2.5
&nbsp;    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {
<b class="nc">&nbsp;        addDelegatingCreator(creator, false, injectables);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated // since 2.5
&nbsp;    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {
<b class="nc">&nbsp;        addPropertyCreator(creator, false, properties);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Accessors
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public boolean hasDefaultCreator() {
<b class="nc">&nbsp;        return _creators[C_DEFAULT] != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public boolean hasDelegatingCreator() {
<b class="nc">&nbsp;        return _creators[C_DELEGATE] != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public boolean hasPropertyBasedCreator() {
<b class="nc">&nbsp;        return _creators[C_PROPS] != null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    private JavaType _computeDelegateType(AnnotatedWithParams creator,
&nbsp;            SettableBeanProperty[] delegateArgs)
&nbsp;    {
<b class="nc">&nbsp;        if (!_hasNonDefaultCreator || (creator == null)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // need to find type...
<b class="nc">&nbsp;        int ix = 0;</b>
<b class="nc">&nbsp;        if (delegateArgs != null) {</b>
<b class="nc">&nbsp;            for (int i = 0, len = delegateArgs.length; i &lt; len; ++i) {</b>
<b class="nc">&nbsp;                if (delegateArgs[i] == null) { // marker for delegate itself</b>
<b class="nc">&nbsp;                    ix = i;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return creator.getParameterType(ix);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T extends AnnotatedMember&gt; T _fixAccess(T member)
&nbsp;    {
<b class="nc">&nbsp;        if (member != null &amp;&amp; _canFixAccess) {</b>
<b class="nc">&nbsp;            ClassUtil.checkAndFixAccess((Member) member.getAnnotated(), _forceAccess);</b>
&nbsp;        }
<b class="nc">&nbsp;        return member;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return True if specified Creator is to be used
&nbsp;     */
&nbsp;    protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
&nbsp;    {
<b class="nc">&nbsp;        final int mask = (1 &lt;&lt; typeIndex);</b>
<b class="nc">&nbsp;        _hasNonDefaultCreator = true;</b>
<b class="nc">&nbsp;        AnnotatedWithParams oldOne = _creators[typeIndex];</b>
&nbsp;        // already had an explicitly marked one?
<b class="nc">&nbsp;        if (oldOne != null) {</b>
&nbsp;            boolean verify;
<b class="nc">&nbsp;            if ((_explicitCreators &amp; mask) != 0) { // already had explicitly annotated, leave as-is</b>
&nbsp;                // but skip, if new one not annotated
<b class="nc">&nbsp;                if (!explicit) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;                // both explicit: verify
<b class="nc">&nbsp;                verify = true;</b>
&nbsp;            } else {
&nbsp;                // otherwise only verify if neither explicitly annotated.
<b class="nc">&nbsp;                verify = !explicit;</b>
&nbsp;            }
&nbsp;
&nbsp;            // one more thing: ok to override in sub-class
<b class="nc">&nbsp;            if (verify &amp;&amp; (oldOne.getClass() == newOne.getClass())) {</b>
&nbsp;                // [databind#667]: avoid one particular class of bogus problems
<b class="nc">&nbsp;                Class&lt;?&gt; oldType = oldOne.getRawParameterType(0);</b>
<b class="nc">&nbsp;                Class&lt;?&gt; newType = newOne.getRawParameterType(0);</b>
&nbsp;
<b class="nc">&nbsp;                if (oldType == newType) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Conflicting &quot;+TYPE_DESCS[typeIndex]</b>
&nbsp;                            +&quot; creators: already had explicitly marked &quot;+oldOne+&quot;, encountered &quot;+newOne);
&nbsp;                }
&nbsp;                // otherwise, which one to choose?
<b class="nc">&nbsp;                if (newType.isAssignableFrom(oldType)) {</b>
&nbsp;                    // new type more generic, use old
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;                // new type more specific, use it
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (explicit) {</b>
<b class="nc">&nbsp;            _explicitCreators |= mask;</b>
&nbsp;        }
<b class="nc">&nbsp;        _creators[typeIndex] = _fixAccess(newOne);</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper class(es)
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    protected final static class Vanilla
&nbsp;        extends ValueInstantiator
&nbsp;        implements java.io.Serializable
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        public final static int TYPE_COLLECTION = 1;
&nbsp;        public final static int TYPE_MAP = 2;
&nbsp;        public final static int TYPE_HASH_MAP = 3;
&nbsp;
&nbsp;        private final int _type;
&nbsp;        
<b class="nc">&nbsp;        public Vanilla(int t) {</b>
<b class="nc">&nbsp;            _type = t;</b>
&nbsp;        }
&nbsp;        
&nbsp;        
&nbsp;        @Override
&nbsp;        public String getValueTypeDesc() {
<b class="nc">&nbsp;            switch (_type) {</b>
<b class="nc">&nbsp;            case TYPE_COLLECTION: return ArrayList.class.getName();</b>
<b class="nc">&nbsp;            case TYPE_MAP: return LinkedHashMap.class.getName();</b>
<b class="nc">&nbsp;            case TYPE_HASH_MAP: return HashMap.class.getName();</b>
&nbsp;            }
<b class="nc">&nbsp;            return Object.class.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        public boolean canInstantiate() { return true; }</b>
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        public boolean canCreateUsingDefault() {  return true; }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {
<b class="nc">&nbsp;            switch (_type) {</b>
<b class="nc">&nbsp;            case TYPE_COLLECTION: return new ArrayList&lt;Object&gt;();</b>
<b class="nc">&nbsp;            case TYPE_MAP: return new LinkedHashMap&lt;String,Object&gt;();</b>
<b class="nc">&nbsp;            case TYPE_HASH_MAP: return new HashMap&lt;String,Object&gt;();</b>
&nbsp;            }
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Unknown type &quot;+_type);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-02 19:53</div>
</div>
</body>
</html>
