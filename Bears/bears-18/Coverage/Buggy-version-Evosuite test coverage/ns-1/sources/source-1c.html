


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > POJOPropertyBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.introspect</a>
</div>

<h1>Coverage Summary for Class: POJOPropertyBuilder (com.fasterxml.jackson.databind.introspect)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">POJOPropertyBuilder</td>
<td class="coverageStat">
  <span class="percent">
    1.4%
  </span>
  <span class="absValue">
    (1/72)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.4%
  </span>
  <span class="absValue">
    (2/468)
  </span>
</td>
</tr>
  <tr>
    <td class="name">POJOPropertyBuilder$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$Linked</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$MemberIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$WithMember</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    1%
  </span>
  <span class="absValue">
    (1/104)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.4%
  </span>
  <span class="absValue">
    (2/549)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.introspect;
&nbsp;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import com.fasterxml.jackson.annotation.JsonInclude;
&nbsp;import com.fasterxml.jackson.annotation.JsonProperty;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.cfg.MapperConfig;
&nbsp;import com.fasterxml.jackson.databind.util.ClassUtil;
&nbsp;
&nbsp;/**
&nbsp; * Helper class used for aggregating information about a single
&nbsp; * potential POJO property.
&nbsp; */
&nbsp;public class POJOPropertyBuilder
&nbsp;    extends BeanPropertyDefinition
&nbsp;    implements Comparable&lt;POJOPropertyBuilder&gt;
&nbsp;{
&nbsp;    /**
&nbsp;     * Whether property is being composed for serialization
&nbsp;     * (true) or deserialization (false)
&nbsp;     */
&nbsp;    protected final boolean _forSerialization;
&nbsp;
&nbsp;    protected final MapperConfig&lt;?&gt; _config;
&nbsp;
&nbsp;    protected final AnnotationIntrospector _annotationIntrospector;
&nbsp;
<b class="fc">&nbsp;    /**</b>
<b class="fc">&nbsp;     * External name of logical property; may change with</b>
&nbsp;     * renaming (by new instance being constructed using
&nbsp;     * a new name)
&nbsp;     */
&nbsp;    protected final PropertyName _name;
&nbsp;
&nbsp;    /**
&nbsp;     * Original internal name, derived from accessor, of this
&nbsp;     * property. Will not be changed by renaming.
&nbsp;     */
&nbsp;    protected final PropertyName _internalName;
&nbsp;
&nbsp;    protected Linked&lt;AnnotatedField&gt; _fields;
&nbsp;
&nbsp;    protected Linked&lt;AnnotatedParameter&gt; _ctorParameters;
&nbsp;
&nbsp;    protected Linked&lt;AnnotatedMethod&gt; _getters;
&nbsp;
&nbsp;    protected Linked&lt;AnnotatedMethod&gt; _setters;
&nbsp;
&nbsp;    public POJOPropertyBuilder(MapperConfig&lt;?&gt; config, AnnotationIntrospector ai,
&nbsp;            boolean forSerialization, PropertyName internalName) {
&nbsp;        this(config, ai, forSerialization, internalName, internalName);
&nbsp;    }
&nbsp;
&nbsp;    protected POJOPropertyBuilder(MapperConfig&lt;?&gt; config, AnnotationIntrospector ai,
&nbsp;            boolean forSerialization, PropertyName internalName, PropertyName name)
&nbsp;    {
&nbsp;        _config = config;
&nbsp;        _annotationIntrospector = ai;
&nbsp;        _internalName = internalName;
&nbsp;        _name = name;
&nbsp;        _forSerialization = forSerialization;
&nbsp;    }
&nbsp;
&nbsp;    public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName)
&nbsp;    {
&nbsp;        _config = src._config;
&nbsp;        _annotationIntrospector = src._annotationIntrospector;
&nbsp;        _internalName = src._internalName;
&nbsp;        _name = newName;
&nbsp;        _fields = src._fields;
&nbsp;        _ctorParameters = src._ctorParameters;
&nbsp;        _getters = src._getters;
&nbsp;        _setters = src._setters;
<b class="nc">&nbsp;        _forSerialization = src._forSerialization;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
<b class="nc">&nbsp;    /* Fluent factory methods</b>
<b class="nc">&nbsp;    /**********************************************************</b>
<b class="nc">&nbsp;     */</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public POJOPropertyBuilder withName(PropertyName newName) {</b>
<b class="nc">&nbsp;        return new POJOPropertyBuilder(this, newName);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
<b class="nc">&nbsp;    public POJOPropertyBuilder withSimpleName(String newSimpleName)</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        PropertyName newName = _name.withSimpleName(newSimpleName);</b>
<b class="nc">&nbsp;        return (newName == _name) ? this : new POJOPropertyBuilder(this, newName);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    </b>
<b class="nc">&nbsp;    /*</b>
<b class="nc">&nbsp;    /**********************************************************</b>
<b class="nc">&nbsp;    /* Comparable implementation: sort alphabetically, except</b>
<b class="nc">&nbsp;    /* that properties with constructor parameters sorted</b>
<b class="nc">&nbsp;    /* before other properties</b>
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public int compareTo(POJOPropertyBuilder other)
&nbsp;    {
&nbsp;        // first, if one has ctor params, that should come first:
&nbsp;        if (_ctorParameters != null) {
&nbsp;            if (other._ctorParameters == null) {
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
&nbsp;        } else if (other._ctorParameters != null) {
&nbsp;            return 1;
&nbsp;        }
&nbsp;        /* otherwise sort by external name (including sorting of
<b class="nc">&nbsp;         * ctor parameters)</b>
<b class="nc">&nbsp;         */</b>
&nbsp;        return getName().compareTo(other.getName());
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* BeanPropertyDefinition implementation, name/type
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public String getName() {
&nbsp;        return (_name == null) ? null : _name.getSimpleName();
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public PropertyName getFullName() {</b>
<b class="nc">&nbsp;        return _name;</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Override</b>
&nbsp;    public boolean hasName(PropertyName name) {
&nbsp;        return _name.equals(name);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Override</b>
&nbsp;    public String getInternalName() { return _internalName.getSimpleName(); }
&nbsp;
&nbsp;    @Override
&nbsp;    public PropertyName getWrapperName() {
&nbsp;        /* 13-Mar-2013, tatu: Accessing via primary member SHOULD work,
&nbsp;         *   due to annotation merging. However, I have seen some problems
&nbsp;         *   with this access (for other annotations)... so if this should
&nbsp;         *   occur, try commenting out full traversal code
&nbsp;         */
&nbsp;        AnnotatedMember member = getPrimaryMember();
<b class="nc">&nbsp;        return (member == null || _annotationIntrospector == null) ? null</b>
&nbsp;                : _annotationIntrospector.findWrapperName(member);
&nbsp;    	/*
&nbsp;        return fromMemberAnnotations(new WithMember&lt;PropertyName&gt;() {
&nbsp;            @Override
<b class="nc">&nbsp;            public PropertyName withMember(AnnotatedMember member) {</b>
&nbsp;                return _annotationIntrospector.findWrapperName(member);
&nbsp;            }
&nbsp;        });
&nbsp;        */
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isExplicitlyIncluded() {
<b class="nc">&nbsp;        return _anyExplicits(_fields)</b>
&nbsp;                || _anyExplicits(_getters)
&nbsp;                || _anyExplicits(_setters)
&nbsp;                || _anyExplicits(_ctorParameters)
&nbsp;                ;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isExplicitlyNamed() {
<b class="nc">&nbsp;        return _anyExplicitNames(_fields)</b>
<b class="nc">&nbsp;                || _anyExplicitNames(_getters)</b>
<b class="nc">&nbsp;                || _anyExplicitNames(_setters)</b>
&nbsp;                || _anyExplicitNames(_ctorParameters)
&nbsp;                ;
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* BeanPropertyDefinition implementation, accessor access
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasGetter() { return _getters != null; }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public boolean hasSetter() { return _setters != null; }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasField() { return _fields != null; }
&nbsp;
<b class="nc">&nbsp;    @Override</b>
&nbsp;    public boolean hasConstructorParameter() { return _ctorParameters != null; }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean couldDeserialize() {
&nbsp;        return (_ctorParameters != null) || (_setters != null) || (_fields != null);
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public boolean couldSerialize() {</b>
&nbsp;        return (_getters != null) || (_fields != null);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotatedMethod getGetter()
&nbsp;    {
&nbsp;        // Easy with zero or one getters...
&nbsp;        Linked&lt;AnnotatedMethod&gt; curr = _getters;
&nbsp;        if (curr == null) {
&nbsp;            return null;
&nbsp;        }
<b class="nc">&nbsp;        Linked&lt;AnnotatedMethod&gt; next = curr.next;</b>
<b class="nc">&nbsp;        if (next == null) {</b>
<b class="nc">&nbsp;            return curr.value;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        // But if multiple, verify that they do not conflict...</b>
<b class="nc">&nbsp;        for (; next != null; next = next.next) {</b>
<b class="nc">&nbsp;            /* [JACKSON-255] Allow masking, i.e. do not report exception if one</b>
<b class="nc">&nbsp;             *   is in super-class from the other</b>
&nbsp;             */
<b class="nc">&nbsp;            Class&lt;?&gt; currClass = curr.value.getDeclaringClass();</b>
&nbsp;            Class&lt;?&gt; nextClass = next.value.getDeclaringClass();
<b class="nc">&nbsp;            if (currClass != nextClass) {</b>
<b class="nc">&nbsp;                if (currClass.isAssignableFrom(nextClass)) { // next is more specific</b>
&nbsp;                    curr = next;
&nbsp;                    continue;
<b class="nc">&nbsp;                }</b>
&nbsp;                if (nextClass.isAssignableFrom(currClass)) { // current more specific
&nbsp;                    continue;
&nbsp;                }
&nbsp;            }
&nbsp;            /* 30-May-2014, tatu: Three levels of precedence:
&nbsp;             * 
&nbsp;             * 1. Regular getters (&quot;getX&quot;)
&nbsp;             * 2. Is-getters (&quot;isX&quot;)
&nbsp;             * 3. Implicit, possible getters (&quot;x&quot;)
<b class="nc">&nbsp;             */</b>
<b class="nc">&nbsp;            int priNext = _getterPriority(next.value);</b>
<b class="nc">&nbsp;            int priCurr = _getterPriority(curr.value);</b>
&nbsp;
&nbsp;            if (priNext != priCurr) {
&nbsp;                if (priNext &lt; priCurr) {
<b class="nc">&nbsp;                    curr = next;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                continue;
<b class="nc">&nbsp;            }</b>
&nbsp;            throw new IllegalArgumentException(&quot;Conflicting getter definitions for property \&quot;&quot;+getName()+&quot;\&quot;: &quot;
<b class="nc">&nbsp;                    +curr.value.getFullName()+&quot; vs &quot;+next.value.getFullName());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        // One more thing; to avoid having to do it again...</b>
<b class="nc">&nbsp;        _getters = curr.withoutNext();</b>
<b class="nc">&nbsp;        return curr.value;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    </b>
&nbsp;    @Override
&nbsp;    public AnnotatedMethod getSetter()
&nbsp;    {
<b class="nc">&nbsp;        // Easy with zero or one getters...</b>
<b class="nc">&nbsp;        Linked&lt;AnnotatedMethod&gt; curr = _setters;</b>
<b class="nc">&nbsp;        if (curr == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        Linked&lt;AnnotatedMethod&gt; next = curr.next;
&nbsp;        if (next == null) {
&nbsp;            return curr.value;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        // But if multiple, verify that they do not conflict...</b>
<b class="nc">&nbsp;        for (; next != null; next = next.next) {</b>
<b class="nc">&nbsp;            // Allow masking, i.e. do not fail if one is in super-class from the other</b>
<b class="nc">&nbsp;            Class&lt;?&gt; currClass = curr.value.getDeclaringClass();</b>
<b class="nc">&nbsp;            Class&lt;?&gt; nextClass = next.value.getDeclaringClass();</b>
<b class="nc">&nbsp;            if (currClass != nextClass) {</b>
&nbsp;                if (currClass.isAssignableFrom(nextClass)) { // next is more specific
<b class="nc">&nbsp;                    curr = next;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                if (nextClass.isAssignableFrom(currClass)) { // current more specific
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            AnnotatedMethod nextM = next.value;</b>
<b class="nc">&nbsp;            AnnotatedMethod currM = curr.value;</b>
<b class="nc">&nbsp;</b>
&nbsp;            /* 30-May-2014, tatu: Two levels of precedence:
&nbsp;             * 
&nbsp;             * 1. Regular setters (&quot;setX(...)&quot;)
&nbsp;             * 2. Implicit, possible setters (&quot;x(...)&quot;)
&nbsp;             */
<b class="nc">&nbsp;            int priNext = _setterPriority(nextM);</b>
<b class="nc">&nbsp;            int priCurr = _setterPriority(currM);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            if (priNext != priCurr) {</b>
&nbsp;                if (priNext &lt; priCurr) {
<b class="nc">&nbsp;                    curr = next;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                continue;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            // 11-Dec-2015, tatu: As per [databind#1033] allow pluggable conflict resolution</b>
<b class="nc">&nbsp;            if (_annotationIntrospector != null) {</b>
<b class="nc">&nbsp;                AnnotatedMethod pref = _annotationIntrospector.resolveSetterConflict(_config,</b>
<b class="nc">&nbsp;                        currM, nextM);</b>
&nbsp;                
&nbsp;                // note: should be one of nextM/currM; but no need to check
&nbsp;                if (pref == currM) {
&nbsp;                    continue;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (pref == nextM) {</b>
&nbsp;                    curr = next;
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            throw new IllegalArgumentException(String.format(
&nbsp; &quot;Conflicting setter definitions for property \&quot;%s\&quot;: %s vs %s&quot;,
&nbsp; getName(), curr.value.getFullName(), next.value.getFullName()));
&nbsp;        }
&nbsp;        // One more thing; to avoid having to do it again...
&nbsp;        _setters = curr.withoutNext();
&nbsp;        return curr.value;
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public AnnotatedField getField()</b>
<b class="nc">&nbsp;    {</b>
&nbsp;        if (_fields == null) {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        // If multiple, verify that they do not conflict...</b>
&nbsp;        AnnotatedField field = _fields.value;
<b class="nc">&nbsp;        Linked&lt;AnnotatedField&gt; next = _fields.next;</b>
&nbsp;        for (; next != null; next = next.next) {
<b class="nc">&nbsp;            AnnotatedField nextField = next.value;</b>
<b class="nc">&nbsp;            Class&lt;?&gt; fieldClass = field.getDeclaringClass();</b>
<b class="nc">&nbsp;            Class&lt;?&gt; nextClass = nextField.getDeclaringClass();</b>
&nbsp;            if (fieldClass != nextClass) {
&nbsp;                if (fieldClass.isAssignableFrom(nextClass)) { // next is more specific
<b class="nc">&nbsp;                    field = nextField;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (nextClass.isAssignableFrom(fieldClass)) { // getter more specific</b>
&nbsp;                    continue;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Multiple fields representing property \&quot;&quot;+getName()+&quot;\&quot;: &quot;</b>
<b class="nc">&nbsp;                    +field.getFullName()+&quot; vs &quot;+nextField.getFullName());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return field;
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    @Override
&nbsp;    public AnnotatedParameter getConstructorParameter()
&nbsp;    {
&nbsp;        if (_ctorParameters == null) {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        /* Hmmh. Checking for constructor parameters is trickier; for one,
&nbsp;         * we must allow creator and factory method annotations.
&nbsp;         * If this is the case, constructor parameter has the precedence.
&nbsp;         * 
&nbsp;         * So, for now, just try finding the first constructor parameter;
&nbsp;         * if none, first factory method. And don&#39;t check for dups, if we must,
&nbsp;         * can start checking for them later on.
&nbsp;         */
<b class="nc">&nbsp;        Linked&lt;AnnotatedParameter&gt; curr = _ctorParameters;</b>
&nbsp;        do {
&nbsp;            if (curr.value.getOwner() instanceof AnnotatedConstructor) {
<b class="nc">&nbsp;                return curr.value;</b>
&nbsp;            }
&nbsp;            curr = curr.next;
<b class="nc">&nbsp;        } while (curr != null);</b>
&nbsp;        return _ctorParameters.value;
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    @Override
&nbsp;    public Iterator&lt;AnnotatedParameter&gt; getConstructorParameters() {
&nbsp;        if (_ctorParameters == null) {
<b class="nc">&nbsp;            return ClassUtil.emptyIterator();</b>
&nbsp;        }
&nbsp;        return new MemberIterator&lt;AnnotatedParameter&gt;(_ctorParameters);
&nbsp;    }
&nbsp;    
<b class="nc">&nbsp;    @Override</b>
&nbsp;    public AnnotatedMember getAccessor()
&nbsp;    {
&nbsp;        AnnotatedMember m = getGetter();
&nbsp;        if (m == null) {
&nbsp;            m = getField();
&nbsp;        }
<b class="nc">&nbsp;        return m;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    @Override
<b class="nc">&nbsp;    public AnnotatedMember getMutator()</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        AnnotatedMember m = getConstructorParameter();</b>
&nbsp;        if (m == null) {
&nbsp;            m = getSetter();
<b class="nc">&nbsp;            if (m == null) {</b>
&nbsp;                m = getField();
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return m;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public AnnotatedMember getNonConstructorMutator() {</b>
<b class="nc">&nbsp;        AnnotatedMember m = getSetter();</b>
&nbsp;        if (m == null) {
<b class="nc">&nbsp;            m = getField();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return m;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotatedMember getPrimaryMember() {
&nbsp;        if (_forSerialization) {
&nbsp;            return getAccessor();
&nbsp;        }
<b class="nc">&nbsp;        return getMutator();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    protected int _getterPriority(AnnotatedMethod m)</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        final String name = m.getName();</b>
&nbsp;        // [databind#238]: Also, regular getters have precedence over &quot;is-getters&quot;
&nbsp;        if (name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3) {
&nbsp;            // should we check capitalization?
<b class="nc">&nbsp;            return 1;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        if (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2) {
&nbsp;            return 2;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return 3;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected int _setterPriority(AnnotatedMethod m)
&nbsp;    {
&nbsp;        final String name = m.getName();
&nbsp;        if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) {
<b class="nc">&nbsp;            // should we check capitalization?</b>
<b class="nc">&nbsp;            return 1;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return 2;
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    /*</b>
&nbsp;    /**********************************************************
&nbsp;    /* Implementations of refinement accessors
<b class="nc">&nbsp;    /**********************************************************</b>
&nbsp;     */
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public Class&lt;?&gt;[] findViews() {</b>
<b class="nc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;Class&lt;?&gt;[]&gt;() {</b>
<b class="nc">&nbsp;            @Override</b>
<b class="nc">&nbsp;            public Class&lt;?&gt;[] withMember(AnnotatedMember member) {</b>
<b class="nc">&nbsp;                return _annotationIntrospector.findViews(member);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        });</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public AnnotationIntrospector.ReferenceProperty findReferenceType() {</b>
<b class="nc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;AnnotationIntrospector.ReferenceProperty&gt;() {</b>
&nbsp;            @Override
&nbsp;            public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) {
<b class="nc">&nbsp;                return _annotationIntrospector.findReferenceType(member);</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    @Override
<b class="nc">&nbsp;    public boolean isTypeId() {</b>
<b class="nc">&nbsp;        Boolean b = fromMemberAnnotations(new WithMember&lt;Boolean&gt;() {</b>
<b class="nc">&nbsp;            @Override</b>
&nbsp;            public Boolean withMember(AnnotatedMember member) {
<b class="nc">&nbsp;                return _annotationIntrospector.isTypeId(member);</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        return (b != null) &amp;&amp; b.booleanValue();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public PropertyMetadata getMetadata() {
<b class="nc">&nbsp;        final Boolean b = _findRequired();</b>
<b class="nc">&nbsp;        final String desc = _findDescription();</b>
&nbsp;        final Integer idx = _findIndex();
<b class="nc">&nbsp;        final String def = _findDefaultValue();</b>
<b class="nc">&nbsp;        if (b == null &amp;&amp; idx == null &amp;&amp; def == null) {</b>
<b class="nc">&nbsp;            return (desc == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL</b>
&nbsp;                    : PropertyMetadata.STD_REQUIRED_OR_OPTIONAL.withDescription(desc);
&nbsp;        }
<b class="nc">&nbsp;        return PropertyMetadata.construct(b.booleanValue(), desc, idx, def);</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    protected Boolean _findRequired() {
<b class="nc">&nbsp;       return fromMemberAnnotations(new WithMember&lt;Boolean&gt;() {</b>
<b class="nc">&nbsp;            @Override</b>
<b class="nc">&nbsp;            public Boolean withMember(AnnotatedMember member) {</b>
<b class="nc">&nbsp;                return _annotationIntrospector.hasRequiredMarker(member);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;    
<b class="nc">&nbsp;    protected String _findDescription() {</b>
<b class="nc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;String&gt;() {</b>
&nbsp;            @Override
&nbsp;            public String withMember(AnnotatedMember member) {
<b class="nc">&nbsp;                return _annotationIntrospector.findPropertyDescription(member);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        });</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    protected Integer _findIndex() {</b>
<b class="nc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;Integer&gt;() {</b>
<b class="nc">&nbsp;            @Override</b>
<b class="nc">&nbsp;            public Integer withMember(AnnotatedMember member) {</b>
<b class="nc">&nbsp;                return _annotationIntrospector.findPropertyIndex(member);</b>
&nbsp;            }
<b class="nc">&nbsp;        });</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected String _findDefaultValue() {
<b class="nc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;String&gt;() {</b>
<b class="nc">&nbsp;            @Override</b>
&nbsp;            public String withMember(AnnotatedMember member) {
<b class="nc">&nbsp;                return _annotationIntrospector.findPropertyDefaultValue(member);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;    
&nbsp;    @Override
<b class="nc">&nbsp;    public ObjectIdInfo findObjectIdInfo() {</b>
<b class="nc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;ObjectIdInfo&gt;() {</b>
&nbsp;            @Override
&nbsp;            public ObjectIdInfo withMember(AnnotatedMember member) {
<b class="nc">&nbsp;                ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(member);</b>
<b class="nc">&nbsp;                if (info != null) {</b>
<b class="nc">&nbsp;                    info = _annotationIntrospector.findObjectReferenceInfo(member, info);</b>
&nbsp;                }
<b class="nc">&nbsp;                return info;</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    @Override</b>
<b class="nc">&nbsp;    public JsonInclude.Value findInclusion() {</b>
&nbsp;        AnnotatedMember a = getAccessor();
<b class="nc">&nbsp;        // 16-Apr-2106, tatu: Let&#39;s include per-type default inclusion too</b>
<b class="nc">&nbsp;        // 17-Aug-2016, tatu: Do NOT include global, or per-type defaults, because</b>
<b class="nc">&nbsp;        //    not all of this information (specifically, enclosing type&#39;s settings)</b>
&nbsp;        //    is available here
&nbsp;        JsonInclude.Value v = (_annotationIntrospector == null) ?
&nbsp;                null : _annotationIntrospector.findPropertyInclusion(a);
&nbsp;        return (v == null) ? JsonInclude.Value.empty() : v;
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public JsonProperty.Access findAccess() {
<b class="nc">&nbsp;        return fromMemberAnnotationsExcept(new WithMember&lt;JsonProperty.Access&gt;() {</b>
&nbsp;            @Override
&nbsp;            public JsonProperty.Access withMember(AnnotatedMember member) {
<b class="nc">&nbsp;                return _annotationIntrospector.findPropertyAccess(member);</b>
&nbsp;            }
<b class="nc">&nbsp;        }, JsonProperty.Access.AUTO);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
<b class="nc">&nbsp;    /*</b>
&nbsp;    /**********************************************************
<b class="nc">&nbsp;    /* Data aggregation</b>
<b class="nc">&nbsp;    /**********************************************************</b>
&nbsp;     */
<b class="nc">&nbsp;    </b>
&nbsp;    public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored) {
&nbsp;        _fields = new Linked&lt;AnnotatedField&gt;(a, _fields, name, explName, visible, ignored);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public void addCtor(AnnotatedParameter a, PropertyName name, boolean explName, boolean visible, boolean ignored) {</b>
&nbsp;        _ctorParameters = new Linked&lt;AnnotatedParameter&gt;(a, _ctorParameters, name, explName, visible, ignored);
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public void addGetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {</b>
&nbsp;        _getters = new Linked&lt;AnnotatedMethod&gt;(a, _getters, name, explName, visible, ignored);
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public void addSetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {
<b class="nc">&nbsp;        _setters = new Linked&lt;AnnotatedMethod&gt;(a, _setters, name, explName, visible, ignored);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for adding all property members from specified collector into
<b class="nc">&nbsp;     * this collector.</b>
<b class="nc">&nbsp;     */</b>
&nbsp;    public void addAll(POJOPropertyBuilder src)
<b class="nc">&nbsp;    {</b>
&nbsp;        _fields = merge(_fields, src._fields);
<b class="nc">&nbsp;        _ctorParameters = merge(_ctorParameters, src._ctorParameters);</b>
&nbsp;        _getters= merge(_getters, src._getters);
&nbsp;        _setters = merge(_setters, src._setters);
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T&gt; Linked&lt;T&gt; merge(Linked&lt;T&gt; chain1, Linked&lt;T&gt; chain2)
&nbsp;    {
&nbsp;        if (chain1 == null) {
&nbsp;            return chain2;
&nbsp;        }
&nbsp;        if (chain2 == null) {
<b class="nc">&nbsp;            return chain1;</b>
&nbsp;        }
&nbsp;        return chain1.append(chain2);
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Modifications
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
<b class="nc">&nbsp;     * Method called to remove all entries that are marked as</b>
<b class="nc">&nbsp;     * ignored.</b>
<b class="nc">&nbsp;     */</b>
<b class="nc">&nbsp;    public void removeIgnored()</b>
&nbsp;    {
<b class="nc">&nbsp;        _fields = _removeIgnored(_fields);</b>
&nbsp;        _getters = _removeIgnored(_getters);
<b class="nc">&nbsp;        _setters = _removeIgnored(_setters);</b>
&nbsp;        _ctorParameters = _removeIgnored(_ctorParameters);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param inferMutators Whether mutators can be &quot;pulled in&quot; by visible
<b class="nc">&nbsp;     *    accessors or not. </b>
<b class="nc">&nbsp;     */</b>
&nbsp;    public void removeNonVisible(boolean inferMutators)
&nbsp;    {
&nbsp;        /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition
&nbsp;         *  of explicit access type for property; if not &quot;AUTO&quot;, it will
<b class="nc">&nbsp;         *  dictate how visibility checks are applied.</b>
&nbsp;         */
&nbsp;        JsonProperty.Access acc = findAccess();
&nbsp;        if (acc == null) {
&nbsp;            acc = JsonProperty.Access.AUTO;
&nbsp;        }
<b class="nc">&nbsp;        switch (acc) {</b>
&nbsp;        case READ_ONLY:
&nbsp;            // Remove setters, creators for sure, but fields too if deserializing
&nbsp;            _setters = null;
<b class="nc">&nbsp;            _ctorParameters = null;</b>
&nbsp;            if (!_forSerialization) {
&nbsp;                _fields = null;
&nbsp;            }
&nbsp;            break;
&nbsp;        case READ_WRITE:
&nbsp;            // no trimming whatsoever?
&nbsp;            break;
&nbsp;        case WRITE_ONLY:
<b class="nc">&nbsp;            // remove getters, definitely, but also fields if serializing</b>
&nbsp;            _getters = null;
&nbsp;            if (_forSerialization) {
&nbsp;                _fields = null;
&nbsp;            }
&nbsp;            break;
&nbsp;        default:
&nbsp;        case AUTO: // the default case: base it imply on visibility
&nbsp;            _getters = _removeNonVisible(_getters);
<b class="nc">&nbsp;            _ctorParameters = _removeNonVisible(_ctorParameters);</b>
&nbsp;    
&nbsp;            if (!inferMutators || (_getters == null)) {
&nbsp;                _fields = _removeNonVisible(_fields);
&nbsp;                _setters = _removeNonVisible(_setters);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    /**</b>
&nbsp;     * Mutator that will simply drop any constructor parameters property may have.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public void removeConstructors() {
&nbsp;        _ctorParameters = null;
&nbsp;    }
&nbsp;    
&nbsp;    /**
<b class="nc">&nbsp;     * Method called to trim unnecessary entries, such as implicit</b>
&nbsp;     * getter if there is an explict one available. This is important
&nbsp;     * for later stages, to avoid unnecessary conflicts.
&nbsp;     */
&nbsp;    public void trimByVisibility()
&nbsp;    {
&nbsp;        _fields = _trimByVisibility(_fields);
&nbsp;        _getters = _trimByVisibility(_getters);
&nbsp;        _setters = _trimByVisibility(_setters);
&nbsp;        _ctorParameters = _trimByVisibility(_ctorParameters);
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public void mergeAnnotations(boolean forSerialization)
<b class="nc">&nbsp;    {</b>
&nbsp;        if (forSerialization) {
&nbsp;            if (_getters != null) {
&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters);
&nbsp;                _getters = _applyAnnotations(_getters, ann);
<b class="nc">&nbsp;            } else if (_fields != null) {</b>
<b class="nc">&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters);</b>
<b class="nc">&nbsp;                _fields = _applyAnnotations(_fields, ann);</b>
&nbsp;            }
&nbsp;        } else { // for deserialization
&nbsp;            if (_ctorParameters != null) {
<b class="nc">&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters);</b>
&nbsp;                _ctorParameters = _applyAnnotations(_ctorParameters, ann);
&nbsp;            } else if (_setters != null) {
&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters);
&nbsp;                _setters = _applyAnnotations(_setters, ann);
&nbsp;            } else if (_fields != null) {
&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _fields, _getters);
&nbsp;                _fields = _applyAnnotations(_fields, ann);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private AnnotationMap _mergeAnnotations(int index,
&nbsp;            Linked&lt;? extends AnnotatedMember&gt;... nodes)
&nbsp;    {
<b class="nc">&nbsp;        AnnotationMap ann = _getAllAnnotations(nodes[index]);</b>
<b class="nc">&nbsp;        while (++index &lt; nodes.length) {</b>
&nbsp;            if (nodes[index] != null) {
&nbsp;              return AnnotationMap.merge(ann, _mergeAnnotations(index, nodes));
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        return ann;
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    /**</b>
&nbsp;     * Replacement, as per [databind#868], of simple access to annotations, which
&nbsp;     * does &quot;deep merge&quot; if an as necessary.
<b class="nc">&nbsp;     *&lt;pre&gt;</b>
<b class="nc">&nbsp;     * nodes[index].value.getAllAnnotations()</b>
&nbsp;     *&lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    private &lt;T extends AnnotatedMember&gt; AnnotationMap _getAllAnnotations(Linked&lt;T&gt; node) {
&nbsp;        AnnotationMap ann = node.value.getAllAnnotations();
&nbsp;        if (node.next != null) {
<b class="nc">&nbsp;            ann = AnnotationMap.merge(ann, _getAllAnnotations(node.next));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return ann;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    /**
&nbsp;     * Helper method to handle recursive merging of annotations within accessor class,
&nbsp;     * to ensure no annotations are accidentally dropped within chain when non-visible
<b class="nc">&nbsp;     * and secondary accessors are pruned later on.</b>
<b class="nc">&nbsp;     *&lt;p&gt;</b>
&nbsp;     * See [databind#868] for more information.
<b class="nc">&nbsp;     *</b>
<b class="nc">&nbsp;     * @since 2.6</b>
&nbsp;     */
<b class="nc">&nbsp;    private &lt;T extends AnnotatedMember&gt; Linked&lt;T&gt; _applyAnnotations(Linked&lt;T&gt; node, AnnotationMap ann) {</b>
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        T value = (T) node.value.withAnnotations(ann);
&nbsp;        if (node.next != null) {
&nbsp;            node = node.withNext(_applyAnnotations(node.next, ann));
&nbsp;        }
&nbsp;        return node.withValue(value);
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; Linked&lt;T&gt; _removeIgnored(Linked&lt;T&gt; node)
&nbsp;    {
&nbsp;        if (node == null) {
&nbsp;            return node;
&nbsp;        }
&nbsp;        return node.withoutIgnored();
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private &lt;T&gt; Linked&lt;T&gt; _removeNonVisible(Linked&lt;T&gt; node)</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        if (node == null) {</b>
&nbsp;            return node;
&nbsp;        }
&nbsp;        return node.withoutNonVisible();
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; Linked&lt;T&gt; _trimByVisibility(Linked&lt;T&gt; node)
&nbsp;    {
&nbsp;        if (node == null) {
&nbsp;            return node;
&nbsp;        }
&nbsp;        return node.trimByVisibility();
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;        </b>
<b class="nc">&nbsp;    /*</b>
&nbsp;    /**********************************************************
<b class="nc">&nbsp;    /* Accessors for aggregate information</b>
&nbsp;    /**********************************************************
&nbsp;     */
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private &lt;T&gt; boolean _anyExplicits(Linked&lt;T&gt; n)</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        for (; n != null; n = n.next) {</b>
&nbsp;            if (n.name != null &amp;&amp; n.name.hasSimpleName()) {
&nbsp;                return true;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private &lt;T&gt; boolean _anyExplicitNames(Linked&lt;T&gt; n)</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        for (; n != null; n = n.next) {</b>
&nbsp;            if (n.name != null &amp;&amp; n.isNameExplicit) {
&nbsp;                return true;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public boolean anyVisible() {</b>
<b class="nc">&nbsp;        return _anyVisible(_fields)</b>
<b class="nc">&nbsp;            || _anyVisible(_getters)</b>
&nbsp;            || _anyVisible(_setters)
&nbsp;            || _anyVisible(_ctorParameters)
<b class="nc">&nbsp;        ;</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; boolean _anyVisible(Linked&lt;T&gt; n)
&nbsp;    {
&nbsp;        for (; n != null; n = n.next) {
&nbsp;            if (n.isVisible) {
&nbsp;                return true;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public boolean anyIgnorals() {
&nbsp;        return _anyIgnorals(_fields)
&nbsp;            || _anyIgnorals(_getters)
&nbsp;            || _anyIgnorals(_setters)
&nbsp;            || _anyIgnorals(_ctorParameters)
&nbsp;        ;
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private &lt;T&gt; boolean _anyIgnorals(Linked&lt;T&gt; n)</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        for (; n != null; n = n.next) {</b>
&nbsp;            if (n.isMarkedIgnored) {
&nbsp;                return true;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    /**</b>
<b class="nc">&nbsp;     * Method called to find out set of explicit names for accessors</b>
<b class="nc">&nbsp;     * bound together due to implicit name.</b>
<b class="nc">&nbsp;     * </b>
<b class="nc">&nbsp;     * @since 2.4</b>
&nbsp;     */
<b class="nc">&nbsp;    public Set&lt;PropertyName&gt; findExplicitNames()</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        Set&lt;PropertyName&gt; renamed = null;</b>
<b class="nc">&nbsp;        renamed = _findExplicitNames(_fields, renamed);</b>
<b class="nc">&nbsp;        renamed = _findExplicitNames(_getters, renamed);</b>
<b class="nc">&nbsp;        renamed = _findExplicitNames(_setters, renamed);</b>
<b class="nc">&nbsp;        renamed = _findExplicitNames(_ctorParameters, renamed);</b>
<b class="nc">&nbsp;        if (renamed == null) {</b>
<b class="nc">&nbsp;            return Collections.emptySet();</b>
&nbsp;        }
&nbsp;        return renamed;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Method called when a previous call to {@link #findExplicitNames} found
&nbsp;     * multiple distinct explicit names, and the property this builder represents
<b class="nc">&nbsp;     * basically needs to be broken apart and replaced by a set of more than</b>
<b class="nc">&nbsp;     * one properties.</b>
<b class="nc">&nbsp;     * </b>
<b class="nc">&nbsp;     * @since 2.4</b>
&nbsp;     */
&nbsp;    public Collection&lt;POJOPropertyBuilder&gt; explode(Collection&lt;PropertyName&gt; newNames)
<b class="nc">&nbsp;    {</b>
&nbsp;        HashMap&lt;PropertyName,POJOPropertyBuilder&gt; props = new HashMap&lt;PropertyName,POJOPropertyBuilder&gt;();
&nbsp;        _explode(newNames, props, _fields);
&nbsp;        _explode(newNames, props, _getters);
&nbsp;        _explode(newNames, props, _setters);
&nbsp;        _explode(newNames, props, _ctorParameters);
&nbsp;        return props.values();
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void _explode(Collection&lt;PropertyName&gt; newNames,
&nbsp;            Map&lt;PropertyName,POJOPropertyBuilder&gt; props,
&nbsp;            Linked&lt;?&gt; accessors)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        final Linked&lt;?&gt; firstAcc = accessors; // clumsy, part 1</b>
<b class="nc">&nbsp;        for (Linked&lt;?&gt; node = accessors; node != null; node = node.next) {</b>
&nbsp;            PropertyName name = node.name;
<b class="nc">&nbsp;            if (!node.isNameExplicit || name == null) { // no explicit name -- problem!</b>
&nbsp;                // [databind#541] ... but only as long as it&#39;s visible
&nbsp;                if (!node.isVisible) {
&nbsp;                    continue;
&nbsp;                }
&nbsp;                
&nbsp;                throw new IllegalStateException(&quot;Conflicting/ambiguous property name definitions (implicit name &#39;&quot;
&nbsp;                        +_name+&quot;&#39;): found multiple explicit names: &quot;
&nbsp;                        +newNames+&quot;, but also implicit accessor: &quot;+node);
&nbsp;            }
&nbsp;            POJOPropertyBuilder prop = props.get(name);
&nbsp;            if (prop == null) {
&nbsp;                prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,
&nbsp;                        _internalName, name);
<b class="nc">&nbsp;                props.put(name, prop);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            // ultra-clumsy, part 2 -- lambdas would be nice here</b>
&nbsp;            if (firstAcc == _fields) {
<b class="nc">&nbsp;                Linked&lt;AnnotatedField&gt; n2 = (Linked&lt;AnnotatedField&gt;) node;</b>
&nbsp;                prop._fields = n2.withNext(prop._fields);
&nbsp;            } else if (firstAcc == _getters) {
&nbsp;                Linked&lt;AnnotatedMethod&gt; n2 = (Linked&lt;AnnotatedMethod&gt;) node;
&nbsp;                prop._getters = n2.withNext(prop._getters);
<b class="nc">&nbsp;            } else if (firstAcc == _setters) {</b>
<b class="nc">&nbsp;                Linked&lt;AnnotatedMethod&gt; n2 = (Linked&lt;AnnotatedMethod&gt;) node;</b>
&nbsp;                prop._setters = n2.withNext(prop._setters);
<b class="nc">&nbsp;            } else if (firstAcc == _ctorParameters) {</b>
&nbsp;                Linked&lt;AnnotatedParameter&gt; n2 = (Linked&lt;AnnotatedParameter&gt;) node;
&nbsp;                prop._ctorParameters = n2.withNext(prop._ctorParameters);
&nbsp;            } else {
&nbsp;                throw new IllegalStateException(&quot;Internal error: mismatched accessors, property: &quot;+this);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
<b class="nc">&nbsp;    </b>
&nbsp;    private Set&lt;PropertyName&gt; _findExplicitNames(Linked&lt;? extends AnnotatedMember&gt; node,
&nbsp;            Set&lt;PropertyName&gt; renamed)
&nbsp;    {
&nbsp;        for (; node != null; node = node.next) {
<b class="nc">&nbsp;            /* 30-Mar-2014, tatu: Second check should not be needed, but seems like</b>
<b class="nc">&nbsp;             *   removing it can cause nasty exceptions with certain version</b>
&nbsp;             *   combinations (2.4 databind, an older module).
<b class="nc">&nbsp;             *   So leaving it in for now until this is resolved</b>
&nbsp;             *   (or version beyond 2.4)
&nbsp;             */
&nbsp;            if (!node.isNameExplicit || node.name == null) {
&nbsp;                continue;
&nbsp;            }
&nbsp;            if (renamed == null) {
&nbsp;                renamed = new HashSet&lt;PropertyName&gt;();
&nbsp;            }
&nbsp;            renamed.add(node.name);
&nbsp;        }
<b class="nc">&nbsp;        return renamed;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    </b>
&nbsp;    // For trouble-shooting
&nbsp;    @Override
<b class="nc">&nbsp;    public String toString()</b>
&nbsp;    {
&nbsp;        StringBuilder sb = new StringBuilder();
&nbsp;        sb.append(&quot;[Property &#39;&quot;).append(_name)
&nbsp;          .append(&quot;&#39;; ctors: &quot;).append(_ctorParameters)
<b class="nc">&nbsp;          .append(&quot;, field(s): &quot;).append(_fields)</b>
<b class="nc">&nbsp;          .append(&quot;, getter(s): &quot;).append(_getters)</b>
<b class="nc">&nbsp;          .append(&quot;, setter(s): &quot;).append(_setters)</b>
&nbsp;          ;
&nbsp;        sb.append(&quot;]&quot;);
<b class="nc">&nbsp;        return sb.toString();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
<b class="nc">&nbsp;    /**********************************************************</b>
<b class="nc">&nbsp;    /* Helper methods</b>
<b class="nc">&nbsp;    /**********************************************************</b>
<b class="nc">&nbsp;     */</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method used for finding annotation values, from accessors
&nbsp;     * relevant to current usage (deserialization, serialization)
&nbsp;     */
<b class="nc">&nbsp;    protected &lt;T&gt; T fromMemberAnnotations(WithMember&lt;T&gt; func)</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        T result = null;</b>
&nbsp;        if (_annotationIntrospector != null) {
&nbsp;            if (_forSerialization) {
<b class="nc">&nbsp;                if (_getters != null) {</b>
&nbsp;                    result = func.withMember(_getters.value);
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (_ctorParameters != null) {</b>
<b class="nc">&nbsp;                    result = func.withMember(_ctorParameters.value);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (result == null &amp;&amp; _setters != null) {</b>
&nbsp;                    result = func.withMember(_setters.value);
&nbsp;                }
&nbsp;            }
&nbsp;            if (result == null &amp;&amp; _fields != null) {
&nbsp;                result = func.withMember(_fields.value);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected &lt;T&gt; T fromMemberAnnotationsExcept(WithMember&lt;T&gt; func, T defaultValue)</b>
&nbsp;    {
&nbsp;        if (_annotationIntrospector == null) {
&nbsp;            return null;
&nbsp;        }
&nbsp;
&nbsp;        // NOTE: here we must ask ALL accessors, but the order varies between
&nbsp;        // serialization, deserialization
&nbsp;        if (_forSerialization) {
&nbsp;            if (_getters != null) {
&nbsp;                T result = func.withMember(_getters.value);
<b class="nc">&nbsp;                if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="nc">&nbsp;                    return result;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (_fields != null) {</b>
<b class="nc">&nbsp;                T result = func.withMember(_fields.value);</b>
<b class="nc">&nbsp;                if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
&nbsp;                    return result;
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            if (_ctorParameters != null) {
&nbsp;                T result = func.withMember(_ctorParameters.value);
&nbsp;                if ((result != null) &amp;&amp; (result != defaultValue)) {
&nbsp;                    return result;
&nbsp;                }
&nbsp;            }
&nbsp;            if (_setters != null) {
&nbsp;                T result = func.withMember(_setters.value);
&nbsp;                if ((result != null) &amp;&amp; (result != defaultValue)) {
&nbsp;                    return result;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (_ctorParameters != null) {</b>
<b class="nc">&nbsp;            T result = func.withMember(_ctorParameters.value);</b>
<b class="nc">&nbsp;            if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
&nbsp;                return result;
&nbsp;            }
&nbsp;        }
&nbsp;        if (_setters != null) {
&nbsp;            T result = func.withMember(_setters.value);
&nbsp;            if ((result != null) &amp;&amp; (result != defaultValue)) {
&nbsp;                return result;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (_fields != null) {</b>
<b class="nc">&nbsp;            T result = func.withMember(_fields.value);</b>
&nbsp;            if ((result != null) &amp;&amp; (result != defaultValue)) {
<b class="nc">&nbsp;                return result;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;        if (_getters != null) {
<b class="nc">&nbsp;            T result = func.withMember(_getters.value);</b>
&nbsp;            if ((result != null) &amp;&amp; (result != defaultValue)) {
&nbsp;                return result;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    
<b class="nc">&nbsp;    /*</b>
&nbsp;    /**********************************************************
&nbsp;    /* Helper classes
<b class="nc">&nbsp;    /**********************************************************</b>
<b class="nc">&nbsp;     */</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private interface WithMember&lt;T&gt; {</b>
<b class="nc">&nbsp;        public T withMember(AnnotatedMember member);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    /**</b>
<b class="nc">&nbsp;     * @since 2.5</b>
<b class="nc">&nbsp;     */</b>
<b class="nc">&nbsp;    protected static class MemberIterator&lt;T extends AnnotatedMember&gt;</b>
<b class="nc">&nbsp;        implements Iterator&lt;T&gt;</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        private Linked&lt;T&gt; next;</b>
&nbsp;        
<b class="nc">&nbsp;        public MemberIterator(Linked&lt;T&gt; first) {</b>
<b class="nc">&nbsp;            next = first;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public boolean hasNext() {
<b class="nc">&nbsp;            return (next != null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public T next() {
<b class="nc">&nbsp;            if (next == null) throw new NoSuchElementException();</b>
<b class="nc">&nbsp;            T result = next.value;</b>
<b class="nc">&nbsp;            next = next.next;</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @Override</b>
&nbsp;        public void remove() {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
<b class="nc">&nbsp;        </b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Node used for creating simple linked lists to efficiently store small sets
&nbsp;     * of things.
&nbsp;     */
<b class="nc">&nbsp;    protected final static class Linked&lt;T&gt;</b>
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        public final T value;</b>
<b class="nc">&nbsp;        public final Linked&lt;T&gt; next;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public final PropertyName name;</b>
&nbsp;        public final boolean isNameExplicit;
<b class="nc">&nbsp;        public final boolean isVisible;</b>
<b class="nc">&nbsp;        public final boolean isMarkedIgnored;</b>
&nbsp;        
&nbsp;        public Linked(T v, Linked&lt;T&gt; n,
&nbsp;                PropertyName name, boolean explName, boolean visible, boolean ignored)
&nbsp;        {
&nbsp;            value = v;
&nbsp;            next = n;
&nbsp;            // ensure that we&#39;ll never have missing names
&nbsp;            this.name = (name == null || name.isEmpty()) ? null : name;
&nbsp;
&nbsp;            if (explName) {
&nbsp;                if (this.name == null) { // sanity check to catch internal problems
&nbsp;                    throw new IllegalArgumentException(&quot;Can not pass true for &#39;explName&#39; if name is null/empty&quot;);
&nbsp;                }
&nbsp;                // 03-Apr-2014, tatu: But how about name-space only override?
<b class="nc">&nbsp;                //   Probably should not be explicit? Or, need to merge somehow?</b>
<b class="nc">&nbsp;                if (!name.hasSimpleName()) {</b>
<b class="nc">&nbsp;                    explName = false;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            
&nbsp;            isNameExplicit = explName;
<b class="nc">&nbsp;            isVisible = visible;</b>
<b class="nc">&nbsp;            isMarkedIgnored = ignored;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Linked&lt;T&gt; withoutNext() {</b>
&nbsp;            if (next == null) {
&nbsp;                return this;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return new Linked&lt;T&gt;(value, null, name, isNameExplicit, isVisible, isMarkedIgnored);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        public Linked&lt;T&gt; withValue(T newValue) {</b>
&nbsp;            if (newValue == value) {
&nbsp;                return this;
&nbsp;            }
&nbsp;            return new Linked&lt;T&gt;(newValue, next, name, isNameExplicit, isVisible, isMarkedIgnored);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        </b>
&nbsp;        public Linked&lt;T&gt; withNext(Linked&lt;T&gt; newNext) {
&nbsp;            if (newNext == next) {
&nbsp;                return this;
&nbsp;            }
<b class="nc">&nbsp;            return new Linked&lt;T&gt;(value, newNext, name, isNameExplicit, isVisible, isMarkedIgnored);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        </b>
<b class="nc">&nbsp;        public Linked&lt;T&gt; withoutIgnored() {</b>
<b class="nc">&nbsp;            if (isMarkedIgnored) {</b>
&nbsp;                return (next == null) ? null : next.withoutIgnored();
&nbsp;            }
<b class="nc">&nbsp;            if (next != null) {</b>
<b class="nc">&nbsp;                Linked&lt;T&gt; newNext = next.withoutIgnored();</b>
<b class="nc">&nbsp;                if (newNext != next) {</b>
<b class="nc">&nbsp;                    return withNext(newNext);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return this;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        </b>
<b class="nc">&nbsp;        public Linked&lt;T&gt; withoutNonVisible() {</b>
&nbsp;            Linked&lt;T&gt; newNext = (next == null) ? null : next.withoutNonVisible();
&nbsp;            return isVisible ? withNext(newNext) : newNext;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        /**</b>
<b class="nc">&nbsp;         * Method called to append given node(s) at the end of this</b>
&nbsp;         * node chain.
&nbsp;         */
<b class="nc">&nbsp;        protected Linked&lt;T&gt; append(Linked&lt;T&gt; appendable) {</b>
&nbsp;            if (next == null) {
<b class="nc">&nbsp;                return withNext(appendable);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return withNext(next.append(appendable));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public Linked&lt;T&gt; trimByVisibility() {
<b class="nc">&nbsp;            if (next == null) {</b>
<b class="nc">&nbsp;                return this;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Linked&lt;T&gt; newNext = next.trimByVisibility();</b>
&nbsp;            if (name != null) { // this already has highest; how about next one?
&nbsp;                if (newNext.name == null) { // next one not, drop it
<b class="nc">&nbsp;                    return withNext(null);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                //  both have it, keep</b>
<b class="nc">&nbsp;                return withNext(newNext);</b>
&nbsp;            }
&nbsp;            if (newNext.name != null) { // next one has higher, return it...
<b class="nc">&nbsp;                return newNext;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            // neither has explicit name; how about visibility?</b>
<b class="nc">&nbsp;            if (isVisible == newNext.isVisible) { // same; keep both in current order</b>
&nbsp;                return withNext(newNext);
&nbsp;            }
<b class="nc">&nbsp;            return isVisible ? withNext(null) : newNext;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public String toString() {
&nbsp;            String msg = value.toString()+&quot;[visible=&quot;+isVisible+&quot;,ignore=&quot;+isMarkedIgnored
&nbsp;                    +&quot;,explicitName=&quot;+isNameExplicit+&quot;]&quot;;
&nbsp;            if (next != null) {
&nbsp;                msg = msg + &quot;, &quot;+next.toString();
&nbsp;            }
&nbsp;            return msg;
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 23:23</div>
</div>
</body>
</html>
