


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DefaultSerializerProvider</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.ser</a>
</div>

<h1>Coverage Summary for Class: DefaultSerializerProvider (com.fasterxml.jackson.databind.ser)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultSerializerProvider</td>
<td class="coverageStat">
  <span class="percent">
    95.7%
  </span>
  <span class="absValue">
    (22/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.6%
  </span>
  <span class="absValue">
    (127/180)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultSerializerProvider$Impl</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    96.4%
  </span>
  <span class="absValue">
    (27/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.1%
  </span>
  <span class="absValue">
    (133/187)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.ser;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.atomic.AtomicReference;
&nbsp;
&nbsp;import com.fasterxml.jackson.annotation.ObjectIdGenerator;
&nbsp;import com.fasterxml.jackson.core.JsonGenerator;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;
&nbsp;import com.fasterxml.jackson.databind.introspect.Annotated;
&nbsp;import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
&nbsp;import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
&nbsp;import com.fasterxml.jackson.databind.jsonschema.SchemaAware;
&nbsp;import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;
&nbsp;import com.fasterxml.jackson.databind.util.ClassUtil;
&nbsp;
&nbsp;/**
&nbsp; * Standard implementation used by {@link ObjectMapper}:
&nbsp; * adds methods only exposed to {@link ObjectMapper},
&nbsp; * as well as constructors.
&nbsp; *&lt;p&gt;
&nbsp; * Note that class is abstract just because it does not
&nbsp; * define {@link #createInstance} method.
&nbsp; *&lt;p&gt;
&nbsp; * Also note that all custom {@link SerializerProvider}
&nbsp; * implementations must sub-class this class: {@link ObjectMapper}
&nbsp; * requires this type, not basic provider type.
&nbsp; */
&nbsp;public abstract class DefaultSerializerProvider
&nbsp;    extends SerializerProvider
&nbsp;    implements java.io.Serializable // since 2.1; only because ObjectWriter needs it
&nbsp;{
&nbsp;    private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* State, for non-blueprint instances
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Per-serialization map Object Ids that have seen so far, iff
&nbsp;     * Object Id handling is enabled.
&nbsp;     */
&nbsp;    protected transient Map&lt;Object, WritableObjectId&gt; _seenObjectIds;
&nbsp;    
&nbsp;    protected transient ArrayList&lt;ObjectIdGenerator&lt;?&gt;&gt; _objectIdGenerators;
&nbsp;
&nbsp;    /**
&nbsp;     * Generator used for serialization. Needed mostly for error reporting
&nbsp;     * purposes.
&nbsp;     *
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    protected transient JsonGenerator _generator;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Life-cycle
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
<b class="fc">&nbsp;    protected DefaultSerializerProvider() { super(); }</b>
&nbsp;
&nbsp;    protected DefaultSerializerProvider(SerializerProvider src,
&nbsp;            SerializationConfig config,SerializerFactory f) {
<b class="fc">&nbsp;        super(src, config, f);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected DefaultSerializerProvider(DefaultSerializerProvider src) {
<b class="fc">&nbsp;        super(src);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that sub-classes need to implement: used to create a non-blueprint instances
&nbsp;     * from the blueprint.
&nbsp;     * This is needed to retain state during serialization.
&nbsp;     */
&nbsp;    public abstract DefaultSerializerProvider createInstance(SerializationConfig config,
&nbsp;            SerializerFactory jsf);
&nbsp;
&nbsp;    /**
&nbsp;     * Method needed to ensure that {@link ObjectMapper#copy} will work
&nbsp;     * properly; specifically, that caches are cleared, but settings
&nbsp;     * will otherwise remain identical; and that no sharing of state
&nbsp;     * occurs.
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public DefaultSerializerProvider copy() {
<b class="nc">&nbsp;        throw new IllegalStateException(&quot;DefaultSerializerProvider sub-class not overriding copy()&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Abstract method impls, factory methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    @Override
&nbsp;    public JsonSerializer&lt;Object&gt; serializerInstance(Annotated annotated, Object serDef)
&nbsp;            throws JsonMappingException
&nbsp;    {
<b class="fc">&nbsp;        if (serDef == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        JsonSerializer&lt;?&gt; ser;
&nbsp;        
<b class="fc">&nbsp;        if (serDef instanceof JsonSerializer) {</b>
<b class="fc">&nbsp;            ser = (JsonSerializer&lt;?&gt;) serDef;</b>
&nbsp;        } else {
&nbsp;            // Alas, there&#39;s no way to force return type of &quot;either class
&nbsp;            // X or Y&quot; -- need to throw an exception after the fact
<b class="fc">&nbsp;            if (!(serDef instanceof Class)) {</b>
<b class="nc">&nbsp;                reportBadDefinition(annotated.getType(),</b>
&nbsp;                        &quot;AnnotationIntrospector returned serializer definition of type &quot;
<b class="nc">&nbsp;                        +serDef.getClass().getName()+&quot;; expected type JsonSerializer or Class&lt;JsonSerializer&gt; instead&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            Class&lt;?&gt; serClass = (Class&lt;?&gt;)serDef;</b>
&nbsp;            // there are some known &quot;no class&quot; markers to consider too:
<b class="fc">&nbsp;            if (serClass == JsonSerializer.None.class || ClassUtil.isBogusClass(serClass)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (!JsonSerializer.class.isAssignableFrom(serClass)) {</b>
<b class="nc">&nbsp;                reportBadDefinition(annotated.getType(),</b>
&nbsp;                        &quot;AnnotationIntrospector returned Class &quot;
<b class="nc">&nbsp;                        +serClass.getName()+&quot;; expected Class&lt;JsonSerializer&gt;&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            HandlerInstantiator hi = _config.getHandlerInstantiator();</b>
<b class="fc">&nbsp;            ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass);</b>
<b class="fc">&nbsp;            if (ser == null) {</b>
<b class="fc">&nbsp;                ser = (JsonSerializer&lt;?&gt;) ClassUtil.createInstance(serClass,</b>
<b class="fc">&nbsp;                        _config.canOverrideAccessModifiers());</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return (JsonSerializer&lt;Object&gt;) _handleResolvable(ser);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object includeFilterInstance(BeanPropertyDefinition forProperty,
&nbsp;            Class&lt;?&gt; filterClass)
&nbsp;    {
<b class="fc">&nbsp;        if (filterClass == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        HandlerInstantiator hi = _config.getHandlerInstantiator();</b>
<b class="fc">&nbsp;        Object filter = (hi == null) ? null : hi.includeFilterInstance(_config, forProperty, filterClass);</b>
<b class="fc">&nbsp;        if (filter == null) {</b>
<b class="fc">&nbsp;            filter = ClassUtil.createInstance(filterClass,</b>
<b class="fc">&nbsp;                    _config.canOverrideAccessModifiers());</b>
&nbsp;        }
<b class="fc">&nbsp;        return filter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException
&nbsp;    {
<b class="fc">&nbsp;        if (filter == null) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        // should let filter decide what to do with nulls:
&nbsp;        // But just case, let&#39;s handle unexpected (from our perspective) problems explicitly
&nbsp;        try {
<b class="fc">&nbsp;            return filter.equals(null);</b>
<b class="fc">&nbsp;        } catch (Throwable t) {</b>
<b class="fc">&nbsp;            String msg = String.format(</b>
&nbsp;&quot;Problem determining whether filter of type &#39;%s&#39; should filter out `null` values: (%s) %s&quot;,
<b class="fc">&nbsp;filter.getClass().getName(), t.getClass().getName(), t.getMessage());</b>
<b class="fc">&nbsp;            reportBadDefinition(filter.getClass(), msg, t);</b>
<b class="nc">&nbsp;            return false; // never gets here</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Object Id handling
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    @Override
&nbsp;    public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator&lt;?&gt; generatorType)
&nbsp;    {
<b class="fc">&nbsp;        if (_seenObjectIds == null) {</b>
<b class="fc">&nbsp;            _seenObjectIds = _createObjectIdMap();</b>
&nbsp;        } else {
<b class="fc">&nbsp;            WritableObjectId oid = _seenObjectIds.get(forPojo);</b>
<b class="fc">&nbsp;            if (oid != null) {</b>
<b class="fc">&nbsp;                return oid;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Not seen yet; must add an entry, return it. For that, we need generator
<b class="fc">&nbsp;        ObjectIdGenerator&lt;?&gt; generator = null;</b>
&nbsp;        
<b class="fc">&nbsp;        if (_objectIdGenerators == null) {</b>
<b class="fc">&nbsp;            _objectIdGenerators = new ArrayList&lt;ObjectIdGenerator&lt;?&gt;&gt;(8);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            for (int i = 0, len = _objectIdGenerators.size(); i &lt; len; ++i) {</b>
<b class="fc">&nbsp;                ObjectIdGenerator&lt;?&gt; gen = _objectIdGenerators.get(i);</b>
<b class="fc">&nbsp;                if (gen.canUseFor(generatorType)) {</b>
<b class="fc">&nbsp;                    generator = gen;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (generator == null) {</b>
<b class="fc">&nbsp;            generator = generatorType.newForSerialization(this);</b>
<b class="fc">&nbsp;            _objectIdGenerators.add(generator);</b>
&nbsp;        }
<b class="fc">&nbsp;        WritableObjectId oid = new WritableObjectId(generator);</b>
<b class="fc">&nbsp;        _seenObjectIds.put(forPojo, oid);</b>
<b class="fc">&nbsp;        return oid;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Overridable helper method used for creating {@link java.util.Map}
&nbsp;     * used for storing mappings from serializable objects to their
&nbsp;     * Object Ids.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    protected Map&lt;Object,WritableObjectId&gt; _createObjectIdMap()
&nbsp;    {
&nbsp;        /* 06-Aug-2013, tatu: We may actually want to use equality,
&nbsp;         *   instead of identity... so:
&nbsp;         */
<b class="fc">&nbsp;        if (isEnabled(SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID)) {</b>
<b class="fc">&nbsp;            return new HashMap&lt;Object,WritableObjectId&gt;();</b>
&nbsp;        }
<b class="fc">&nbsp;        return new IdentityHashMap&lt;Object,WritableObjectId&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended API: simple accesors
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be called to see if this serializer provider
&nbsp;     * can find a serializer for an instance of given class.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that no Exceptions are thrown, including unchecked ones:
&nbsp;     * implementations are to swallow exceptions if necessary.
&nbsp;     */
&nbsp;    public boolean hasSerializerFor(Class&lt;?&gt; cls, AtomicReference&lt;Throwable&gt; cause)
&nbsp;    {
&nbsp;        // 07-Nov-2015, tatu: One special case, Object.class; will work only if
&nbsp;        //   empty beans are allowed or custom serializer registered. Easiest to
&nbsp;        //   check here.
<b class="fc">&nbsp;        if (cls == Object.class) {</b>
<b class="fc">&nbsp;            if (!_config.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        try {
<b class="fc">&nbsp;            JsonSerializer&lt;?&gt; ser = _findExplicitUntypedSerializer(cls);</b>
<b class="fc">&nbsp;            return (ser != null);</b>
<b class="nc">&nbsp;        } catch (JsonMappingException e) {</b>
<b class="nc">&nbsp;            if (cause != null) {</b>
<b class="nc">&nbsp;                cause.set(e);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;            if (cause == null) { // earlier behavior</b>
<b class="nc">&nbsp;                throw e;</b>
&nbsp;            }
<b class="nc">&nbsp;            cause.set(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accessor for the {@link JsonGenerator} currently in use for serializing
&nbsp;     * content. Null for blueprint instances; non-null for actual active
&nbsp;     * provider instances.
&nbsp;     *
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    @Override
&nbsp;    public JsonGenerator getGenerator() {
<b class="fc">&nbsp;        return _generator;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended API called by ObjectMapper: value serialization
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}
&nbsp;     * for serializing given value, using serializers that
&nbsp;     * this provider has access to (via caching and/or creating new serializers
&nbsp;     * as need be).
&nbsp;     */
&nbsp;    public void serializeValue(JsonGenerator gen, Object value) throws IOException
&nbsp;    {
<b class="fc">&nbsp;        _generator = gen;</b>
<b class="fc">&nbsp;        if (value == null) {</b>
<b class="fc">&nbsp;            _serializeNull(gen);</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        final Class&lt;?&gt; cls = value.getClass();</b>
&nbsp;        // true, since we do want to cache root-level typed serializers (ditto for null property)
<b class="fc">&nbsp;        final JsonSerializer&lt;Object&gt; ser = findTypedValueSerializer(cls, true, null);</b>
&nbsp;
<b class="fc">&nbsp;        PropertyName rootName = _config.getFullRootName();</b>
<b class="fc">&nbsp;        if (rootName == null) { // not explicitly specified</b>
<b class="fc">&nbsp;            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {</b>
<b class="fc">&nbsp;                _serialize(gen, value, ser, _config.findRootName(cls));</b>
&nbsp;                return;
&nbsp;            }
<b class="fc">&nbsp;        } else if (!rootName.isEmpty()) {</b>
<b class="fc">&nbsp;            _serialize(gen, value, ser, rootName);</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        _serialize(gen, value, ser);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}
&nbsp;     * for serializing given value (assumed to be of specified root type,
&nbsp;     * instead of runtime type of value),
&nbsp;     * using serializers that
&nbsp;     * this provider has access to (via caching and/or creating new serializers
&nbsp;     * as need be),
&nbsp;     * 
&nbsp;     * @param rootType Type to use for locating serializer to use, instead of actual
&nbsp;     *    runtime type. Must be actual type, or one of its super types
&nbsp;     */
&nbsp;    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException
&nbsp;    {
<b class="fc">&nbsp;        _generator = gen;</b>
<b class="fc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            _serializeNull(gen);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // Let&#39;s ensure types are compatible at this point
<b class="fc">&nbsp;        if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {</b>
<b class="nc">&nbsp;            _reportIncompatibleRootType(value, rootType);</b>
&nbsp;        }
&nbsp;        // root value, not reached via property:
<b class="fc">&nbsp;        JsonSerializer&lt;Object&gt; ser = findTypedValueSerializer(rootType, true, null);</b>
<b class="fc">&nbsp;        PropertyName rootName = _config.getFullRootName();</b>
<b class="fc">&nbsp;        if (rootName == null) { // not explicitly specified</b>
<b class="fc">&nbsp;            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {</b>
<b class="nc">&nbsp;                _serialize(gen, value, ser, _config.findRootName(rootType));</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;        } else if (!rootName.isEmpty()) {</b>
<b class="nc">&nbsp;            _serialize(gen, value, ser, rootName);</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        _serialize(gen, value, ser);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The method to be called by {@link ObjectWriter}
&nbsp;     * for serializing given value (assumed to be of specified root type,
&nbsp;     * instead of runtime type of value), when it may know specific
&nbsp;     * {@link JsonSerializer} to use.
&nbsp;     * 
&nbsp;     * @param rootType Type to use for locating serializer to use, instead of actual
&nbsp;     *    runtime type, if no serializer is passed
&nbsp;     * @param ser Root Serializer to use, if not null
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,
&nbsp;            JsonSerializer&lt;Object&gt; ser) throws IOException
&nbsp;    {
<b class="fc">&nbsp;        _generator = gen;</b>
<b class="fc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            _serializeNull(gen);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // Let&#39;s ensure types are compatible at this point
<b class="fc">&nbsp;        if ((rootType != null) &amp;&amp; !rootType.getRawClass().isAssignableFrom(value.getClass())) {</b>
<b class="fc">&nbsp;            _reportIncompatibleRootType(value, rootType);</b>
&nbsp;        }
&nbsp;        // root value, not reached via property:
<b class="fc">&nbsp;        if (ser == null) {</b>
<b class="nc">&nbsp;            ser = findTypedValueSerializer(rootType, true, null);</b>
&nbsp;        }
<b class="fc">&nbsp;        PropertyName rootName = _config.getFullRootName();</b>
<b class="fc">&nbsp;        if (rootName == null) { // not explicitly specified</b>
<b class="fc">&nbsp;            if (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) {</b>
<b class="fc">&nbsp;                rootName = (rootType == null)</b>
<b class="nc">&nbsp;                        ? _config.findRootName(value.getClass())</b>
<b class="fc">&nbsp;                        : _config.findRootName(rootType);</b>
<b class="fc">&nbsp;                _serialize(gen, value, ser, rootName);</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;        } else if (!rootName.isEmpty()) {</b>
<b class="nc">&nbsp;            _serialize(gen, value, ser, rootName);</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        _serialize(gen, value, ser);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Alternate serialization call used for polymorphic types, when {@link TypeSerializer}
&nbsp;     * is already known, but the actual serializer may or may not be.
&nbsp;     *
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public void serializePolymorphic(JsonGenerator gen, Object value, JavaType rootType,
&nbsp;            JsonSerializer&lt;Object&gt; valueSer, TypeSerializer typeSer)
&nbsp;        throws IOException
&nbsp;    {
<b class="fc">&nbsp;        _generator = gen;</b>
<b class="fc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            _serializeNull(gen);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // Let&#39;s ensure types are compatible at this point
<b class="fc">&nbsp;        if ((rootType != null) &amp;&amp; !rootType.getRawClass().isAssignableFrom(value.getClass())) {</b>
<b class="nc">&nbsp;            _reportIncompatibleRootType(value, rootType);</b>
&nbsp;        }
&nbsp;        /* 12-Jun-2015, tatu: nominal root type is necessary for Maps at least;
&nbsp;         *   possibly collections, but can cause problems for other polymorphic
&nbsp;         *   types. We really need to distinguish between serialization type,
&nbsp;         *   base type; but right we don&#39;t. Hence this check
&nbsp;         */
<b class="fc">&nbsp;        if (valueSer == null) {</b>
<b class="fc">&nbsp;            if ((rootType != null) &amp;&amp; rootType.isContainerType()) {</b>
<b class="fc">&nbsp;                valueSer = findValueSerializer(rootType, null);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                valueSer = findValueSerializer(value.getClass(), null);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        final boolean wrap;
<b class="fc">&nbsp;        PropertyName rootName = _config.getFullRootName();</b>
<b class="fc">&nbsp;        if (rootName == null) {</b>
<b class="fc">&nbsp;            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);</b>
<b class="fc">&nbsp;            if (wrap) {</b>
<b class="nc">&nbsp;                gen.writeStartObject();</b>
<b class="nc">&nbsp;                PropertyName pname = _config.findRootName(value.getClass());</b>
<b class="nc">&nbsp;                gen.writeFieldName(pname.simpleAsEncoded(_config));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (rootName.isEmpty()) {</b>
<b class="nc">&nbsp;            wrap = false;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            wrap = true;</b>
<b class="nc">&nbsp;            gen.writeStartObject();</b>
<b class="nc">&nbsp;            gen.writeFieldName(rootName.getSimpleName());</b>
&nbsp;        }
&nbsp;        try {
<b class="fc">&nbsp;            valueSer.serializeWithType(value, gen, this, typeSer);</b>
<b class="fc">&nbsp;            if (wrap) {</b>
<b class="nc">&nbsp;                gen.writeEndObject();</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw _wrapAsIOE(gen, e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private final void _serialize(JsonGenerator gen, Object value,
&nbsp;            JsonSerializer&lt;Object&gt; ser, PropertyName rootName)
&nbsp;        throws IOException
&nbsp;    {
&nbsp;        try {
<b class="fc">&nbsp;            gen.writeStartObject();</b>
<b class="fc">&nbsp;            gen.writeFieldName(rootName.simpleAsEncoded(_config));</b>
<b class="fc">&nbsp;            ser.serialize(value, gen, this);</b>
<b class="fc">&nbsp;            gen.writeEndObject();</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw _wrapAsIOE(gen, e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private final void _serialize(JsonGenerator gen, Object value,
&nbsp;            JsonSerializer&lt;Object&gt; ser)
&nbsp;        throws IOException
&nbsp;    {
&nbsp;        try {
<b class="fc">&nbsp;            ser.serialize(value, gen, this);</b>
<b class="fc">&nbsp;        } catch (Exception e) {</b>
<b class="fc">&nbsp;            throw _wrapAsIOE(gen, e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method called when root value to serialize is null
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    protected void _serializeNull(JsonGenerator gen) throws IOException
&nbsp;    {
<b class="fc">&nbsp;        JsonSerializer&lt;Object&gt; ser = getDefaultNullValueSerializer();</b>
&nbsp;        try {
<b class="fc">&nbsp;            ser.serialize(null, gen, this);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw _wrapAsIOE(gen, e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private IOException _wrapAsIOE(JsonGenerator g, Exception e) {
<b class="fc">&nbsp;        if (e instanceof IOException) {</b>
<b class="fc">&nbsp;            return (IOException) e;</b>
&nbsp;        }
<b class="nc">&nbsp;        String msg = e.getMessage();</b>
<b class="nc">&nbsp;        if (msg == null) {</b>
<b class="nc">&nbsp;            msg = &quot;[no message for &quot;+e.getClass().getName()+&quot;]&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new JsonMappingException(g, msg, e);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /********************************************************
&nbsp;    /* Access to caching details
&nbsp;    /********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to determine how many serializers this
&nbsp;     * provider is caching currently
&nbsp;     * (if it does caching: default implementation does)
&nbsp;     * Exact count depends on what kind of serializers get cached;
&nbsp;     * default implementation caches all serializers, including ones that
&nbsp;     * are eagerly constructed (for optimal access speed)
&nbsp;     *&lt;p&gt; 
&nbsp;     * The main use case for this method is to allow conditional flushing of
&nbsp;     * serializer cache, if certain number of entries is reached.
&nbsp;     */
&nbsp;    public int cachedSerializersCount() {
<b class="fc">&nbsp;        return _serializerCache.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that will drop all serializers currently cached by this provider.
&nbsp;     * This can be used to remove memory usage (in case some serializers are
&nbsp;     * only used once or so), or to force re-construction of serializers after
&nbsp;     * configuration changes for mapper than owns the provider.
&nbsp;     */
&nbsp;    public void flushCachedSerializers() {
<b class="fc">&nbsp;        _serializerCache.flush();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended API called by ObjectMapper: other
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}
&nbsp;     * to to expose the format of the given to to the given visitor
&nbsp;     *
&nbsp;     * @param javaType The type for which to generate format
&nbsp;     * @param visitor the visitor to accept the format
&nbsp;     */
&nbsp;    public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="fc">&nbsp;        if (javaType == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;A class must be provided&quot;);</b>
&nbsp;        }
&nbsp;        /* no need for embedded type information for JSON schema generation (all
&nbsp;         * type information it needs is accessible via &quot;untyped&quot; serializer)
&nbsp;         */
<b class="fc">&nbsp;        visitor.setProvider(this);</b>
<b class="fc">&nbsp;        findValueSerializer(javaType, null).acceptJsonFormatVisitor(visitor, javaType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The method to be called by {@link ObjectMapper}
&nbsp;     * to generate &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON schema&lt;/a&gt; for
&nbsp;     * given type.
&nbsp;     *
&nbsp;     * @param type The type for which to generate schema
&nbsp;     * 
&nbsp;     * @deprecated Should not be used any more
&nbsp;     */
&nbsp;    @Deprecated // since 2.6
&nbsp;    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class&lt;?&gt; type)
&nbsp;        throws JsonMappingException
&nbsp;    {
&nbsp;        /* no need for embedded type information for JSON schema generation (all
&nbsp;         * type information it needs is accessible via &quot;untyped&quot; serializer)
&nbsp;         */
<b class="fc">&nbsp;        JsonSerializer&lt;Object&gt; ser = findValueSerializer(type, null);</b>
<b class="fc">&nbsp;        JsonNode schemaNode = (ser instanceof SchemaAware) ?</b>
<b class="fc">&nbsp;                ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode();</b>
<b class="fc">&nbsp;        if (!(schemaNode instanceof ObjectNode)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Class &quot; + type.getName()</b>
&nbsp;                    +&quot; would not be serialized as a JSON object and therefore has no schema&quot;);
&nbsp;        }
<b class="fc">&nbsp;        return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode);</b>
&nbsp;    }
&nbsp;    
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper classes
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Concrete implementation that defines factory method(s),
&nbsp;     * defined as final.
&nbsp;     */
&nbsp;    public final static class Impl extends DefaultSerializerProvider {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        public Impl() { super(); }</b>
<b class="fc">&nbsp;        public Impl(Impl src) { super(src); }</b>
&nbsp;
&nbsp;        protected Impl(SerializerProvider src, SerializationConfig config,
&nbsp;                SerializerFactory f) {
<b class="fc">&nbsp;            super(src, config, f);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public DefaultSerializerProvider copy()
&nbsp;        {
<b class="fc">&nbsp;            if (getClass() != Impl.class) {</b>
<b class="nc">&nbsp;                return super.copy();</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Impl(this);</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public Impl createInstance(SerializationConfig config, SerializerFactory jsf) {
<b class="fc">&nbsp;            return new Impl(this, config, jsf);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-02 21:24</div>
</div>
</body>
</html>
