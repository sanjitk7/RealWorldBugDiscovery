


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > StdKeySerializers</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.ser.std</a>
</div>

<h1>Coverage Summary for Class: StdKeySerializers (com.fasterxml.jackson.databind.ser.std)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StdKeySerializers</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (26/28)
  </span>
</td>
</tr>
  <tr>
    <td class="name">StdKeySerializers$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45%
  </span>
  <span class="absValue">
    (9/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StdKeySerializers$Dynamic</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.7%
  </span>
  <span class="absValue">
    (22/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StdKeySerializers$EnumKeySerializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.5%
  </span>
  <span class="absValue">
    (8/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StdKeySerializers$StringKeySerializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77%
  </span>
  <span class="absValue">
    (67/87)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.ser.std;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.Calendar;
&nbsp;import java.util.Date;
&nbsp;
&nbsp;import com.fasterxml.jackson.core.*;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
&nbsp;import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;
&nbsp;import com.fasterxml.jackson.databind.util.EnumValues;
&nbsp;
&nbsp;@SuppressWarnings(&quot;serial&quot;)
&nbsp;public class StdKeySerializers
&nbsp;{
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<b class="fc">&nbsp;    protected final static JsonSerializer&lt;Object&gt; DEFAULT_KEY_SERIALIZER = new StdKeySerializer();</b>
&nbsp;
<b class="fc">&nbsp;    protected final static JsonSerializer&lt;Object&gt; DEFAULT_STRING_SERIALIZER = new StringKeySerializer();</b>
&nbsp;
<b class="nc">&nbsp;    private StdKeySerializers() { }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @param config Serialization configuration in use, may be needed in choosing
&nbsp;     *    serializer to use
&nbsp;     * @param rawKeyType Type of key values to serialize
&nbsp;     * @param useDefault If no match is found, should we return fallback deserializer
&nbsp;     *    (true), or null (false)?
&nbsp;     */
&nbsp;    public static JsonSerializer&lt;Object&gt; getStdKeySerializer(SerializationConfig config,
&nbsp;            Class&lt;?&gt; rawKeyType, boolean useDefault)
&nbsp;    {
&nbsp;        // 24-Sep-2015, tatu: Important -- should ONLY consider types for which `@JsonValue`
&nbsp;        //    can not be used, since caller has not yet checked for that annotation
&nbsp;        //    This is why Enum types are not handled here quite yet
&nbsp;
&nbsp;        // [databind#943: Use a dynamic key serializer if we are not given actual
&nbsp;        // type declaration
<b class="fc">&nbsp;        if ((rawKeyType == null) || (rawKeyType == Object.class)) {</b>
<b class="fc">&nbsp;            return new Dynamic();</b>
&nbsp;        }
<b class="fc">&nbsp;        if (rawKeyType == String.class) {</b>
<b class="fc">&nbsp;            return DEFAULT_STRING_SERIALIZER;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (rawKeyType.isPrimitive() || Number.class.isAssignableFrom(rawKeyType)) {</b>
&nbsp;            // 28-Jun-2016, tatu: Used to just return DEFAULT_KEY_SERIALIZER, but makes
&nbsp;            //   more sense to use simpler one directly
<b class="fc">&nbsp;            return new Default(Default.TYPE_TO_STRING, rawKeyType);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (rawKeyType == Class.class) {</b>
<b class="fc">&nbsp;            return new Default(Default.TYPE_CLASS, rawKeyType);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (Date.class.isAssignableFrom(rawKeyType)) {</b>
<b class="fc">&nbsp;            return new Default(Default.TYPE_DATE, rawKeyType);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (Calendar.class.isAssignableFrom(rawKeyType)) {</b>
<b class="fc">&nbsp;            return new Default(Default.TYPE_CALENDAR, rawKeyType);</b>
&nbsp;        }
&nbsp;        // other JDK types we know convert properly with &#39;toString()&#39;?
<b class="fc">&nbsp;        if (rawKeyType == java.util.UUID.class) {</b>
<b class="fc">&nbsp;            return new Default(Default.TYPE_TO_STRING, rawKeyType);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (useDefault) {</b>
<b class="fc">&nbsp;            return DEFAULT_KEY_SERIALIZER;</b>
&nbsp;        }
<b class="fc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method called if no specified key serializer was located; will return a
&nbsp;     * &quot;default&quot; key serializer.
&nbsp;     *
&nbsp;     * @since 2.7
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public static JsonSerializer&lt;Object&gt; getFallbackKeySerializer(SerializationConfig config,
&nbsp;            Class&lt;?&gt; rawKeyType)
&nbsp;    {
<b class="fc">&nbsp;        if (rawKeyType != null) {</b>
&nbsp;            // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure
&nbsp;            //   if that is a bug or feature. Regardless, it seems to require dynamic handling
&nbsp;            //   (compared to getting actual fully typed Enum).
&nbsp;            //  Note that this might even work from the earlier point, but let&#39;s play it safe for now
&nbsp;            // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because
&nbsp;            //    then there is no static type
<b class="fc">&nbsp;            if (rawKeyType == Enum.class) {</b>
<b class="nc">&nbsp;                return new Dynamic();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawKeyType.isEnum()) {</b>
<b class="fc">&nbsp;                return EnumKeySerializer.construct(rawKeyType,</b>
<b class="fc">&nbsp;                        EnumValues.constructFromName(config, (Class&lt;Enum&lt;?&gt;&gt;) rawKeyType));</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return DEFAULT_KEY_SERIALIZER;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated since 2.7
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static JsonSerializer&lt;Object&gt; getDefault() {
<b class="fc">&nbsp;        return DEFAULT_KEY_SERIALIZER;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Standard implementations used
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * This is a &quot;chameleon&quot; style multi-type key serializer for simple
&nbsp;     * standard JDK types.
&nbsp;     *&lt;p&gt;
&nbsp;     * TODO: Should (but does not yet) support re-configuring format used for
&nbsp;     * {@link java.util.Date} and {@link java.util.Calendar} key serializers,
&nbsp;     * as well as alternative configuration of Enum key serializers.
&nbsp;     */
&nbsp;    public static class Default extends StdSerializer&lt;Object&gt; {
&nbsp;        final static int TYPE_DATE = 1;
&nbsp;        final static int TYPE_CALENDAR = 2;
&nbsp;        final static int TYPE_CLASS = 3;
&nbsp;        final static int TYPE_ENUM = 4;
&nbsp;        final static int TYPE_TO_STRING = 5;
&nbsp;
&nbsp;        protected final int _typeId;
&nbsp;        
&nbsp;        public Default(int typeId, Class&lt;?&gt; type) {
<b class="fc">&nbsp;            super(type, false);</b>
<b class="fc">&nbsp;            _typeId = typeId;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void serialize(Object value, JsonGenerator g, SerializerProvider provider) throws IOException {
<b class="fc">&nbsp;            switch (_typeId) {</b>
&nbsp;            case TYPE_DATE:
<b class="nc">&nbsp;                provider.defaultSerializeDateKey((Date)value, g);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case TYPE_CALENDAR:
<b class="fc">&nbsp;                provider.defaultSerializeDateKey(((Calendar) value).getTimeInMillis(), g);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case TYPE_CLASS:
<b class="fc">&nbsp;                g.writeFieldName(((Class&lt;?&gt;)value).getName());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case TYPE_ENUM:
&nbsp;                {
&nbsp;                    String str = provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)
&nbsp;                            ? value.toString() : ((Enum&lt;?&gt;) value).name();
<b class="fc">&nbsp;                    g.writeFieldName(str);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                break;
<b class="nc">&nbsp;            case TYPE_TO_STRING:</b>
<b class="nc">&nbsp;            default:</b>
<b class="nc">&nbsp;                g.writeFieldName(value.toString());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    /**</b>
&nbsp;     * Key serializer used when key type is not known statically, and actual key
<b class="nc">&nbsp;     * serializer needs to be dynamically located.</b>
&nbsp;     */
&nbsp;    public static class Dynamic extends StdSerializer&lt;Object&gt;
<b class="fc">&nbsp;    {</b>
&nbsp;        // Important: MUST be transient, to allow serialization of key serializer itself
<b class="fc">&nbsp;        protected transient PropertySerializerMap _dynamicSerializers;</b>
&nbsp;        
&nbsp;        public Dynamic() {
&nbsp;            super(String.class, false);
&nbsp;            _dynamicSerializers = PropertySerializerMap.emptyForProperties();
&nbsp;        }
&nbsp;
&nbsp;        Object readResolve() {
&nbsp;            // Since it&#39;s transient, and since JDK serialization by-passes ctor, need this:
&nbsp;            _dynamicSerializers = PropertySerializerMap.emptyForProperties();
&nbsp;            return this;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        @Override</b>
<b class="fc">&nbsp;        public void serialize(Object value, JsonGenerator g, SerializerProvider provider)</b>
<b class="fc">&nbsp;                throws IOException</b>
&nbsp;        {
&nbsp;            Class&lt;?&gt; cls = value.getClass();
&nbsp;            PropertySerializerMap m = _dynamicSerializers;
<b class="fc">&nbsp;            JsonSerializer&lt;Object&gt; ser = m.serializerFor(cls);</b>
<b class="fc">&nbsp;            if (ser == null) {</b>
&nbsp;                ser = _findAndAddDynamic(m, cls, provider);
&nbsp;            }
&nbsp;            ser.serialize(value, g, provider);
&nbsp;        }
&nbsp;
&nbsp;        @Override
<b class="fc">&nbsp;        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {</b>
<b class="fc">&nbsp;            visitStringFormat(visitor, typeHint);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        protected JsonSerializer&lt;Object&gt; _findAndAddDynamic(PropertySerializerMap map,</b>
&nbsp;                Class&lt;?&gt; type, SerializerProvider provider) throws JsonMappingException
<b class="fc">&nbsp;        {</b>
<b class="nc">&nbsp;            PropertySerializerMap.SerializerAndMapResult result =</b>
&nbsp;                    // null -&gt; for now we won&#39;t keep ref or pass BeanProperty; could change
&nbsp;                    map.findAndAddKeySerializer(type, provider, null);
&nbsp;            // did we get a new map of serializers? If so, start using it
<b class="fc">&nbsp;            if (map != result.map) {</b>
<b class="fc">&nbsp;                _dynamicSerializers = result.map;</b>
&nbsp;            }
&nbsp;            return result.serializer;
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    /**</b>
&nbsp;     * Simple and fast key serializer when keys are Strings.
<b class="fc">&nbsp;     */</b>
<b class="fc">&nbsp;    public static class StringKeySerializer extends StdSerializer&lt;Object&gt;</b>
<b class="fc">&nbsp;    {</b>
&nbsp;        public StringKeySerializer() { super(String.class, false); }
<b class="fc">&nbsp;</b>
&nbsp;        @Override
<b class="fc">&nbsp;        public void serialize(Object value, JsonGenerator g, SerializerProvider provider) throws IOException {</b>
&nbsp;            g.writeFieldName((String) value);
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    /**</b>
&nbsp;     * Specialized instance to use for Enum keys, as per [databind#1322]
&nbsp;     *
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public static class EnumKeySerializer extends StdSerializer&lt;Object&gt;
&nbsp;    {
&nbsp;        protected final EnumValues _values;
&nbsp;
<b class="fc">&nbsp;        protected EnumKeySerializer(Class&lt;?&gt; enumType, EnumValues values) {</b>
&nbsp;            super(enumType, false);
&nbsp;            _values = values;
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;        public static EnumKeySerializer construct(Class&lt;?&gt; enumType,</b>
&nbsp;                EnumValues enumValues)
&nbsp;        {
&nbsp;            return new EnumKeySerializer(enumType, enumValues);
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public void serialize(Object value, JsonGenerator g, SerializerProvider serializers)
&nbsp;                throws IOException
&nbsp;        {
&nbsp;            if (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {
&nbsp;                g.writeFieldName(value.toString());
&nbsp;                return;
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            Enum&lt;?&gt; en = (Enum&lt;?&gt;) value;</b>
<b class="fc">&nbsp;            g.writeFieldName(_values.serializedValueFor(en));</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 23:47</div>
</div>
</body>
</html>
