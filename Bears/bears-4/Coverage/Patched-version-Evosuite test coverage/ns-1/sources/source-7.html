


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DeserializationContext</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind</a>
</div>

<h1>Coverage Summary for Class: DeserializationContext (com.fasterxml.jackson.databind)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DeserializationContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/77)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/225)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.text.DateFormat;
&nbsp;import java.text.ParseException;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.atomic.AtomicReference;
&nbsp;
&nbsp;import com.fasterxml.jackson.annotation.JsonFormat;
&nbsp;import com.fasterxml.jackson.annotation.ObjectIdGenerator;
&nbsp;import com.fasterxml.jackson.annotation.ObjectIdResolver;
&nbsp;import com.fasterxml.jackson.core.*;
&nbsp;import com.fasterxml.jackson.databind.cfg.ContextAttributes;
&nbsp;import com.fasterxml.jackson.databind.deser.*;
&nbsp;import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;
&nbsp;import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;
&nbsp;import com.fasterxml.jackson.databind.exc.InvalidFormatException;
&nbsp;import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
&nbsp;import com.fasterxml.jackson.databind.introspect.Annotated;
&nbsp;import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
&nbsp;import com.fasterxml.jackson.databind.node.JsonNodeFactory;
&nbsp;import com.fasterxml.jackson.databind.type.TypeFactory;
&nbsp;import com.fasterxml.jackson.databind.util.*;
&nbsp;
&nbsp;/**
&nbsp; * Context for the process of deserialization a single root-level value.
&nbsp; * Used to allow passing in configuration settings and reusable temporary
&nbsp; * objects (scrap arrays, containers).
&nbsp; *&lt;p&gt;
&nbsp; * Instance life-cycle is such that an partially configured &quot;blueprint&quot; object
&nbsp; * is registered with {@link ObjectMapper} (and {@link ObjectReader},
&nbsp; * and when an actual instance is needed for deserialization,
&nbsp; * a fully configured instance will
&nbsp; * be created using a method in excented API of sub-class
&nbsp; * ({@link com.fasterxml.jackson.databind.deser.DefaultDeserializationContext#createInstance}).
&nbsp; * Each instance is guaranteed to only be used from single-threaded context;
&nbsp; * instances may be reused iff no configuration has changed.
&nbsp; *&lt;p&gt;
&nbsp; * Defined as abstract class so that implementations must define methods
&nbsp; * for reconfiguring blueprints and creating instances.
&nbsp; */
&nbsp;public abstract class DeserializationContext
&nbsp;    extends DatabindContext
&nbsp;    implements java.io.Serializable
&nbsp;{
&nbsp;    private static final long serialVersionUID = 1L; // 2.6
&nbsp;
&nbsp;    /**
&nbsp;     * Let&#39;s limit length of error messages, for cases where underlying data
&nbsp;     * may be very large -- no point in spamming logs with megs of meaningless
&nbsp;     * data.
&nbsp;     */
&nbsp;    private final static int MAX_ERROR_STR_LEN = 500;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, immutable
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Object that handle details of {@link JsonDeserializer} caching.
&nbsp;     */
&nbsp;    protected final DeserializerCache _cache;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, changeable via fluent factories
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Read-only factory instance; exposed to let
&nbsp;     * owners (&lt;code&gt;ObjectMapper&lt;/code&gt;, &lt;code&gt;ObjectReader&lt;/code&gt;)
&nbsp;     * access it.
&nbsp;     */
&nbsp;    protected final DeserializerFactory _factory;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration that gets set for instances (not blueprints)
&nbsp;    /* (partly denormalized for performance)
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Generic deserialization processing configuration
&nbsp;     */
&nbsp;    protected final DeserializationConfig _config;
&nbsp;
&nbsp;    /**
&nbsp;     * Bitmap of {@link DeserializationFeature}s that are enabled
&nbsp;     */
&nbsp;    protected final int _featureFlags;
&nbsp;
&nbsp;    /**
&nbsp;     * Currently active view, if any.
&nbsp;     */
&nbsp;    protected final Class&lt;?&gt; _view;
&nbsp;
&nbsp;    /**
&nbsp;     * Currently active parser used for deserialization.
&nbsp;     * May be different from the outermost parser
&nbsp;     * when content is buffered.
&nbsp;     */
&nbsp;    protected transient JsonParser _parser;
&nbsp;    
&nbsp;    /**
&nbsp;     * Object used for resolving references to injectable
&nbsp;     * values.
&nbsp;     */
&nbsp;    protected final InjectableValues _injectableValues;
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Per-operation reusable helper objects (not for blueprints)
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    protected transient ArrayBuilders _arrayBuilders;
&nbsp;
&nbsp;    protected transient ObjectBuffer _objectBuffer;
&nbsp;
&nbsp;    protected transient DateFormat _dateFormat;
&nbsp;
&nbsp;    /**
&nbsp;     * Lazily-constructed holder for per-call attributes.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    protected transient ContextAttributes _attributes;
&nbsp;
&nbsp;    /**
&nbsp;     * Type of {@link JsonDeserializer} (or, more specifically,
&nbsp;     *   {@link ContextualDeserializer}) that is being
&nbsp;     *   contextualized currently.
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected LinkedNode&lt;JavaType&gt; _currentType;
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Life-cycle
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    protected DeserializationContext(DeserializerFactory df) {
<b class="nc">&nbsp;        this(df, null);</b>
&nbsp;    }
&nbsp;    
&nbsp;    protected DeserializationContext(DeserializerFactory df,
&nbsp;            DeserializerCache cache)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        if (df == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can not pass null DeserializerFactory&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        _factory = df;</b>
<b class="nc">&nbsp;        _cache = (cache == null) ? new DeserializerCache() : cache;</b>
&nbsp;        
<b class="nc">&nbsp;        _featureFlags = 0;</b>
<b class="nc">&nbsp;        _config = null;</b>
<b class="nc">&nbsp;        _injectableValues = null;</b>
<b class="nc">&nbsp;        _view = null;</b>
<b class="nc">&nbsp;        _attributes = null;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected DeserializationContext(DeserializationContext src,
&nbsp;            DeserializerFactory factory)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        _cache = src._cache;</b>
<b class="nc">&nbsp;        _factory = factory;</b>
&nbsp;        
<b class="nc">&nbsp;        _config = src._config;</b>
<b class="nc">&nbsp;        _featureFlags = src._featureFlags;</b>
<b class="nc">&nbsp;        _view = src._view;</b>
<b class="nc">&nbsp;        _parser = src._parser;</b>
<b class="nc">&nbsp;        _injectableValues = src._injectableValues;</b>
<b class="nc">&nbsp;        _attributes = src._attributes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor used for creating actual per-call instances.
&nbsp;     */
&nbsp;    protected DeserializationContext(DeserializationContext src,
&nbsp;            DeserializationConfig config, JsonParser p,
&nbsp;            InjectableValues injectableValues)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        _cache = src._cache;</b>
<b class="nc">&nbsp;        _factory = src._factory;</b>
&nbsp;        
<b class="nc">&nbsp;        _config = config;</b>
<b class="nc">&nbsp;        _featureFlags = config.getDeserializationFeatures();</b>
<b class="nc">&nbsp;        _view = config.getActiveView();</b>
<b class="nc">&nbsp;        _parser = p;</b>
<b class="nc">&nbsp;        _injectableValues = injectableValues;</b>
<b class="nc">&nbsp;        _attributes = config.getAttributes();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy-constructor for use with &lt;code&gt;copy()&lt;/code&gt; by {@link ObjectMapper#copy()}
&nbsp;     */
<b class="nc">&nbsp;    protected DeserializationContext(DeserializationContext src) {</b>
<b class="nc">&nbsp;        _cache = new DeserializerCache();</b>
<b class="nc">&nbsp;        _factory = src._factory;</b>
&nbsp;
<b class="nc">&nbsp;        _config = src._config;</b>
<b class="nc">&nbsp;        _featureFlags = src._featureFlags;</b>
<b class="nc">&nbsp;        _view = src._view;</b>
<b class="nc">&nbsp;        _injectableValues = null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* DatabindContext implementation
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
<b class="nc">&nbsp;    public DeserializationConfig getConfig() { return _config; }</b>
&nbsp;
&nbsp;    @Override
<b class="nc">&nbsp;    public final Class&lt;?&gt; getActiveView() { return _view; }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public final boolean canOverrideAccessModifiers() {
<b class="nc">&nbsp;        return _config.canOverrideAccessModifiers();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final boolean isEnabled(MapperFeature feature) {
<b class="nc">&nbsp;        return _config.isEnabled(feature);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final JsonFormat.Value getDefaultPropertyFormat(Class&lt;?&gt; baseType) {
<b class="nc">&nbsp;        return _config.getDefaultPropertyFormat(baseType);</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public final AnnotationIntrospector getAnnotationIntrospector() {
<b class="nc">&nbsp;        return _config.getAnnotationIntrospector();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final TypeFactory getTypeFactory() {
<b class="nc">&nbsp;        return _config.getTypeFactory();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for accessing default Locale to use: convenience method for
&nbsp;     *&lt;pre&gt;
&nbsp;     *   getConfig().getLocale();
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Locale getLocale() {
<b class="nc">&nbsp;        return _config.getLocale();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for accessing default TimeZone to use: convenience method for
&nbsp;     *&lt;pre&gt;
&nbsp;     *   getConfig().getTimeZone();
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    @Override
&nbsp;    public TimeZone getTimeZone() {
<b class="nc">&nbsp;        return _config.getTimeZone();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Access to per-call state, like generic attributes (2.3+)
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public Object getAttribute(Object key) {
<b class="nc">&nbsp;        return _attributes.getAttribute(key);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public DeserializationContext setAttribute(Object key, Object value)
&nbsp;    {
<b class="nc">&nbsp;        _attributes = _attributes.withPerCallAttribute(key, value);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accessor to {@link JavaType} of currently contextualized
&nbsp;     * {@link ContextualDeserializer}, if any.
&nbsp;     * This is sometimes useful for generic {@link JsonDeserializer}s that
&nbsp;     * do not get passed (or do not retain) type information when being
&nbsp;     * constructed: happens for example for deserializers constructed
&nbsp;     * from annotations.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     *
&nbsp;     * @return Type of {@link ContextualDeserializer} being contextualized,
&nbsp;     *   if process is on-going; null if not.
&nbsp;     */
&nbsp;    public JavaType getContextualType() {
<b class="nc">&nbsp;        return (_currentType == null) ? null : _currentType.value();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API, config setting accessors
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method for getting current {@link DeserializerFactory}.
&nbsp;     */
&nbsp;    public DeserializerFactory getFactory() {
<b class="nc">&nbsp;        return _factory;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method for checking whether specified on/off
&nbsp;     * feature is enabled
&nbsp;     */
&nbsp;    public final boolean isEnabled(DeserializationFeature feat) {
&nbsp;        /* 03-Dec-2010, tatu: minor shortcut; since this is called quite often,
&nbsp;         *   let&#39;s use a local copy of feature settings:
&nbsp;         */
<b class="nc">&nbsp;        return (_featureFlags &amp; feat.getMask()) != 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
&nbsp;     * that are enabled.
&nbsp;     *
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public final int getDeserializationFeatures() {
<b class="nc">&nbsp;        return _featureFlags;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Bulk access method for checking that all features specified by
&nbsp;     * mask are enabled.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public final boolean hasDeserializationFeatures(int featureMask) {
<b class="nc">&nbsp;        return (_featureFlags &amp; featureMask) == featureMask;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Bulk access method for checking that at least one of features specified by
&nbsp;     * mask is enabled.
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public final boolean hasSomeOfFeatures(int featureMask) {
<b class="nc">&nbsp;        return (_featureFlags &amp; featureMask) != 0;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for accessing the currently active parser.
&nbsp;     * May be different from the outermost parser
&nbsp;     * when content is buffered.
&nbsp;     *&lt;p&gt;
&nbsp;     * Use of this method is discouraged: if code has direct access
&nbsp;     * to the active parser, that should be used instead.
&nbsp;     */
<b class="nc">&nbsp;    public final JsonParser getParser() { return _parser; }</b>
&nbsp;
&nbsp;    public final Object findInjectableValue(Object valueId,
&nbsp;            BeanProperty forProperty, Object beanInstance)
&nbsp;    {
<b class="nc">&nbsp;        if (_injectableValues == null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;No &#39;injectableValues&#39; configured, can not inject value with id [&quot;+valueId+&quot;]&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return _injectableValues.findInjectableValue(valueId, this, forProperty, beanInstance);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for accessing the default Base64 encoding
&nbsp;     * used for decoding base64 encoded binary content.
&nbsp;     * Same as calling:
&nbsp;     *&lt;pre&gt;
&nbsp;     *  getConfig().getBase64Variant();
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    public final Base64Variant getBase64Variant() {
<b class="nc">&nbsp;        return _config.getBase64Variant();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method, functionally equivalent to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *  getConfig().getNodeFactory();
&nbsp;     * &lt;/pre&gt;
&nbsp;     */
&nbsp;    public final JsonNodeFactory getNodeFactory() {
<b class="nc">&nbsp;        return _config.getNodeFactory();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API, pass-through to DeserializerCache
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Deprecated // since 2.3, use overloaded variant
&nbsp;    public boolean hasValueDeserializerFor(JavaType type) {
<b class="nc">&nbsp;        return hasValueDeserializerFor(type, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for checking whether we could find a deserializer
&nbsp;     * for given type.
&nbsp;     *
&nbsp;     * @param type
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public boolean hasValueDeserializerFor(JavaType type, AtomicReference&lt;Throwable&gt; cause) {
&nbsp;        try {
<b class="nc">&nbsp;            return _cache.hasValueDeserializerFor(this, _factory, type);</b>
<b class="nc">&nbsp;        } catch (JsonMappingException e) {</b>
<b class="nc">&nbsp;            if (cause != null) {</b>
<b class="nc">&nbsp;                cause.set(e);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;            if (cause == null) { // earlier behavior</b>
<b class="nc">&nbsp;                throw e;</b>
&nbsp;            }
<b class="nc">&nbsp;            cause.set(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for finding a value deserializer, and creating a contextual
&nbsp;     * version if necessary, for value reached via specified property.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final JsonDeserializer&lt;Object&gt; findContextualValueDeserializer(JavaType type,
&nbsp;            BeanProperty prop) throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        JsonDeserializer&lt;Object&gt; deser = _cache.findValueDeserializer(this, _factory, type);</b>
<b class="nc">&nbsp;        if (deser != null) {</b>
<b class="nc">&nbsp;            deser = (JsonDeserializer&lt;Object&gt;) handleSecondaryContextualization(deser, prop, type);</b>
&nbsp;        }
<b class="nc">&nbsp;        return deser;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Variant that will try to locate deserializer for current type, but without
&nbsp;     * performing any contextualization (unlike {@link #findContextualValueDeserializer})
&nbsp;     * or checking for need to create a {@link TypeDeserializer} (unlike
&nbsp;     * {@link #findRootValueDeserializer(JavaType)}.
&nbsp;     * This method is usually called from within {@link ResolvableDeserializer#resolve},
&nbsp;     * and expectation is that caller then calls either
&nbsp;     * {@link #handlePrimaryContextualization(JsonDeserializer, BeanProperty, JavaType)} or
&nbsp;     * {@link #handleSecondaryContextualization(JsonDeserializer, BeanProperty, JavaType)} at a
&nbsp;     * later point, as necessary.
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public final JsonDeserializer&lt;Object&gt; findNonContextualValueDeserializer(JavaType type)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return _cache.findValueDeserializer(this, _factory, type);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for finding a deserializer for root-level value.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final JsonDeserializer&lt;Object&gt; findRootValueDeserializer(JavaType type)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        JsonDeserializer&lt;Object&gt; deser = _cache.findValueDeserializer(this,</b>
&nbsp;                _factory, type);
<b class="nc">&nbsp;        if (deser == null) { // can this occur?</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        deser = (JsonDeserializer&lt;Object&gt;) handleSecondaryContextualization(deser, null, type);</b>
<b class="nc">&nbsp;        TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type);</b>
<b class="nc">&nbsp;        if (typeDeser != null) {</b>
&nbsp;            // important: contextualize to indicate this is for root value
<b class="nc">&nbsp;            typeDeser = typeDeser.forProperty(null);</b>
<b class="nc">&nbsp;            return new TypeWrappedDeserializer(typeDeser, deser);</b>
&nbsp;        }
<b class="nc">&nbsp;        return deser;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method, functionally same as:
&nbsp;     *&lt;pre&gt;
&nbsp;     *  getDeserializerProvider().findKeyDeserializer(getConfig(), prop.getType(), prop);
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    public final KeyDeserializer findKeyDeserializer(JavaType keyType,
&nbsp;            BeanProperty prop) throws JsonMappingException {
<b class="nc">&nbsp;        KeyDeserializer kd = _cache.findKeyDeserializer(this,</b>
&nbsp;                _factory, keyType);
&nbsp;        // Second: contextualize?
<b class="nc">&nbsp;        if (kd instanceof ContextualKeyDeserializer) {</b>
<b class="nc">&nbsp;            kd = ((ContextualKeyDeserializer) kd).createContextual(this, prop);</b>
&nbsp;        }
<b class="nc">&nbsp;        return kd;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API, ObjectId handling
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method called to find and return entry corresponding to given
&nbsp;     * Object Id: will add an entry if necessary, and never returns null
&nbsp;     */
&nbsp;    public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator&lt;?&gt; generator, ObjectIdResolver resolver);
&nbsp;
&nbsp;    @Deprecated // since 2.4
&nbsp;    public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator&lt;?&gt; generator);
&nbsp;
&nbsp;    /**
&nbsp;     * Method called to ensure that every object id encounter during processing
&nbsp;     * are resolved.
&nbsp;     * 
&nbsp;     * @throws UnresolvedForwardReference
&nbsp;     */
&nbsp;    public abstract void checkUnresolvedObjectId()
&nbsp;        throws UnresolvedForwardReference;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API, type handling
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method, functionally equivalent to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *  getConfig().constructType(cls);
&nbsp;     * &lt;/pre&gt;
&nbsp;     */
&nbsp;    public final JavaType constructType(Class&lt;?&gt; cls) {
<b class="nc">&nbsp;        return _config.constructType(cls);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method that is to be used when resolving basic class name into
&nbsp;     * Class instance, the reason being that it may be necessary to work around
&nbsp;     * various ClassLoader limitations, as well as to handle primitive type
&nbsp;     * signatures.
&nbsp;     *
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public Class&lt;?&gt; findClass(String className) throws ClassNotFoundException
&nbsp;    {
&nbsp;        // By default, delegate to ClassUtil: can be overridden with custom handling
<b class="nc">&nbsp;        return getTypeFactory().findClass(className);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API, helper object recycling
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to get access to a reusable ObjectBuffer,
&nbsp;     * useful for efficiently constructing Object arrays and Lists.
&nbsp;     * Note that leased buffers should be returned once deserializer
&nbsp;     * is done, to allow for reuse during same round of deserialization.
&nbsp;     */
&nbsp;    public final ObjectBuffer leaseObjectBuffer()
&nbsp;    {
<b class="nc">&nbsp;        ObjectBuffer buf = _objectBuffer;</b>
<b class="nc">&nbsp;        if (buf == null) {</b>
<b class="nc">&nbsp;            buf = new ObjectBuffer();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            _objectBuffer = null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return buf;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to call to return object buffer previously leased with
&nbsp;     * {@link #leaseObjectBuffer}.
&nbsp;     * 
&nbsp;     * @param buf Returned object buffer
&nbsp;     */
&nbsp;    public final void returnObjectBuffer(ObjectBuffer buf)
&nbsp;    {
&nbsp;        /* Already have a reusable buffer? Let&#39;s retain bigger one
&nbsp;         * (or if equal, favor newer one, shorter life-cycle)
&nbsp;         */
<b class="nc">&nbsp;        if (_objectBuffer == null</b>
<b class="nc">&nbsp;            || buf.initialCapacity() &gt;= _objectBuffer.initialCapacity()) {</b>
<b class="nc">&nbsp;            _objectBuffer = buf;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for accessing object useful for building arrays of
&nbsp;     * primitive types (such as int[]).
&nbsp;     */
&nbsp;    public final ArrayBuilders getArrayBuilders()
&nbsp;    {
<b class="nc">&nbsp;        if (_arrayBuilders == null) {</b>
<b class="nc">&nbsp;            _arrayBuilders = new ArrayBuilders();</b>
&nbsp;        }
<b class="nc">&nbsp;        return _arrayBuilders;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended API: handler instantiation
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    public abstract JsonDeserializer&lt;Object&gt; deserializerInstance(Annotated annotated,
&nbsp;            Object deserDef)
&nbsp;        throws JsonMappingException;
&nbsp;
&nbsp;    public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated,
&nbsp;            Object deserDef)
&nbsp;        throws JsonMappingException;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended API: resolving contextual deserializers; called
&nbsp;    /* by structured deserializers for their value/component
&nbsp;    /* deserializers
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method called for primary property deserializers (ones
&nbsp;     * directly created to deserialize values of a POJO property),
&nbsp;     * to handle details of resolving
&nbsp;     * {@link ContextualDeserializer} with given property context.
&nbsp;     * 
&nbsp;     * @param prop Property for which the given primary deserializer is used; never null.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public JsonDeserializer&lt;?&gt; handlePrimaryContextualization(JsonDeserializer&lt;?&gt; deser,
&nbsp;            BeanProperty prop, JavaType type)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (deser instanceof ContextualDeserializer) {</b>
<b class="nc">&nbsp;            _currentType = new LinkedNode&lt;JavaType&gt;(type, _currentType);</b>
&nbsp;            try {
<b class="nc">&nbsp;                deser = ((ContextualDeserializer) deser).createContextual(this, prop);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                _currentType = _currentType.next();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return deser;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method called for secondary property deserializers (ones
&nbsp;     * NOT directly created to deal with an annotatable POJO property,
&nbsp;     * but instead created as a component -- such as value deserializers
&nbsp;     * for structured types, or deserializers for root values)
&nbsp;     * to handle details of resolving
&nbsp;     * {@link ContextualDeserializer} with given property context.
&nbsp;     * Given that these deserializers are not directly related to given property
&nbsp;     * (or, in case of root value property, to any property), annotations
&nbsp;     * accessible may or may not be relevant.
&nbsp;     * 
&nbsp;     * @param prop Property for which deserializer is used, if any; null
&nbsp;     *    when deserializing root values
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public JsonDeserializer&lt;?&gt; handleSecondaryContextualization(JsonDeserializer&lt;?&gt; deser,
&nbsp;            BeanProperty prop, JavaType type)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (deser instanceof ContextualDeserializer) {</b>
<b class="nc">&nbsp;            _currentType = new LinkedNode&lt;JavaType&gt;(type, _currentType);</b>
&nbsp;            try {
<b class="nc">&nbsp;                deser = ((ContextualDeserializer) deser).createContextual(this, prop);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                _currentType = _currentType.next();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return deser;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated // since 2.5; remove from 2.7
&nbsp;    public JsonDeserializer&lt;?&gt; handlePrimaryContextualization(JsonDeserializer&lt;?&gt; deser, BeanProperty prop) throws JsonMappingException {
<b class="nc">&nbsp;        return handlePrimaryContextualization(deser, prop, TypeFactory.unknownType());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated // since 2.5; remove from 2.7
&nbsp;    public JsonDeserializer&lt;?&gt; handleSecondaryContextualization(JsonDeserializer&lt;?&gt; deser, BeanProperty prop) throws JsonMappingException {
<b class="nc">&nbsp;        if (deser instanceof ContextualDeserializer) {</b>
<b class="nc">&nbsp;            deser = ((ContextualDeserializer) deser).createContextual(this, prop);</b>
&nbsp;        }
<b class="nc">&nbsp;        return deser;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Parsing methods that may use reusable/-cyclable objects
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for parsing a Date from given String, using
&nbsp;     * currently configured date format (accessed using
&nbsp;     * {@link DeserializationConfig#getDateFormat()}).
&nbsp;     *&lt;p&gt;
&nbsp;     * Implementation will handle thread-safety issues related to
&nbsp;     * date formats such that first time this method is called,
&nbsp;     * date format is cloned, and cloned instance will be retained
&nbsp;     * for use during this deserialization round.
&nbsp;     */
&nbsp;    public Date parseDate(String dateStr) throws IllegalArgumentException
&nbsp;    {
&nbsp;        try {
<b class="nc">&nbsp;            DateFormat df = getDateFormat();</b>
<b class="nc">&nbsp;            return df.parse(dateStr);</b>
<b class="nc">&nbsp;        } catch (ParseException e) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(String.format(</b>
<b class="nc">&nbsp;                    &quot;Failed to parse Date value &#39;%s&#39;: %s&quot;, dateStr, e.getMessage()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for constructing Calendar instance set
&nbsp;     * to specified time, to be modified and used by caller.
&nbsp;     */
&nbsp;    public Calendar constructCalendar(Date d) {
&nbsp;        // 08-Jan-2008, tatu: not optimal, but should work for the most part; let&#39;s revise as needed.
<b class="nc">&nbsp;        Calendar c = Calendar.getInstance(getTimeZone());</b>
<b class="nc">&nbsp;        c.setTime(d);</b>
<b class="nc">&nbsp;        return c;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Convenience methods for reading parsed values
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that may be used by composite or container deserializers,
&nbsp;     * for reading one-off values contained (for sequences, it is more efficient
&nbsp;     * to actually fetch deserializer once for the whole collection).
&nbsp;     *&lt;p&gt;
&nbsp;     * NOTE: when deserializing values of properties contained in composite types,
&nbsp;     * rather use {@link #readPropertyValue(JsonParser, BeanProperty, Class)};
&nbsp;     * this method does not allow use of contextual annotations.
&nbsp;     * 
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public &lt;T&gt; T readValue(JsonParser p, Class&lt;T&gt; type) throws IOException {
<b class="nc">&nbsp;        return readValue(p, getTypeFactory().constructType(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(JsonParser p, JavaType type) throws IOException {
<b class="nc">&nbsp;        JsonDeserializer&lt;Object&gt; deser = findRootValueDeserializer(type);</b>
<b class="nc">&nbsp;        if (deser == null) {</b>
<b class="nc">&nbsp;            throw mappingException(&quot;Could not find JsonDeserializer for type %s&quot;, type);</b>
&nbsp;        }
<b class="nc">&nbsp;        return (T) deser.deserialize(p, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that may be used by composite or container deserializers,
&nbsp;     * for reading one-off values for the composite type, taking into account
&nbsp;     * annotations that the property (passed to this method -- usually property that
&nbsp;     * has custom serializer that called this method) has.
&nbsp;     * 
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public &lt;T&gt; T readPropertyValue(JsonParser p, BeanProperty prop, Class&lt;T&gt; type) throws IOException {
<b class="nc">&nbsp;        return readPropertyValue(p, prop, getTypeFactory().constructType(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readPropertyValue(JsonParser p, BeanProperty prop, JavaType type) throws IOException {
<b class="nc">&nbsp;        JsonDeserializer&lt;Object&gt; deser = findContextualValueDeserializer(type, prop);</b>
<b class="nc">&nbsp;        if (deser == null) {</b>
<b class="nc">&nbsp;            String propName = (prop == null) ? &quot;NULL&quot; : (&quot;&#39;&quot;+prop.getName()+&quot;&#39;&quot;);</b>
<b class="nc">&nbsp;            throw mappingException(&quot;Could not find JsonDeserializer for type %s (via property %s)&quot;,</b>
&nbsp;                    type, propName);
&nbsp;        }
<b class="nc">&nbsp;        return (T) deser.deserialize(p, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Methods for problem handling, reporting
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method deserializers can call to inform configured {@link DeserializationProblemHandler}s
&nbsp;     * of an unrecognized property.
&nbsp;     * 
&nbsp;     * @return True if there was a configured problem handler that was able to handle the
&nbsp;     *   problem
&nbsp;     */
&nbsp;    public boolean handleUnknownProperty(JsonParser p, JsonDeserializer&lt;?&gt; deser,
&nbsp;            Object instanceOrClass, String propName)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        LinkedNode&lt;DeserializationProblemHandler&gt; h = _config.getProblemHandlers();</b>
<b class="nc">&nbsp;        if (h != null) {</b>
<b class="nc">&nbsp;            while (h != null) {</b>
&nbsp;                // Can bail out if it&#39;s handled
<b class="nc">&nbsp;                if (h.value().handleUnknownProperty(this, p, deser, instanceOrClass, propName)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                h = h.next();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method for reporting a problem with unhandled unknown exception
&nbsp;     * 
&nbsp;     * @param instanceOrClass Either value being populated (if one has been
&nbsp;     *   instantiated), or Class that indicates type that would be (or
&nbsp;     *   have been) instantiated
&nbsp;     * @param deser Deserializer that had the problem, if called by deserializer
&nbsp;     *   (or on behalf of one)
&nbsp;     */
&nbsp;    public void reportUnknownProperty(Object instanceOrClass, String fieldName,
&nbsp;            JsonDeserializer&lt;?&gt; deser)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // Do we know properties that are expected instead?
<b class="nc">&nbsp;        Collection&lt;Object&gt; propIds = (deser == null) ? null : deser.getKnownPropertyNames();</b>
<b class="nc">&nbsp;        throw UnrecognizedPropertyException.from(_parser,</b>
&nbsp;                instanceOrClass, fieldName, propIds);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public JsonMappingException reportMappingException(String msg, Object... msgArgs)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (msgArgs.length &gt; 0) {</b>
<b class="nc">&nbsp;            msg = String.format(msg, msgArgs);</b>
&nbsp;        }
<b class="nc">&nbsp;        throw mappingException(msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public JsonMappingException reportInstantiationException(Class&lt;?&gt; instClass, Throwable t)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        throw instantiationException(instClass, t);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public JsonMappingException reportInstantiationException(Class&lt;?&gt; instClass,
&nbsp;            String msg, Object... msgArgs)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (msgArgs.length &gt; 0) {</b>
<b class="nc">&nbsp;            msg = String.format(msg, msgArgs);</b>
&nbsp;        }
<b class="nc">&nbsp;        throw instantiationException(instClass, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public &lt;T&gt; T reportWeirdStringException(String value, Class&lt;?&gt; instClass,
&nbsp;            String msg, Object... msgArgs)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (msgArgs.length &gt; 0) {</b>
<b class="nc">&nbsp;            msg = String.format(msg, msgArgs);</b>
&nbsp;        }
<b class="nc">&nbsp;        throw weirdStringException(value, instClass, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public &lt;T&gt; T reportWeirdNumberException(Number value, Class&lt;?&gt; instClass,
&nbsp;            String msg, Object... msgArgs)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (msgArgs.length &gt; 0) {</b>
<b class="nc">&nbsp;            msg = String.format(msg, msgArgs);</b>
&nbsp;        }
<b class="nc">&nbsp;        throw weirdNumberException(value, instClass, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public &lt;T&gt; T reportWeirdKeyException(Class&lt;?&gt; keyClass, String keyValue,
&nbsp;            String msg, Object... msgArgs)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (msgArgs.length &gt; 0) {</b>
<b class="nc">&nbsp;            msg = String.format(msg, msgArgs);</b>
&nbsp;        }
<b class="nc">&nbsp;        throw weirdKeyException(keyClass, keyValue, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public &lt;T&gt; T reportWrongTokenException(JsonParser p,
&nbsp;            JsonToken expToken, String msg, Object... msgArgs)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (msgArgs.length &gt; 0) {</b>
<b class="nc">&nbsp;            msg = String.format(msg, msgArgs);</b>
&nbsp;        }
<b class="nc">&nbsp;        throw wrongTokenException(p, expToken, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public &lt;T&gt; T reportUnknownTypeException(JavaType type, String id,
&nbsp;            String extraDesc) throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        throw unknownTypeException(type, id, extraDesc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public &lt;T&gt; T reportEndOfInputException(Class&lt;?&gt; instClass) throws JsonMappingException {
<b class="nc">&nbsp;        throw endOfInputException(instClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Methods for constructing exceptions
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper method for constructing generic mapping exception for specified type
&nbsp;     */
&nbsp;    public JsonMappingException mappingException(Class&lt;?&gt; targetClass) {
<b class="nc">&nbsp;        return mappingException(targetClass, _parser.getCurrentToken());</b>
&nbsp;    }
&nbsp;
&nbsp;    public JsonMappingException mappingException(Class&lt;?&gt; targetClass, JsonToken token) {
<b class="nc">&nbsp;        String tokenDesc = (token == null) ? &quot;&lt;end of input&gt;&quot; : String.format(&quot;%s token&quot;, token);</b>
<b class="nc">&nbsp;        return JsonMappingException.from(_parser,</b>
<b class="nc">&nbsp;                String.format(&quot;Can not deserialize instance of %s out of %s&quot;,</b>
<b class="nc">&nbsp;                        _calcName(targetClass), tokenDesc));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper method for constructing generic mapping exception with specified
&nbsp;     * message and current location information
&nbsp;     */
&nbsp;    public JsonMappingException mappingException(String message) {
<b class="nc">&nbsp;        return JsonMappingException.from(getParser(), message);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method for constructing generic mapping exception with specified
&nbsp;     * message and current location information
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public JsonMappingException mappingException(String msgTemplate, Object... args) {
<b class="nc">&nbsp;        String message = String.format(msgTemplate, args);</b>
<b class="nc">&nbsp;        return JsonMappingException.from(getParser(), message);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper method for constructing instantiation exception for specified type,
&nbsp;     * to indicate problem with physically constructing instance of
&nbsp;     * specified class (missing constructor, exception from constructor)
&nbsp;     */
&nbsp;    public JsonMappingException instantiationException(Class&lt;?&gt; instClass, Throwable t) {
<b class="nc">&nbsp;        return JsonMappingException.from(_parser,</b>
<b class="nc">&nbsp;                String.format(&quot;Can not construct instance of %s, problem: %s&quot;, instClass.getName(), t.getMessage()), t);</b>
&nbsp;    }
&nbsp;
&nbsp;    public JsonMappingException instantiationException(Class&lt;?&gt; instClass, String msg) {
<b class="nc">&nbsp;        return JsonMappingException.from(_parser,</b>
<b class="nc">&nbsp;                String.format(&quot;Can not construct instance of %s, problem: %s&quot;, instClass.getName(), msg));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that will construct an exception suitable for throwing when
&nbsp;     * some String values are acceptable, but the one encountered is not.
&nbsp;     * 
&nbsp;     * @param value String value from input being deserialized
&nbsp;     * @param instClass Type that String should be deserialized into
&nbsp;     * @param msg Message that describes specific problem
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public JsonMappingException weirdStringException(String value, Class&lt;?&gt; instClass, String msg) {
<b class="nc">&nbsp;        return InvalidFormatException.from(_parser,</b>
<b class="nc">&nbsp;                String.format(&quot;Can not construct instance of %s from String value (%s): %s&quot;,</b>
<b class="nc">&nbsp;                        instClass.getName(), _quotedString(value), msg),</b>
&nbsp;                value, instClass);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method for constructing exception to indicate that input JSON
&nbsp;     * Number was not suitable for deserializing into given target type.
&nbsp;     */
&nbsp;    public JsonMappingException weirdNumberException(Number value, Class&lt;?&gt; instClass, String msg) {
<b class="nc">&nbsp;        return InvalidFormatException.from(_parser,</b>
<b class="nc">&nbsp;                String.format(&quot;Can not construct instance of %s from number value (%s): %s&quot;,</b>
<b class="nc">&nbsp;                        instClass.getName(), String.valueOf(value), msg),</b>
&nbsp;                value, instClass);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method for constructing exception to indicate that given JSON
&nbsp;     * Object field name was not in format to be able to deserialize specified
&nbsp;     * key type.
&nbsp;     */
&nbsp;    public JsonMappingException weirdKeyException(Class&lt;?&gt; keyClass, String keyValue, String msg) {
<b class="nc">&nbsp;        return InvalidFormatException.from(_parser,</b>
<b class="nc">&nbsp;                String.format(&quot;Can not construct Map key of type %s from String (%s): %s&quot;,</b>
<b class="nc">&nbsp;                        keyClass.getName(), _quotedString(keyValue), msg),</b>
&nbsp;                keyValue, keyClass);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method for indicating that the current token was expected to be another
&nbsp;     * token.
&nbsp;     */
&nbsp;    public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg0) {
<b class="nc">&nbsp;        String msg = String.format(&quot;Unexpected token (%s), expected %s&quot;,</b>
<b class="nc">&nbsp;                p.getCurrentToken(), expToken);</b>
<b class="nc">&nbsp;        if (msg0 != null) {</b>
<b class="nc">&nbsp;            msg = msg + &quot;: &quot;+msg0;</b>
&nbsp;        }
<b class="nc">&nbsp;        return JsonMappingException.from(p, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method for constructing exception to indicate that given
&nbsp;     * type id (parsed from JSON) could not be converted to a Java type.
&nbsp;     */
&nbsp;    @Deprecated // since 2.5, use overloaded variant
&nbsp;    public JsonMappingException unknownTypeException(JavaType type, String id) {
<b class="nc">&nbsp;        return JsonMappingException.from(_parser, &quot;Could not resolve type id &#39;&quot;+id+&quot;&#39; into a subtype of &quot;+type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public JsonMappingException unknownTypeException(JavaType type, String id,
&nbsp;            String extraDesc) {
<b class="nc">&nbsp;        String msg = String.format(&quot;Could not resolve type id &#39;%s&#39; into a subtype of %s&quot;,</b>
&nbsp;                id, type);
<b class="nc">&nbsp;        if (extraDesc != null) {</b>
<b class="nc">&nbsp;            msg = msg + &quot;: &quot;+extraDesc;</b>
&nbsp;        }
<b class="nc">&nbsp;        return JsonMappingException.from(_parser, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    public JsonMappingException endOfInputException(Class&lt;?&gt; instClass) {
<b class="nc">&nbsp;        return JsonMappingException.from(_parser, &quot;Unexpected end-of-input when trying to deserialize a &quot;</b>
<b class="nc">&nbsp;                +instClass.getName());</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Overridable internal methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    protected DateFormat getDateFormat()
&nbsp;    {
<b class="nc">&nbsp;        if (_dateFormat != null) {</b>
<b class="nc">&nbsp;            return _dateFormat;</b>
&nbsp;        }
&nbsp;        /* 24-Feb-2012, tatu: At this point, all timezone configuration
&nbsp;         *    should have occurred, with respect to default dateformat
&nbsp;         *    and timezone configuration. But we still better clone
&nbsp;         *    an instance as formatters may be stateful.
&nbsp;         */
<b class="nc">&nbsp;        DateFormat df = _config.getDateFormat();</b>
<b class="nc">&nbsp;        _dateFormat = df = (DateFormat) df.clone();</b>
<b class="nc">&nbsp;        return df;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected String determineClassName(Object instance) {
<b class="nc">&nbsp;        return ClassUtil.getClassDescription(instance);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Other internal methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    protected String _calcName(Class&lt;?&gt; cls) {
<b class="nc">&nbsp;        if (cls.isArray()) {</b>
<b class="nc">&nbsp;            return _calcName(cls.getComponentType())+&quot;[]&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return cls.getName();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected String _valueDesc() {
&nbsp;        try {
<b class="nc">&nbsp;            return _desc(_parser.getText());</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            return &quot;[N/A]&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected String _desc(String desc) {
<b class="nc">&nbsp;        if (desc == null) {</b>
<b class="nc">&nbsp;            return &quot;[N/A]&quot;;</b>
&nbsp;        }
&nbsp;        // !!! should we quote it? (in case there are control chars, linefeeds)
<b class="nc">&nbsp;        if (desc.length() &gt; MAX_ERROR_STR_LEN) {</b>
<b class="nc">&nbsp;            desc = desc.substring(0, MAX_ERROR_STR_LEN) + &quot;]...[&quot; + desc.substring(desc.length() - MAX_ERROR_STR_LEN);</b>
&nbsp;        }
<b class="nc">&nbsp;        return desc;</b>
&nbsp;    }
&nbsp;
&nbsp;    // @since 2.7
&nbsp;    protected String _quotedString(String desc) {
<b class="nc">&nbsp;        if (desc == null) {</b>
<b class="nc">&nbsp;            return &quot;[N/A]&quot;;</b>
&nbsp;        }
&nbsp;        // !!! should we quote it? (in case there are control chars, linefeeds)
<b class="nc">&nbsp;        if (desc.length() &gt; MAX_ERROR_STR_LEN) {</b>
<b class="nc">&nbsp;            return String.format(&quot;\&quot;%s]...[%s\&quot;&quot;,</b>
<b class="nc">&nbsp;                    desc.substring(0, MAX_ERROR_STR_LEN),</b>
<b class="nc">&nbsp;                    desc.substring(desc.length() - MAX_ERROR_STR_LEN));</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;\&quot;&quot; + desc + &quot;\&quot;&quot;;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-02 19:56</div>
</div>
</body>
</html>
