


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > EnumDeserializer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.deser.std</a>
</div>

<h1>Coverage Summary for Class: EnumDeserializer (com.fasterxml.jackson.databind.deser.std)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EnumDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/69)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EnumDeserializer$FactoryBasedDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/96)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.deser.std;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.reflect.Method;
&nbsp;
&nbsp;import com.fasterxml.jackson.core.*;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
&nbsp;import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
&nbsp;import com.fasterxml.jackson.databind.exc.InvalidFormatException;
&nbsp;import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
&nbsp;import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
&nbsp;import com.fasterxml.jackson.databind.util.ClassUtil;
&nbsp;import com.fasterxml.jackson.databind.util.CompactStringObjectMap;
&nbsp;import com.fasterxml.jackson.databind.util.EnumResolver;
&nbsp;
&nbsp;/**
&nbsp; * Deserializer class that can deserialize instances of
&nbsp; * specified Enum class from Strings and Integers.
&nbsp; */
&nbsp;@JacksonStdImpl // was missing until 2.6
&nbsp;public class EnumDeserializer
&nbsp;    extends StdScalarDeserializer&lt;Object&gt;
&nbsp;{
&nbsp;    private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    protected Object[] _enumsByIndex;
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.7.3
&nbsp;     */
&nbsp;    protected final CompactStringObjectMap _lookupByName;
&nbsp;
&nbsp;    /**
&nbsp;     * Alternatively, we may need a different lookup object if &quot;use toString&quot;
&nbsp;     * is defined.
&nbsp;     *
&nbsp;     * @since 2.7.3
&nbsp;     */
&nbsp;    protected CompactStringObjectMap _lookupByToString;
&nbsp;    
&nbsp;    public EnumDeserializer(EnumResolver byNameResolver)
&nbsp;    {
<b class="nc">&nbsp;        super(byNameResolver.getEnumClass());</b>
<b class="nc">&nbsp;        _lookupByName = byNameResolver.constructLookup();</b>
<b class="nc">&nbsp;        _enumsByIndex = byNameResolver.getRawEnums();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method used when Enum instances are to be deserialized
&nbsp;     * using a creator (static factory method)
&nbsp;     * 
&nbsp;     * @return Deserializer based on given factory method, if type was suitable;
&nbsp;     *  null if type can not be used
&nbsp;     */
&nbsp;    public static JsonDeserializer&lt;?&gt; deserializerForCreator(DeserializationConfig config,
&nbsp;            Class&lt;?&gt; enumClass, AnnotatedMethod factory)
&nbsp;    {
&nbsp;        // note: caller has verified there&#39;s just one arg; but we must verify its type
<b class="nc">&nbsp;        Class&lt;?&gt; paramClass = factory.getRawParameterType(0);</b>
<b class="nc">&nbsp;        if (config.canOverrideAccessModifiers()) {</b>
<b class="nc">&nbsp;            ClassUtil.checkAndFixAccess(factory.getMember(),</b>
<b class="nc">&nbsp;                    config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new FactoryBasedDeserializer(enumClass, factory, paramClass);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Default JsonDeserializer implementation
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Because of costs associated with constructing Enum resolvers,
&nbsp;     * let&#39;s cache instances by default.
&nbsp;     */
&nbsp;    @Override
<b class="nc">&nbsp;    public boolean isCachable() { return true; }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;    {
<b class="nc">&nbsp;        JsonToken curr = p.getCurrentToken();</b>
&nbsp;        
&nbsp;        // Usually should just get string value:
<b class="nc">&nbsp;        if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) {</b>
<b class="nc">&nbsp;            CompactStringObjectMap lookup = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)</b>
<b class="nc">&nbsp;                    ? _getToStringLookup() : _lookupByName;</b>
<b class="nc">&nbsp;            final String name = p.getText();</b>
<b class="nc">&nbsp;            Object result = lookup.find(name);</b>
<b class="nc">&nbsp;            if (result == null) {</b>
<b class="nc">&nbsp;                return _deserializeAltString(p, ctxt, lookup, name);</b>
&nbsp;            }
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;        // But let&#39;s consider int acceptable as well (if within ordinal range)
<b class="nc">&nbsp;        if (curr == JsonToken.VALUE_NUMBER_INT) {</b>
&nbsp;            // ... unless told not to do that
<b class="nc">&nbsp;            int index = p.getIntValue();</b>
<b class="nc">&nbsp;            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {</b>
<b class="nc">&nbsp;                _failOnNumber(ctxt, p, index);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (index &gt;= 0 &amp;&amp; index &lt; _enumsByIndex.length) {</b>
<b class="nc">&nbsp;                return _enumsByIndex[index];</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {</b>
<b class="nc">&nbsp;                throw ctxt.weirdNumberException(index, _enumClass(),</b>
&nbsp;                        &quot;index value outside legal index range [0..&quot;+(_enumsByIndex.length-1)+&quot;]&quot;);
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return _deserializeOther(p, ctxt);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Internal helper methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    private final Object _deserializeAltString(JsonParser p, DeserializationContext ctxt,
&nbsp;            CompactStringObjectMap lookup, String name) throws IOException
&nbsp;    {
<b class="nc">&nbsp;        name = name.trim();</b>
<b class="nc">&nbsp;        if (name.length() == 0) {</b>
<b class="nc">&nbsp;            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // [databind#149]: Allow use of &#39;String&#39; indexes as well
<b class="nc">&nbsp;            char c = name.charAt(0);</b>
<b class="nc">&nbsp;            if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    int ix = Integer.parseInt(name);</b>
<b class="nc">&nbsp;                    if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {</b>
<b class="nc">&nbsp;                        _failOnNumber(ctxt, p, ix);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (ix &gt;= 0 &amp;&amp; ix &lt; _enumsByIndex.length) {</b>
<b class="nc">&nbsp;                        return _enumsByIndex[ix];</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (NumberFormatException e) {</b>
&nbsp;                    // fine, ignore, was not an integer
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {</b>
<b class="nc">&nbsp;            throw ctxt.weirdStringException(name, _enumClass(),</b>
<b class="nc">&nbsp;                    &quot;value not one of declared Enum instance names: &quot;+lookup.keys());</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Object _deserializeOther(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;    {
<b class="nc">&nbsp;        JsonToken curr = p.getCurrentToken();</b>
&nbsp;        // [databind#381]
<b class="nc">&nbsp;        if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)</b>
<b class="nc">&nbsp;                &amp;&amp; p.isExpectedStartArrayToken()) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final Object parsed = deserialize(p, ctxt);</b>
<b class="nc">&nbsp;            curr = p.nextToken();</b>
<b class="nc">&nbsp;            if (curr != JsonToken.END_ARRAY) {</b>
<b class="nc">&nbsp;                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY,</b>
<b class="nc">&nbsp;                        &quot;Attempted to unwrap single value array for single &#39;&quot; + _enumClass().getName() + &quot;&#39; value but there was more than a single value in the array&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return parsed;</b>
&nbsp;        }
<b class="nc">&nbsp;        throw ctxt.mappingException(_enumClass());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void _failOnNumber(DeserializationContext ctxt, JsonParser p, int index)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        throw InvalidFormatException.from(p,</b>
<b class="nc">&nbsp;                String.format(&quot;Not allowed to deserialize Enum value out of JSON number (%d): disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow&quot;,</b>
<b class="nc">&nbsp;                        index),</b>
<b class="nc">&nbsp;                        index, _enumClass());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Class&lt;?&gt; _enumClass() {
<b class="nc">&nbsp;        return handledType();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected CompactStringObjectMap _getToStringLookup()
&nbsp;    {
<b class="nc">&nbsp;        CompactStringObjectMap lookup = _lookupByToString;</b>
&nbsp;        // note: exact locking not needed; all we care for here is to try to
&nbsp;        // reduce contention for the initial resolution
<b class="nc">&nbsp;        if (lookup == null) {</b>
<b class="nc">&nbsp;            synchronized (this) {</b>
<b class="nc">&nbsp;                lookup = EnumResolver.constructUnsafeUsingToString(_enumClass())</b>
<b class="nc">&nbsp;                        .constructLookup();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            _lookupByToString = lookup;</b>
&nbsp;        }
<b class="nc">&nbsp;        return lookup;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Additional helper classes
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Deserializer that uses a single-String static factory method
&nbsp;     * for locating Enum values by String id.
&nbsp;     */
&nbsp;    protected static class FactoryBasedDeserializer
&nbsp;        extends StdDeserializer&lt;Object&gt;
&nbsp;        implements ContextualDeserializer
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1;
&nbsp;
&nbsp;        // Marker type; null if String expected; otherwise numeric wrapper
&nbsp;        protected final Class&lt;?&gt; _inputType;
&nbsp;        protected final Method _factory;
&nbsp;        protected final JsonDeserializer&lt;?&gt; _deser;
&nbsp;        
&nbsp;        public FactoryBasedDeserializer(Class&lt;?&gt; cls, AnnotatedMethod f,
&nbsp;                Class&lt;?&gt; inputType)
&nbsp;        {
<b class="nc">&nbsp;            super(cls);</b>
<b class="nc">&nbsp;            _factory = f.getAnnotated();</b>
<b class="nc">&nbsp;            _inputType = inputType;</b>
<b class="nc">&nbsp;            _deser = null;</b>
&nbsp;        }
&nbsp;
&nbsp;        protected FactoryBasedDeserializer(FactoryBasedDeserializer base,
&nbsp;                JsonDeserializer&lt;?&gt; deser) {
<b class="nc">&nbsp;            super(base._valueClass);</b>
<b class="nc">&nbsp;            _inputType = base._inputType;</b>
<b class="nc">&nbsp;            _factory = base._factory;</b>
<b class="nc">&nbsp;            _deser = deser;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public JsonDeserializer&lt;?&gt; createContextual(DeserializationContext ctxt,
&nbsp;                BeanProperty property)
&nbsp;            throws JsonMappingException
&nbsp;        {
<b class="nc">&nbsp;            if ((_deser == null) &amp;&amp; (_inputType != String.class)) {</b>
<b class="nc">&nbsp;                return new FactoryBasedDeserializer(this,</b>
<b class="nc">&nbsp;                        ctxt.findContextualValueDeserializer(ctxt.constructType(_inputType), property));</b>
&nbsp;            }
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
&nbsp;            Object value;
<b class="nc">&nbsp;            if (_deser != null) {</b>
<b class="nc">&nbsp;                value = _deser.deserialize(p, ctxt);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                JsonToken curr = p.getCurrentToken();</b>
<b class="nc">&nbsp;                if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) {</b>
<b class="nc">&nbsp;                    value = p.getText();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    value = p.getValueAsString();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                return _factory.invoke(_valueClass, value);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                Throwable t = ClassUtil.getRootCause(e);</b>
<b class="nc">&nbsp;                if (t instanceof IOException) {</b>
<b class="nc">&nbsp;                    throw (IOException) t;</b>
&nbsp;                }
<b class="nc">&nbsp;                throw ctxt.instantiationException(_valueClass, t);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
<b class="nc">&nbsp;            if (_deser == null) { // String never has type info</b>
<b class="nc">&nbsp;                return deserialize(p, ctxt);</b>
&nbsp;            }
<b class="nc">&nbsp;            return typeDeserializer.deserializeTypedFromAny(p, ctxt);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-02 19:53</div>
</div>
</body>
</html>
