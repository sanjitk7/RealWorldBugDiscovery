


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ClusterResource</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.cassandrareaper.resources</a>
</div>

<h1>Coverage Summary for Class: ClusterResource (io.cassandrareaper.resources)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClusterResource</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/173)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package io.cassandrareaper.resources;
&nbsp;
&nbsp;import io.cassandrareaper.AppContext;
&nbsp;import io.cassandrareaper.ReaperException;
&nbsp;import io.cassandrareaper.core.Cluster;
&nbsp;import io.cassandrareaper.jmx.JmxProxy;
&nbsp;import io.cassandrareaper.resources.view.ClusterStatus;
&nbsp;import io.cassandrareaper.resources.view.NodesStatus;
&nbsp;import io.cassandrareaper.resources.view.RepairRunStatus;
&nbsp;import io.cassandrareaper.resources.view.RepairScheduleStatus;
&nbsp;import io.cassandrareaper.service.ClusterRepairScheduler;
&nbsp;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URI;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.net.URL;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import javax.ws.rs.DELETE;
&nbsp;import javax.ws.rs.GET;
&nbsp;import javax.ws.rs.POST;
&nbsp;import javax.ws.rs.PUT;
&nbsp;import javax.ws.rs.Path;
&nbsp;import javax.ws.rs.PathParam;
&nbsp;import javax.ws.rs.Produces;
&nbsp;import javax.ws.rs.QueryParam;
&nbsp;import javax.ws.rs.core.Context;
&nbsp;import javax.ws.rs.core.MediaType;
&nbsp;import javax.ws.rs.core.Response;
&nbsp;import javax.ws.rs.core.UriInfo;
&nbsp;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import com.google.common.collect.Maps;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;@Path(&quot;/cluster&quot;)
&nbsp;@Produces(MediaType.APPLICATION_JSON)
&nbsp;public final class ClusterResource {
&nbsp;
&nbsp;  private static final int JMX_NODE_STATUS_CONCURRENCY = 3;
&nbsp;
<b class="nc">&nbsp;  private static final ExecutorService CLUSTER_STATUS_EXECUTOR</b>
<b class="nc">&nbsp;      = Executors.newFixedThreadPool(JMX_NODE_STATUS_CONCURRENCY * 2);</b>
&nbsp;
<b class="nc">&nbsp;  private static final Logger LOG = LoggerFactory.getLogger(ClusterResource.class);</b>
&nbsp;
&nbsp;  private final AppContext context;
&nbsp;  private final ClusterRepairScheduler clusterRepairScheduler;
&nbsp;
<b class="nc">&nbsp;  public ClusterResource(AppContext context) {</b>
<b class="nc">&nbsp;    this.context = context;</b>
<b class="nc">&nbsp;    this.clusterRepairScheduler = new ClusterRepairScheduler(context);</b>
&nbsp;  }
&nbsp;
&nbsp;  @GET
&nbsp;  public Response getClusterList(
&nbsp;      @QueryParam(&quot;seedHost&quot;) Optional&lt;String&gt; seedHost) {
&nbsp;
<b class="nc">&nbsp;    LOG.debug(&quot;get cluster list called&quot;);</b>
<b class="nc">&nbsp;    Collection&lt;Cluster&gt; clusters = context.storage.getClusters();</b>
<b class="nc">&nbsp;    List&lt;String&gt; clusterNames = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    for (Cluster cluster : clusters) {</b>
<b class="nc">&nbsp;      if (seedHost.isPresent()) {</b>
<b class="nc">&nbsp;        if (cluster.getSeedHosts().contains(seedHost.get())) {</b>
<b class="nc">&nbsp;          clusterNames.add(cluster.getName());</b>
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        clusterNames.add(cluster.getName());</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return Response.ok().entity(clusterNames).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  @GET
&nbsp;  @Path(&quot;/{cluster_name}&quot;)
&nbsp;  public Response getCluster(
&nbsp;      @PathParam(&quot;cluster_name&quot;) String clusterName,
&nbsp;      @QueryParam(&quot;limit&quot;) Optional&lt;Integer&gt; limit)
&nbsp;      throws ReaperException {
&nbsp;
<b class="nc">&nbsp;    LOG.debug(&quot;get cluster called with cluster_name: {}&quot;, clusterName);</b>
<b class="nc">&nbsp;    return viewCluster(clusterName, limit, Optional.&lt;URI&gt;absent());</b>
&nbsp;  }
&nbsp;
&nbsp;  private Response viewCluster(String clusterName, Optional&lt;Integer&gt; limit, Optional&lt;URI&gt; createdUri)
&nbsp;      throws ReaperException {
&nbsp;
<b class="nc">&nbsp;    Optional&lt;Cluster&gt; cluster = context.storage.getCluster(clusterName);</b>
&nbsp;
<b class="nc">&nbsp;    if (!cluster.isPresent()) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.NOT_FOUND)</b>
<b class="nc">&nbsp;          .entity(&quot;cluster with name \&quot;&quot; + clusterName + &quot;\&quot; not found&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    } else {
<b class="nc">&nbsp;      ClusterStatus view = new ClusterStatus(</b>
<b class="nc">&nbsp;          cluster.get(),</b>
<b class="nc">&nbsp;          context.storage.getClusterRunStatuses(clusterName, limit.or(Integer.MAX_VALUE)),</b>
<b class="nc">&nbsp;          context.storage.getClusterScheduleStatuses(clusterName),</b>
<b class="nc">&nbsp;          getNodesStatus(cluster).orNull());</b>
<b class="nc">&nbsp;      if (createdUri.isPresent()) {</b>
<b class="nc">&nbsp;        return Response.created(createdUri.get()).entity(view).build();</b>
&nbsp;      } else {
<b class="nc">&nbsp;        return Response.ok().entity(view).build();</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @GET
&nbsp;  @Path(&quot;/{cluster_name}/tables&quot;)
&nbsp;  public Response getClusterTables(@PathParam(&quot;cluster_name&quot;) String clusterName)
&nbsp;      throws ReaperException {
<b class="nc">&nbsp;    Map&lt;String, List&lt;String&gt;&gt; tablesByKeyspace = Maps.newHashMap();</b>
&nbsp;
<b class="nc">&nbsp;    Optional&lt;Cluster&gt; cluster = context.storage.getCluster(clusterName);</b>
<b class="nc">&nbsp;    if (cluster.isPresent()) {</b>
<b class="nc">&nbsp;      try (JmxProxy jmxProxy =</b>
<b class="nc">&nbsp;          context.jmxConnectionFactory.connectAny(</b>
<b class="nc">&nbsp;              cluster.get(), context.config.getJmxConnectionTimeoutInSeconds())) {</b>
<b class="nc">&nbsp;        tablesByKeyspace = jmxProxy.listTablesByKeyspace();</b>
<b class="nc">&nbsp;        jmxProxy.close();</b>
<b class="nc">&nbsp;      } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;        LOG.error(&quot;Couldn&#39;t retrieve the list of tables for cluster {}&quot;, clusterName, e);</b>
<b class="nc">&nbsp;        return Response.status(400).entity(e).build();</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return Response.ok().entity(tablesByKeyspace).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  @POST
&nbsp;  public Response addCluster(
&nbsp;      @Context UriInfo uriInfo,
&nbsp;      @QueryParam(&quot;seedHost&quot;) Optional&lt;String&gt; seedHost)
&nbsp;      throws ReaperException {
&nbsp;
<b class="nc">&nbsp;    if (!seedHost.isPresent()) {</b>
<b class="nc">&nbsp;      LOG.error(&quot;POST on cluster resource called without seedHost&quot;);</b>
<b class="nc">&nbsp;      return Response.status(400).entity(&quot;query parameter \&quot;seedHost\&quot; required&quot;).build();</b>
&nbsp;    }
<b class="nc">&nbsp;    LOG.debug(&quot;add cluster called with seedHost: {}&quot;, seedHost.get());</b>
&nbsp;
&nbsp;    Cluster newCluster;
&nbsp;    try {
<b class="nc">&nbsp;      newCluster = createClusterWithSeedHost(seedHost.get());</b>
<b class="nc">&nbsp;    } catch (java.lang.SecurityException e) {</b>
<b class="nc">&nbsp;      LOG.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;      return Response.status(400)</b>
<b class="nc">&nbsp;          .entity(&quot;seed host \&quot;&quot; + seedHost.get() + &quot;\&quot; JMX threw security exception: &quot; + e.getMessage())</b>
<b class="nc">&nbsp;          .build();</b>
<b class="nc">&nbsp;    } catch (ReaperException e) {</b>
<b class="nc">&nbsp;      LOG.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;      return Response.status(400).entity(&quot;failed to create cluster with seed host: &quot; + seedHost.get()).build();</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    Optional&lt;Cluster&gt; existingCluster = context.storage.getCluster(newCluster.getName());</b>
<b class="nc">&nbsp;    if (existingCluster.isPresent()) {</b>
<b class="nc">&nbsp;      LOG.info(&quot;cluster already stored with this name: {}&quot;, existingCluster);</b>
<b class="nc">&nbsp;      return Response.status(403)</b>
<b class="nc">&nbsp;          .entity(String.format(&quot;cluster \&quot;%s\&quot; already exists&quot;, existingCluster.get().getName()))</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    } else {
<b class="nc">&nbsp;      LOG.info(&quot;creating new cluster based on given seed host: {}&quot;, newCluster.getName());</b>
<b class="nc">&nbsp;      context.storage.addCluster(newCluster);</b>
&nbsp;
<b class="nc">&nbsp;      if (context.config.hasAutoSchedulingEnabled()) {</b>
&nbsp;        try {
<b class="nc">&nbsp;          clusterRepairScheduler.scheduleRepairs(newCluster);</b>
<b class="nc">&nbsp;        } catch (ReaperException e) {</b>
<b class="nc">&nbsp;          LOG.error(&quot;failed to automatically schedule repairs&quot;, e);</b>
<b class="nc">&nbsp;          return Response.status(400)</b>
<b class="nc">&nbsp;              .entity(</b>
&nbsp;                  &quot;failed to automatically schedule repairs for cluster with seed host \&quot;&quot;
<b class="nc">&nbsp;                  + seedHost.get()</b>
&nbsp;                  + &quot;\&quot;. Exception was: &quot;
<b class="nc">&nbsp;                  + e.getMessage())</b>
<b class="nc">&nbsp;              .build();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    URI createdUri;
&nbsp;    try {
<b class="nc">&nbsp;      createdUri = new URL(uriInfo.getAbsolutePath().toURL(), newCluster.getName()).toURI();</b>
<b class="nc">&nbsp;    } catch (MalformedURLException | URISyntaxException e) {</b>
<b class="nc">&nbsp;      String errMsg = &quot;failed creating target URI for cluster: &quot; + newCluster.getName();</b>
<b class="nc">&nbsp;      LOG.error(errMsg, e);</b>
<b class="nc">&nbsp;      return Response.status(400).entity(errMsg).build();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    return viewCluster(newCluster.getName(), Optional.&lt;Integer&gt;absent(), Optional.of(createdUri));</b>
&nbsp;  }
&nbsp;
&nbsp;  private Cluster createClusterWithSeedHost(String seedHostInput) throws ReaperException {
<b class="nc">&nbsp;    Optional&lt;String&gt; clusterName = Optional.absent();</b>
<b class="nc">&nbsp;    Optional&lt;String&gt; partitioner = Optional.absent();</b>
<b class="nc">&nbsp;    Optional&lt;List&lt;String&gt;&gt; liveNodes = Optional.absent();</b>
<b class="nc">&nbsp;    Set&lt;String&gt; seedHosts = parseSeedHosts(seedHostInput);</b>
&nbsp;
<b class="nc">&nbsp;    try (JmxProxy jmxProxy = context.jmxConnectionFactory.connectAny(</b>
<b class="nc">&nbsp;        Optional.absent(), seedHosts, context.config.getJmxConnectionTimeoutInSeconds())) {</b>
&nbsp;
<b class="nc">&nbsp;      clusterName = Optional.of(jmxProxy.getClusterName());</b>
<b class="nc">&nbsp;      partitioner = Optional.of(jmxProxy.getPartitioner());</b>
<b class="nc">&nbsp;      liveNodes = Optional.of(jmxProxy.getLiveNodes());</b>
<b class="nc">&nbsp;    } catch (ReaperException e) {</b>
<b class="nc">&nbsp;      LOG.error(&quot;failed to create cluster with seed hosts: {}&quot;, seedHosts, e);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    if (!clusterName.isPresent()) {</b>
<b class="nc">&nbsp;      throw new ReaperException(&quot;Could not connect any seed host&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Set&lt;String&gt; seedHostsFinal = seedHosts;</b>
<b class="nc">&nbsp;    if (context.config.getEnableDynamicSeedList() &amp;&amp; liveNodes.isPresent()) {</b>
<b class="nc">&nbsp;      seedHostsFinal = !liveNodes.get().isEmpty() ? liveNodes.get().stream().collect(Collectors.toSet()) : seedHosts;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    LOG.debug(&quot;Seeds {}&quot;, seedHostsFinal);</b>
&nbsp;
<b class="nc">&nbsp;    return new Cluster(clusterName.get(), partitioner.get(), seedHostsFinal);</b>
&nbsp;  }
&nbsp;
&nbsp;  @PUT
&nbsp;  @Path(&quot;/{cluster_name}&quot;)
&nbsp;  public Response modifyClusterSeed(
&nbsp;      @Context UriInfo uriInfo,
&nbsp;      @PathParam(&quot;cluster_name&quot;) String clusterName,
&nbsp;      @QueryParam(&quot;seedHost&quot;) Optional&lt;String&gt; seedHost)
&nbsp;      throws ReaperException {
&nbsp;
<b class="nc">&nbsp;    if (!seedHost.isPresent()) {</b>
<b class="nc">&nbsp;      LOG.error(&quot;PUT on cluster resource called without seedHost&quot;);</b>
<b class="nc">&nbsp;      return Response.status(400).entity(&quot;query parameter \&quot;seedHost\&quot; required&quot;).build();</b>
&nbsp;    }
<b class="nc">&nbsp;    LOG.info(&quot;modify cluster called with: cluster_name = {}, seedHost = {}&quot;, clusterName, seedHost.get());</b>
&nbsp;
<b class="nc">&nbsp;    Optional&lt;Cluster&gt; cluster = context.storage.getCluster(clusterName);</b>
<b class="nc">&nbsp;    if (!cluster.isPresent()) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.NOT_FOUND)</b>
<b class="nc">&nbsp;          .entity(&quot;cluster with name &quot; + clusterName + &quot; not found&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Set&lt;String&gt; newSeeds = parseSeedHosts(seedHost.get());</b>
&nbsp;
<b class="nc">&nbsp;    if (context.config.getEnableDynamicSeedList()) {</b>
<b class="nc">&nbsp;      try (JmxProxy jmxProxy = context.jmxConnectionFactory.connectAny(</b>
<b class="nc">&nbsp;          Optional.absent(), newSeeds, context.config.getJmxConnectionTimeoutInSeconds())) {</b>
&nbsp;
<b class="nc">&nbsp;        Optional&lt;List&lt;String&gt;&gt; liveNodes = Optional.of(jmxProxy.getLiveNodes());</b>
<b class="nc">&nbsp;        newSeeds = liveNodes.get().stream().collect(Collectors.toSet());</b>
<b class="nc">&nbsp;      } catch (ReaperException e) {</b>
<b class="nc">&nbsp;        LOG.error(&quot;failed to create cluster with seed hosts: {}&quot;, newSeeds, e);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (newSeeds.equals(cluster.get().getSeedHosts()) || newSeeds.isEmpty()) {</b>
<b class="nc">&nbsp;      return Response.notModified().build();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Cluster newCluster = new Cluster(cluster.get().getName(), cluster.get().getPartitioner(), newSeeds);</b>
<b class="nc">&nbsp;    context.storage.updateCluster(newCluster);</b>
&nbsp;
<b class="nc">&nbsp;    return viewCluster(newCluster.getName(), Optional.&lt;Integer&gt;absent(), Optional.&lt;URI&gt;absent());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Delete a Cluster object with given name.
&nbsp;   *
&nbsp;   * &lt;p&gt;
&nbsp;   * Cluster can be only deleted when it hasn&#39;t any RepairRun or RepairSchedule instances under it, i.e. you mus
&nbsp;   * delete all repair runs and schedules first.
&nbsp;   *
&nbsp;   * @param clusterName The name of the Cluster instance you are about to delete.
&nbsp;   * @return The deleted RepairRun instance, with state overwritten to string &quot;DELETED&quot;.
&nbsp;   */
&nbsp;  @DELETE
&nbsp;  @Path(&quot;/{cluster_name}&quot;)
&nbsp;  public Response deleteCluster(
&nbsp;      @PathParam(&quot;cluster_name&quot;) String clusterName)
&nbsp;      throws ReaperException {
&nbsp;
<b class="nc">&nbsp;    LOG.info(&quot;delete cluster called with clusterName: {}&quot;, clusterName);</b>
<b class="nc">&nbsp;    Optional&lt;Cluster&gt; clusterToDelete = context.storage.getCluster(clusterName);</b>
<b class="nc">&nbsp;    if (!clusterToDelete.isPresent()) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.NOT_FOUND)</b>
<b class="nc">&nbsp;          .entity(&quot;cluster with name \&quot;&quot; + clusterName + &quot;\&quot; not found&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
<b class="nc">&nbsp;    if (!context.storage.getRepairSchedulesForCluster(clusterName).isEmpty()) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.FORBIDDEN)</b>
<b class="nc">&nbsp;          .entity(&quot;cluster with name \&quot;&quot; + clusterName + &quot;\&quot; cannot be deleted, as it &quot; + &quot;has repair schedules&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
<b class="nc">&nbsp;    if (!context.storage.getRepairRunsForCluster(clusterName).isEmpty()) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.FORBIDDEN)</b>
<b class="nc">&nbsp;          .entity(&quot;cluster with name \&quot;&quot; + clusterName + &quot;\&quot; cannot be deleted, as it &quot; + &quot;has repair runs&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
<b class="nc">&nbsp;    Optional&lt;Cluster&gt; deletedCluster = context.storage.deleteCluster(clusterName);</b>
<b class="nc">&nbsp;    if (deletedCluster.isPresent()) {</b>
<b class="nc">&nbsp;      return Response.ok(</b>
&nbsp;          new ClusterStatus(
<b class="nc">&nbsp;              deletedCluster.get(),</b>
<b class="nc">&nbsp;              Collections.&lt;RepairRunStatus&gt;emptyList(),</b>
<b class="nc">&nbsp;              Collections.&lt;RepairScheduleStatus&gt;emptyList(),</b>
<b class="nc">&nbsp;              getNodesStatus(deletedCluster).orNull()))</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
<b class="nc">&nbsp;    return Response.serverError().entity(&quot;delete failed for schedule with name \&quot;&quot; + clusterName + &quot;\&quot;&quot;).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Callable to get and parse endpoint states through JMX
&nbsp;   *
&nbsp;   * @param seedHost The host address to connect to via JMX
&nbsp;   * @return An optional NodesStatus object with the status of each node in the cluster as seen from the seedHost node
&nbsp;   */
&nbsp;  private Callable&lt;Optional&lt;NodesStatus&gt;&gt; getEndpointState(List&lt;String&gt; seeds) {
<b class="nc">&nbsp;    return () -&gt; {</b>
<b class="nc">&nbsp;      try (JmxProxy jmxProxy = context.jmxConnectionFactory.connectAny(</b>
<b class="nc">&nbsp;          Optional.absent(), seeds, context.config.getJmxConnectionTimeoutInSeconds())) {</b>
&nbsp;
<b class="nc">&nbsp;        Optional&lt;String&gt; allEndpointsState = Optional.fromNullable(jmxProxy.getAllEndpointsState());</b>
<b class="nc">&nbsp;        Optional&lt;Map&lt;String, String&gt;&gt; simpleStates = Optional.fromNullable(jmxProxy.getSimpleStates());</b>
&nbsp;
<b class="nc">&nbsp;        return Optional.of(</b>
<b class="nc">&nbsp;            new NodesStatus(jmxProxy.getHost(), allEndpointsState.or(&quot;&quot;), simpleStates.or(new HashMap&lt;&gt;())));</b>
&nbsp;
<b class="nc">&nbsp;      } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;        LOG.debug(&quot;failed to create cluster with seed hosts: {}&quot;, seeds, e);</b>
<b class="nc">&nbsp;        Thread.sleep((int) JmxProxy.DEFAULT_JMX_CONNECTION_TIMEOUT.getSeconds() * 1000);</b>
<b class="nc">&nbsp;        return Optional.absent();</b>
&nbsp;      }
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Get all nodes state by querying the AllEndpointsState attribute through JMX.
&nbsp;   *
&nbsp;   * &lt;p&gt;
&nbsp;   * To speed up execution, the method calls JMX on 3 nodes asynchronously and processes the first response
&nbsp;   *
&nbsp;   * @return An optional NodesStatus object with all nodes statuses
&nbsp;   */
&nbsp;  public Optional&lt;NodesStatus&gt; getNodesStatus(Optional&lt;Cluster&gt; cluster) {
<b class="nc">&nbsp;    Optional&lt;NodesStatus&gt; nodesStatus = Optional.absent();</b>
<b class="nc">&nbsp;    if (cluster.isPresent() &amp;&amp; null != cluster.get().getSeedHosts()) {</b>
&nbsp;
<b class="nc">&nbsp;      List&lt;String&gt; seedHosts = Lists.newArrayList(cluster.get().getSeedHosts());</b>
&nbsp;
<b class="nc">&nbsp;      List&lt;Callable&lt;Optional&lt;NodesStatus&gt;&gt;&gt; endpointStateTasks = Lists.&lt;Callable&lt;Optional&lt;NodesStatus&gt;&gt;&gt;newArrayList(</b>
<b class="nc">&nbsp;          getEndpointState(seedHosts), getEndpointState(seedHosts), getEndpointState(seedHosts));</b>
&nbsp;
&nbsp;      try {
<b class="nc">&nbsp;        nodesStatus = CLUSTER_STATUS_EXECUTOR.invokeAny(</b>
&nbsp;            endpointStateTasks,
<b class="nc">&nbsp;            (int) JmxProxy.DEFAULT_JMX_CONNECTION_TIMEOUT.getSeconds(),</b>
&nbsp;            TimeUnit.SECONDS);
&nbsp;
<b class="nc">&nbsp;      } catch (InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc">&nbsp;        LOG.debug(&quot;failed grabbing nodes status&quot;, e);</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      if (nodesStatus.isPresent()) {</b>
<b class="nc">&nbsp;        return nodesStatus;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return nodesStatus;</b>
&nbsp;  }
&nbsp;
&nbsp;  static Set&lt;String&gt; parseSeedHosts(String seedHost) {
<b class="nc">&nbsp;    return Arrays.stream(seedHost.split(&quot;,&quot;)).map(String::trim).collect(Collectors.toSet());</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-02 20:50</div>
</div>
</body>
</html>
