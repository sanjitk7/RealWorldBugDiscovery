


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > NumberDeserializers</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.deser.std</a>
</div>

<h1>Coverage Summary for Class: NumberDeserializers (com.fasterxml.jackson.databind.deser.std)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">NumberDeserializers</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.7%
  </span>
  <span class="absValue">
    (45/47)
  </span>
</td>
</tr>
  <tr>
    <td class="name">NumberDeserializers$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$BigDecimalDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (11/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$BigIntegerDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (12/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$BooleanDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (28/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$ByteDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (24/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$CharacterDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (14/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$DoubleDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (25/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$FloatDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.3%
  </span>
  <span class="absValue">
    (23/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$IntegerDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.6%
  </span>
  <span class="absValue">
    (24/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$LongDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.2%
  </span>
  <span class="absValue">
    (19/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$NumberDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (30/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$PrimitiveOrWrapperDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (9/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$ShortDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.4%
  </span>
  <span class="absValue">
    (24/31)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (49/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.3%
  </span>
  <span class="absValue">
    (289/374)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.deser.std;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.util.HashSet;
&nbsp;
&nbsp;import com.fasterxml.jackson.core.*;
&nbsp;import com.fasterxml.jackson.core.io.NumberInput;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
&nbsp;import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
&nbsp;import com.fasterxml.jackson.databind.util.AccessPattern;
&nbsp;
&nbsp;/**
&nbsp; * Container class for deserializers that handle core JDK primitive
&nbsp; * (and matching wrapper) types, as well as standard &quot;big&quot; numeric types.
&nbsp; * Note that this includes types such as {@link java.lang.Boolean}
&nbsp; * and {@link java.lang.Character} which are not strictly numeric,
&nbsp; * but are part of primitive/wrapper types.
&nbsp; */
<b class="nc">&nbsp;public class NumberDeserializers</b>
&nbsp;{
<b class="fc">&nbsp;    private final static HashSet&lt;String&gt; _classNames = new HashSet&lt;String&gt;();</b>
&nbsp;    static {
&nbsp;        // note: can skip primitive types; other ways to check them:
<b class="fc">&nbsp;        Class&lt;?&gt;[] numberTypes = new Class&lt;?&gt;[] {</b>
&nbsp;            Boolean.class,
&nbsp;            Byte.class,
&nbsp;            Short.class,
&nbsp;            Character.class,
&nbsp;            Integer.class,
&nbsp;            Long.class,
&nbsp;            Float.class,
&nbsp;            Double.class,
&nbsp;            // and more generic ones
&nbsp;            Number.class, BigDecimal.class, BigInteger.class
&nbsp;        };
<b class="fc">&nbsp;        for (Class&lt;?&gt; cls : numberTypes) {</b>
<b class="fc">&nbsp;            _classNames.add(cls.getName());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JsonDeserializer&lt;?&gt; find(Class&lt;?&gt; rawType, String clsName) {
<b class="fc">&nbsp;        if (rawType.isPrimitive()) {</b>
<b class="fc">&nbsp;            if (rawType == Integer.TYPE) {</b>
<b class="fc">&nbsp;                return IntegerDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Boolean.TYPE) {</b>
<b class="fc">&nbsp;                return BooleanDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Long.TYPE) {</b>
<b class="fc">&nbsp;                return LongDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Double.TYPE) {</b>
<b class="fc">&nbsp;                return DoubleDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Character.TYPE) {</b>
<b class="fc">&nbsp;                return CharacterDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Byte.TYPE) {</b>
<b class="fc">&nbsp;                return ByteDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Short.TYPE) {</b>
<b class="fc">&nbsp;                return ShortDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Float.TYPE) {</b>
<b class="fc">&nbsp;                return FloatDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;        } else if (_classNames.contains(clsName)) {</b>
&nbsp;            // Start with most common types; int, boolean, long, double
<b class="fc">&nbsp;            if (rawType == Integer.class) {</b>
<b class="fc">&nbsp;                return IntegerDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Boolean.class) {</b>
<b class="fc">&nbsp;                return BooleanDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Long.class) {</b>
<b class="fc">&nbsp;                return LongDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Double.class) {</b>
<b class="fc">&nbsp;                return DoubleDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Character.class) {</b>
<b class="fc">&nbsp;                return CharacterDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Byte.class) {</b>
<b class="fc">&nbsp;                return ByteDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Short.class) {</b>
<b class="fc">&nbsp;                return ShortDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Float.class) {</b>
<b class="fc">&nbsp;                return FloatDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == Number.class) {</b>
<b class="fc">&nbsp;                return NumberDeserializer.instance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == BigDecimal.class) {</b>
<b class="fc">&nbsp;                return BigDecimalDeserializer.instance;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (rawType == BigInteger.class) {</b>
<b class="fc">&nbsp;                return BigIntegerDeserializer.instance;</b>
&nbsp;            }
&nbsp;        } else {
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // should never occur
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Internal error: can&#39;t find deserializer for &quot;+rawType.getName());</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Then one intermediate base class for things that have
&nbsp;    /* both primitive and wrapper types
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    protected abstract static class PrimitiveOrWrapperDeserializer&lt;T&gt;
&nbsp;        extends StdScalarDeserializer&lt;T&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        protected final T _nullValue;
&nbsp;
&nbsp;        // @since 2.9
&nbsp;        protected final T _emptyValue;
&nbsp;
&nbsp;        protected final boolean _primitive;
&nbsp;
&nbsp;        protected PrimitiveOrWrapperDeserializer(Class&lt;T&gt; vc, T nvl, T empty) {
<b class="fc">&nbsp;            super(vc);</b>
<b class="fc">&nbsp;            _nullValue = nvl;</b>
<b class="fc">&nbsp;            _emptyValue = empty;</b>
<b class="fc">&nbsp;            _primitive = vc.isPrimitive();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AccessPattern getNullAccessPattern() {
&nbsp;            // 02-Feb-2017, tatu: For primitives we must dynamically check (and possibly throw
&nbsp;            //     exception); for wrappers not.
<b class="nc">&nbsp;            if (_primitive) {</b>
<b class="nc">&nbsp;                return AccessPattern.DYNAMIC;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (_nullValue == null) {</b>
<b class="nc">&nbsp;                return AccessPattern.ALWAYS_NULL;</b>
&nbsp;            }
<b class="nc">&nbsp;            return AccessPattern.CONSTANT;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException {
&nbsp;            // 01-Mar-2017, tatu: Alas, not all paths lead to `_coerceNull()`, as `SettableBeanProperty`
&nbsp;            //    short-circuits `null` handling. Hence need this check as well.
<b class="fc">&nbsp;            if (_primitive &amp;&amp; ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {</b>
<b class="fc">&nbsp;                ctxt.reportInputMismatch(this,</b>
&nbsp;                        &quot;Can not map `null` into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to &#39;false&#39; to allow)&quot;,
<b class="fc">&nbsp;                        handledType().toString());</b>
&nbsp;            }
<b class="fc">&nbsp;            return _nullValue;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {
<b class="fc">&nbsp;            return _emptyValue;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Then primitive/wrapper types
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public final static class BooleanDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Boolean&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.TYPE, Boolean.FALSE);</b>
<b class="fc">&nbsp;        final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.class, null);</b>
&nbsp;
&nbsp;        public BooleanDeserializer(Class&lt;Boolean&gt; cls, Boolean nvl)
&nbsp;        {
<b class="fc">&nbsp;            super(cls, nvl, Boolean.FALSE);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            JsonToken t = p.getCurrentToken();</b>
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_TRUE) {</b>
<b class="fc">&nbsp;                return Boolean.TRUE;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_FALSE) {</b>
<b class="fc">&nbsp;                return Boolean.FALSE;</b>
&nbsp;            }
<b class="fc">&nbsp;            return _parseBoolean(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Since we can never have type info (&quot;natural type&quot;; String, Boolean, Integer, Double):
&nbsp;        // (is it an error to even call this version?)
&nbsp;        @Override
&nbsp;        public Boolean deserializeWithType(JsonParser p, DeserializationContext ctxt,
&nbsp;                TypeDeserializer typeDeserializer)
&nbsp;            throws IOException
&nbsp;        {
<b class="nc">&nbsp;            JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;            if (t == JsonToken.VALUE_TRUE) {</b>
<b class="nc">&nbsp;                return Boolean.TRUE;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (t == JsonToken.VALUE_FALSE) {</b>
<b class="nc">&nbsp;                return Boolean.FALSE;</b>
&nbsp;            }
<b class="nc">&nbsp;            return _parseBoolean(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final Boolean _parseBoolean(JsonParser p, DeserializationContext ctxt)
&nbsp;            throws IOException
&nbsp;        {
<b class="fc">&nbsp;            JsonToken t = p.getCurrentToken();</b>
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NULL) {</b>
<b class="fc">&nbsp;                return (Boolean) _coerceNullToken(ctxt, _primitive);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.START_ARRAY) { // unwrapping?</b>
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
&nbsp;            // should accept ints too, (0 == false, otherwise true)
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NUMBER_INT) {</b>
<b class="fc">&nbsp;                return Boolean.valueOf(_parseBooleanFromInt(p, ctxt));</b>
&nbsp;            }
&nbsp;            // And finally, let&#39;s allow Strings to be converted too
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_STRING) {</b>
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
&nbsp;                // [databind#422]: Allow aliases
<b class="fc">&nbsp;                if (&quot;true&quot;.equals(text) || &quot;True&quot;.equals(text)) {</b>
<b class="fc">&nbsp;                    _verifyStringForScalarCoercion(ctxt, text);</b>
<b class="fc">&nbsp;                    return Boolean.TRUE;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (&quot;false&quot;.equals(text) || &quot;False&quot;.equals(text)) {</b>
<b class="fc">&nbsp;                    _verifyStringForScalarCoercion(ctxt, text);</b>
<b class="fc">&nbsp;                    return Boolean.FALSE;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (text.length() == 0) {</b>
<b class="fc">&nbsp;                    return (Boolean) _coerceEmptyString(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_hasTextualNull(text)) {</b>
<b class="nc">&nbsp;                    return (Boolean) _coerceTextualNull(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                return (Boolean) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                        &quot;only \&quot;true\&quot; or \&quot;false\&quot; recognized&quot;);
&nbsp;            }
&nbsp;            // usually caller should have handled but:
<b class="nc">&nbsp;            if (t == JsonToken.VALUE_TRUE) {</b>
<b class="nc">&nbsp;                return Boolean.TRUE;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (t == JsonToken.VALUE_FALSE) {</b>
<b class="nc">&nbsp;                return Boolean.FALSE;</b>
&nbsp;            }
&nbsp;            // Otherwise, no can do:
<b class="nc">&nbsp;            return (Boolean) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public static class ByteDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Byte&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);</b>
<b class="fc">&nbsp;        final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);</b>
&nbsp;        
&nbsp;        public ByteDeserializer(Class&lt;Byte&gt; cls, Byte nvl)
&nbsp;        {
<b class="fc">&nbsp;            super(cls, nvl, (byte) 0);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Byte deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {</b>
<b class="fc">&nbsp;                return p.getByteValue();</b>
&nbsp;            }
<b class="fc">&nbsp;            return _parseByte(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected Byte _parseByte(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            JsonToken t = p.getCurrentToken();</b>
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_STRING) { // let&#39;s do implicit re-parse</b>
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
<b class="fc">&nbsp;                if (_hasTextualNull(text)) {</b>
<b class="nc">&nbsp;                    return (Byte) _coerceTextualNull(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                int len = text.length();</b>
<b class="fc">&nbsp;                if (len == 0) {</b>
<b class="fc">&nbsp;                    return (Byte) _coerceEmptyString(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                int value;
&nbsp;                try {
<b class="fc">&nbsp;                    value = NumberInput.parseInt(text);</b>
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) {</b>
<b class="nc">&nbsp;                    return (Byte) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                            &quot;not a valid Byte value&quot;);
<b class="fc">&nbsp;                }</b>
&nbsp;                // So far so good: but does it fit?
&nbsp;                // as per [JACKSON-804], allow range up to 255, inclusive
<b class="fc">&nbsp;                if (_byteOverflow(value)) {</b>
<b class="nc">&nbsp;                    return (Byte) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                            &quot;overflow, value can not be represented as 8-bit value&quot;);
&nbsp;                    // fall-through for deferred fails
&nbsp;                }
<b class="fc">&nbsp;                return Byte.valueOf((byte) value);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NUMBER_FLOAT) {</b>
<b class="fc">&nbsp;                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
<b class="nc">&nbsp;                    _failDoubleToIntCoercion(p, ctxt, &quot;Byte&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return p.getByteValue();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NULL) {</b>
<b class="nc">&nbsp;                return (Byte) _coerceNullToken(ctxt, _primitive);</b>
&nbsp;            }
&nbsp;            // [databind#381]
<b class="fc">&nbsp;            if (t == JsonToken.START_ARRAY) {</b>
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (t == JsonToken.VALUE_NUMBER_INT) { // shouldn&#39;t usually be called with it but</b>
<b class="nc">&nbsp;                return p.getByteValue();</b>
&nbsp;            }
<b class="nc">&nbsp;            return (Byte) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public static class ShortDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Short&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.TYPE, Short.valueOf((short)0));</b>
<b class="fc">&nbsp;        final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.class, null);</b>
&nbsp;        
&nbsp;        public ShortDeserializer(Class&lt;Short&gt; cls, Short nvl)
&nbsp;        {
<b class="fc">&nbsp;            super(cls, nvl, (short)0);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Short deserialize(JsonParser p, DeserializationContext ctxt)
&nbsp;            throws IOException
&nbsp;        {
<b class="fc">&nbsp;            return _parseShort(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected Short _parseShort(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            JsonToken t = p.getCurrentToken();</b>
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NUMBER_INT) {</b>
<b class="fc">&nbsp;                return p.getShortValue();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_STRING) { // let&#39;s do implicit re-parse</b>
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
<b class="fc">&nbsp;                int len = text.length();</b>
<b class="fc">&nbsp;                if (len == 0) {</b>
<b class="fc">&nbsp;                    return (Short) _coerceEmptyString(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_hasTextualNull(text)) {</b>
<b class="nc">&nbsp;                    return (Short) _coerceTextualNull(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                int value;
&nbsp;                try {
<b class="fc">&nbsp;                    value = NumberInput.parseInt(text);</b>
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) {</b>
<b class="nc">&nbsp;                    return (Short) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                            &quot;not a valid Short value&quot;);
<b class="fc">&nbsp;                }</b>
&nbsp;                // So far so good: but does it fit?
<b class="fc">&nbsp;                if (_shortOverflow(value)) {</b>
<b class="nc">&nbsp;                    return (Short) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                            &quot;overflow, value can not be represented as 16-bit value&quot;);
&nbsp;                }
<b class="fc">&nbsp;                return Short.valueOf((short) value);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NUMBER_FLOAT) {</b>
<b class="fc">&nbsp;                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
<b class="nc">&nbsp;                    _failDoubleToIntCoercion(p, ctxt, &quot;Short&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return p.getShortValue();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NULL) {</b>
<b class="nc">&nbsp;                return (Short) _coerceNullToken(ctxt, _primitive);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.START_ARRAY) {</b>
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
<b class="nc">&nbsp;            return (Short) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public static class CharacterDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Character&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.TYPE, &#39;\0&#39;);</b>
<b class="fc">&nbsp;        final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.class, null);</b>
&nbsp;        
&nbsp;        public CharacterDeserializer(Class&lt;Character&gt; cls, Character nvl)
&nbsp;        {
<b class="fc">&nbsp;            super(cls, nvl, &#39;\0&#39;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Character deserialize(JsonParser p, DeserializationContext ctxt)
&nbsp;            throws IOException
&nbsp;        {
<b class="fc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            case JsonTokenId.ID_NUMBER_INT: // ok iff ascii value
<b class="fc">&nbsp;                _verifyNumberForScalarCoercion(ctxt, p);</b>
<b class="fc">&nbsp;                int value = p.getIntValue();</b>
<b class="fc">&nbsp;                if (value &gt;= 0 &amp;&amp; value &lt;= 0xFFFF) {</b>
<b class="fc">&nbsp;                    return Character.valueOf((char) value);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case JsonTokenId.ID_STRING: // this is the usual type
&nbsp;                // But does it have to be exactly one char?
<b class="fc">&nbsp;                String text = p.getText();</b>
<b class="fc">&nbsp;                if (text.length() == 1) {</b>
<b class="fc">&nbsp;                    return Character.valueOf(text.charAt(0));</b>
&nbsp;                }
&nbsp;                // actually, empty should become null?
<b class="fc">&nbsp;                if (text.length() == 0) {</b>
<b class="fc">&nbsp;                    return (Character) _coerceEmptyString(ctxt, _primitive);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case JsonTokenId.ID_NULL:
<b class="nc">&nbsp;                return (Character) _coerceNullToken(ctxt, _primitive);</b>
&nbsp;            case JsonTokenId.ID_START_ARRAY:
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            default:
&nbsp;            }
<b class="nc">&nbsp;            return (Character) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public final static class IntegerDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Integer&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.TYPE, 0);</b>
<b class="fc">&nbsp;        final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.class, null);</b>
&nbsp;        
&nbsp;        public IntegerDeserializer(Class&lt;Integer&gt; cls, Integer nvl) {
<b class="fc">&nbsp;            super(cls, nvl, 0);</b>
&nbsp;        }
&nbsp;
&nbsp;        // since 2.6, slightly faster lookups for this very common type
&nbsp;        @Override
<b class="fc">&nbsp;        public boolean isCachable() { return true; }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
<b class="fc">&nbsp;            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {</b>
<b class="fc">&nbsp;                return p.getIntValue();</b>
&nbsp;            }
<b class="fc">&nbsp;            return _parseInteger(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Since we can never have type info (&quot;natural type&quot;; String, Boolean, Integer, Double):
&nbsp;        // (is it an error to even call this version?)
&nbsp;        @Override
&nbsp;        public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt,
&nbsp;                TypeDeserializer typeDeserializer) throws IOException
&nbsp;        {
<b class="nc">&nbsp;            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {</b>
<b class="nc">&nbsp;                return p.getIntValue();</b>
&nbsp;            }
<b class="nc">&nbsp;            return _parseInteger(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final Integer _parseInteger(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            // NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
<b class="nc">&nbsp;                return Integer.valueOf(p.getIntValue());</b>
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT: // coercing may work too
<b class="fc">&nbsp;                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
<b class="fc">&nbsp;                    _failDoubleToIntCoercion(p, ctxt, &quot;Integer&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return Integer.valueOf(p.getValueAsInt());</b>
&nbsp;            case JsonTokenId.ID_STRING: // let&#39;s do implicit re-parse
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
<b class="fc">&nbsp;                int len = text.length();</b>
<b class="fc">&nbsp;                if (len == 0) {</b>
<b class="fc">&nbsp;                    return (Integer) _coerceEmptyString(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_hasTextualNull(text)) {</b>
<b class="nc">&nbsp;                    return (Integer) _coerceTextualNull(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    if (len &gt; 9) {</b>
<b class="nc">&nbsp;                        long l = Long.parseLong(text);</b>
<b class="nc">&nbsp;                        if (_intOverflow(l)) {</b>
<b class="nc">&nbsp;                            return (Integer) ctxt.handleWeirdStringValue(_valueClass, text, String.format(</b>
&nbsp;                                &quot;Overflow: numeric value (%s) out of range of Integer (%d - %d)&quot;,
<b class="nc">&nbsp;                                text, Integer.MIN_VALUE, Integer.MAX_VALUE));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return Integer.valueOf((int) l);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return Integer.valueOf(NumberInput.parseInt(text));</b>
<b class="fc">&nbsp;                } catch (IllegalArgumentException iae) {</b>
<b class="fc">&nbsp;                    return (Integer) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                            &quot;not a valid Integer value&quot;);
&nbsp;                }
&nbsp;            case JsonTokenId.ID_NULL:
<b class="fc">&nbsp;                return (Integer) _coerceNullToken(ctxt, _primitive);</b>
&nbsp;            case JsonTokenId.ID_START_ARRAY:
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
&nbsp;            // Otherwise, no can do:
<b class="fc">&nbsp;            return (Integer) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public final static class LongDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Long&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        final static LongDeserializer primitiveInstance = new LongDeserializer(Long.TYPE, 0L);</b>
<b class="fc">&nbsp;        final static LongDeserializer wrapperInstance = new LongDeserializer(Long.class, null);</b>
&nbsp;        
&nbsp;        public LongDeserializer(Class&lt;Long&gt; cls, Long nvl) {
<b class="fc">&nbsp;            super(cls, nvl, 0L);</b>
&nbsp;        }
&nbsp;
&nbsp;        // since 2.6, slightly faster lookups for this very common type
&nbsp;        @Override
<b class="fc">&nbsp;        public boolean isCachable() { return true; }</b>
&nbsp;        
&nbsp;        @Override
&nbsp;        public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
<b class="fc">&nbsp;            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {</b>
<b class="fc">&nbsp;                return p.getLongValue();</b>
&nbsp;            }
<b class="fc">&nbsp;            return _parseLong(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final Long _parseLong(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            // NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
<b class="nc">&nbsp;                return p.getLongValue();</b>
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:
<b class="fc">&nbsp;                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
<b class="fc">&nbsp;                    _failDoubleToIntCoercion(p, ctxt, &quot;Long&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return p.getValueAsLong();</b>
&nbsp;            case JsonTokenId.ID_STRING:
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
<b class="fc">&nbsp;                if (text.length() == 0) {</b>
<b class="fc">&nbsp;                    return (Long) _coerceEmptyString(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_hasTextualNull(text)) {</b>
<b class="nc">&nbsp;                    return (Long) _coerceTextualNull(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                // let&#39;s allow Strings to be converted too
&nbsp;                try {
<b class="fc">&nbsp;                    return Long.valueOf(NumberInput.parseLong(text));</b>
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) { }</b>
<b class="nc">&nbsp;                return (Long) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                        &quot;not a valid Long value&quot;);
&nbsp;                // fall-through
&nbsp;            case JsonTokenId.ID_NULL:
<b class="fc">&nbsp;                return (Long) _coerceNullToken(ctxt, _primitive);</b>
&nbsp;            case JsonTokenId.ID_START_ARRAY:
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
&nbsp;            // Otherwise, no can do:
<b class="nc">&nbsp;            return (Long) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public static class FloatDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Float&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.TYPE, 0.f);</b>
<b class="fc">&nbsp;        final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.class, null);</b>
&nbsp;        
&nbsp;        public FloatDeserializer(Class&lt;Float&gt; cls, Float nvl) {
<b class="fc">&nbsp;            super(cls, nvl, 0.f);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Float deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            return _parseFloat(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final Float _parseFloat(JsonParser p, DeserializationContext ctxt)
&nbsp;            throws IOException
&nbsp;        {
&nbsp;            // We accept couple of different types; obvious ones first:
<b class="fc">&nbsp;            JsonToken t = p.getCurrentToken();</b>
&nbsp;            
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NUMBER_FLOAT || t == JsonToken.VALUE_NUMBER_INT) { // coercing should work too</b>
<b class="fc">&nbsp;                return p.getFloatValue();</b>
&nbsp;            }
&nbsp;            // And finally, let&#39;s allow Strings to be converted too
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_STRING) {</b>
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
<b class="fc">&nbsp;                if ((text.length() == 0)) {</b>
<b class="fc">&nbsp;                    return (Float) _coerceEmptyString(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_hasTextualNull(text)) {</b>
<b class="nc">&nbsp;                    return (Float) _coerceTextualNull(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                switch (text.charAt(0)) {</b>
&nbsp;                case &#39;I&#39;:
<b class="fc">&nbsp;                    if (_isPosInf(text)) {</b>
<b class="fc">&nbsp;                        return Float.POSITIVE_INFINITY;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case &#39;N&#39;:
<b class="fc">&nbsp;                    if (_isNaN(text)) {</b>
<b class="fc">&nbsp;                        return Float.NaN;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case &#39;-&#39;:
<b class="fc">&nbsp;                    if (_isNegInf(text)) {</b>
<b class="nc">&nbsp;                        return Float.NEGATIVE_INFINITY;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return Float.parseFloat(text);</b>
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) { }</b>
<b class="nc">&nbsp;                return (Float) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                        &quot;not a valid Float value&quot;);
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NULL) {</b>
<b class="nc">&nbsp;                return (Float) _coerceNullToken(ctxt, _primitive);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.START_ARRAY) {</b>
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
&nbsp;            // Otherwise, no can do:
<b class="nc">&nbsp;            return (Float) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public static class DoubleDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Double&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.TYPE, 0.d);</b>
<b class="fc">&nbsp;        final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.class, null);</b>
&nbsp;        
&nbsp;        public DoubleDeserializer(Class&lt;Double&gt; cls, Double nvl) {
<b class="fc">&nbsp;            super(cls, nvl, 0.d);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Double deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
<b class="fc">&nbsp;            return _parseDouble(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Since we can never have type info (&quot;natural type&quot;; String, Boolean, Integer, Double):
&nbsp;        // (is it an error to even call this version?)
&nbsp;        @Override
&nbsp;        public Double deserializeWithType(JsonParser p, DeserializationContext ctxt,
&nbsp;                TypeDeserializer typeDeserializer) throws IOException
&nbsp;        {
<b class="nc">&nbsp;            return _parseDouble(p, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final Double _parseDouble(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            JsonToken t = p.getCurrentToken();</b>
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too</b>
<b class="fc">&nbsp;                return p.getDoubleValue();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_STRING) {</b>
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
<b class="fc">&nbsp;                if ((text.length() == 0)) {</b>
<b class="fc">&nbsp;                    return (Double) _coerceEmptyString(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_hasTextualNull(text)) {</b>
<b class="nc">&nbsp;                    return (Double) _coerceTextualNull(ctxt, _primitive);</b>
&nbsp;                }
<b class="fc">&nbsp;                switch (text.charAt(0)) {</b>
&nbsp;                case &#39;I&#39;:
<b class="fc">&nbsp;                    if (_isPosInf(text)) {</b>
<b class="fc">&nbsp;                        return Double.POSITIVE_INFINITY;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case &#39;N&#39;:
<b class="fc">&nbsp;                    if (_isNaN(text)) {</b>
<b class="fc">&nbsp;                        return Double.NaN;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case &#39;-&#39;:
<b class="fc">&nbsp;                    if (_isNegInf(text)) {</b>
<b class="fc">&nbsp;                        return Double.NEGATIVE_INFINITY;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return parseDouble(text);</b>
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) { }</b>
<b class="nc">&nbsp;                return (Double) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                        &quot;not a valid Double value&quot;);
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.VALUE_NULL) {</b>
<b class="fc">&nbsp;                return (Double) _coerceNullToken(ctxt, _primitive);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (t == JsonToken.START_ARRAY) {</b>
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
&nbsp;            // Otherwise, no can do:
<b class="nc">&nbsp;            return (Double) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For type &lt;code&gt;Number.class&lt;/code&gt;, we can just rely on type
&nbsp;     * mappings that plain {@link JsonParser#getNumberValue} returns.
&nbsp;     *&lt;p&gt;
&nbsp;     * There is one additional complication: some numeric
&nbsp;     * types (specifically, int/Integer and double/Double) are &quot;non-typed&quot;;
&nbsp;     * meaning that they will NEVER be output with type information.
&nbsp;     * But other numeric types may need such type information.
&nbsp;     * This is why {@link #deserializeWithType} must be overridden.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;serial&quot;)
&nbsp;    @JacksonStdImpl
&nbsp;    public static class NumberDeserializer
&nbsp;        extends StdScalarDeserializer&lt;Object&gt;
&nbsp;    {
<b class="fc">&nbsp;        public final static NumberDeserializer instance = new NumberDeserializer();</b>
&nbsp;        
&nbsp;        public NumberDeserializer() {
<b class="fc">&nbsp;            super(Number.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
<b class="fc">&nbsp;                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {</b>
<b class="fc">&nbsp;                    return _coerceIntegral(p, ctxt);</b>
&nbsp;                }
<b class="fc">&nbsp;                return p.getNumberValue();</b>
&nbsp;
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:
<b class="fc">&nbsp;                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {</b>
&nbsp;                    // 10-Mar-2017, tatu: NaN and BigDecimal won&#39;t mix...
<b class="fc">&nbsp;                    if (!p.isNaN()) {</b>
<b class="fc">&nbsp;                        return p.getDecimalValue();</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return p.getNumberValue();</b>
&nbsp;
&nbsp;            case JsonTokenId.ID_STRING:
&nbsp;                /* Textual values are more difficult... not parsing itself, but figuring
&nbsp;                 * out &#39;minimal&#39; type to use 
&nbsp;                 */
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
<b class="fc">&nbsp;                if ((text.length() == 0)) {</b>
&nbsp;                    // note: no need to call `coerce` as this is never primitive
<b class="nc">&nbsp;                    return getNullValue(ctxt);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_hasTextualNull(text)) {</b>
&nbsp;                    // note: no need to call `coerce` as this is never primitive
<b class="nc">&nbsp;                    return getNullValue(ctxt);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_isPosInf(text)) {</b>
<b class="nc">&nbsp;                    return Double.POSITIVE_INFINITY;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_isNegInf(text)) {</b>
<b class="nc">&nbsp;                    return Double.NEGATIVE_INFINITY;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (_isNaN(text)) {</b>
<b class="fc">&nbsp;                    return Double.NaN;</b>
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    if (!_isIntNumber(text)) {</b>
<b class="fc">&nbsp;                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {</b>
<b class="nc">&nbsp;                            return new BigDecimal(text);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return Double.valueOf(text);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {</b>
<b class="nc">&nbsp;                        return new BigInteger(text);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    long value = Long.parseLong(text);</b>
<b class="fc">&nbsp;                    if (!ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {</b>
<b class="fc">&nbsp;                        if (value &lt;= Integer.MAX_VALUE &amp;&amp; value &gt;= Integer.MIN_VALUE) {</b>
<b class="fc">&nbsp;                            return Integer.valueOf((int) value);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    return Long.valueOf(value);</b>
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) {</b>
<b class="nc">&nbsp;                    return ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                            &quot;not a valid number&quot;);
&nbsp;                }
&nbsp;            case JsonTokenId.ID_START_ARRAY:
<b class="nc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
&nbsp;            // Otherwise, no can do:
<b class="nc">&nbsp;            return ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * As mentioned in class Javadoc, there is additional complexity in
&nbsp;         * handling potentially mixed type information here. Because of this,
&nbsp;         * we must actually check for &quot;raw&quot; integers and doubles first, before
&nbsp;         * calling type deserializer.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
&nbsp;                TypeDeserializer typeDeserializer)
&nbsp;            throws IOException
&nbsp;        {
<b class="fc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:
&nbsp;            case JsonTokenId.ID_STRING:
&nbsp;                // can not point to type information: hence must be non-typed (int/double)
<b class="fc">&nbsp;                return deserialize(p, ctxt);</b>
&nbsp;            }
<b class="fc">&nbsp;            return typeDeserializer.deserializeTypedFromScalar(p, ctxt);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* And then bit more complicated (but non-structured) number
&nbsp;    /* types
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * This is bit trickier to implement efficiently, while avoiding
&nbsp;     * overflow problems.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;serial&quot;)
&nbsp;    @JacksonStdImpl
&nbsp;    public static class BigIntegerDeserializer
&nbsp;        extends StdScalarDeserializer&lt;BigInteger&gt;
&nbsp;    {
<b class="fc">&nbsp;        public final static BigIntegerDeserializer instance = new BigIntegerDeserializer();</b>
&nbsp;
<b class="fc">&nbsp;        public BigIntegerDeserializer() { super(BigInteger.class); }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Object getEmptyValue(DeserializationContext ctxt) {
<b class="nc">&nbsp;            return BigInteger.ZERO;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;incomplete-switch&quot;)
&nbsp;        @Override
&nbsp;        public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="fc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
<b class="fc">&nbsp;                switch (p.getNumberType()) {</b>
&nbsp;                case INT:
&nbsp;                case LONG:
&nbsp;                case BIG_INTEGER:
<b class="fc">&nbsp;                    return p.getBigIntegerValue();</b>
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:
<b class="nc">&nbsp;                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
<b class="nc">&nbsp;                    _failDoubleToIntCoercion(p, ctxt, &quot;java.math.BigInteger&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                return p.getDecimalValue().toBigInteger();</b>
&nbsp;            case JsonTokenId.ID_START_ARRAY:
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            case JsonTokenId.ID_STRING: // let&#39;s do implicit re-parse
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
&nbsp;                // note: no need to call `coerce` as this is never primitive
<b class="fc">&nbsp;                if (_isEmptyOrTextualNull(text)) {</b>
<b class="fc">&nbsp;                    _verifyNullForScalarCoercion(ctxt, text);</b>
<b class="fc">&nbsp;                    return getNullValue(ctxt);</b>
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new BigInteger(text);</b>
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) { }</b>
<b class="nc">&nbsp;                return (BigInteger) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                        &quot;not a valid representation&quot;);
&nbsp;            }
&nbsp;            // String is ok too, can easily convert; otherwise, no can do:
<b class="nc">&nbsp;            return (BigInteger) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    @SuppressWarnings(&quot;serial&quot;)
&nbsp;    @JacksonStdImpl
&nbsp;    public static class BigDecimalDeserializer
&nbsp;        extends StdScalarDeserializer&lt;BigDecimal&gt;
&nbsp;    {
<b class="fc">&nbsp;        public final static BigDecimalDeserializer instance = new BigDecimalDeserializer();</b>
&nbsp; 
<b class="fc">&nbsp;        public BigDecimalDeserializer() { super(BigDecimal.class); }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Object getEmptyValue(DeserializationContext ctxt) {
<b class="nc">&nbsp;            return BigDecimal.ZERO;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt)
&nbsp;            throws IOException
&nbsp;        {
<b class="fc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:
<b class="fc">&nbsp;                return p.getDecimalValue();</b>
&nbsp;            case JsonTokenId.ID_STRING:
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
&nbsp;                // note: no need to call `coerce` as this is never primitive
<b class="fc">&nbsp;                if (_isEmptyOrTextualNull(text)) {</b>
<b class="fc">&nbsp;                    _verifyNullForScalarCoercion(ctxt, text);</b>
<b class="fc">&nbsp;                    return getNullValue(ctxt);</b>
&nbsp;                }
<b class="fc">&nbsp;                _verifyStringForScalarCoercion(ctxt, text);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new BigDecimal(text);</b>
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) { }</b>
<b class="nc">&nbsp;                return (BigDecimal) ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                        &quot;not a valid representation&quot;);
&nbsp;            case JsonTokenId.ID_START_ARRAY:
<b class="fc">&nbsp;                return _deserializeFromArray(p, ctxt);</b>
&nbsp;            }
&nbsp;            // Otherwise, no can do:
<b class="nc">&nbsp;            return (BigDecimal) ctxt.handleUnexpectedToken(_valueClass, p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-02 21:37</div>
</div>
</body>
</html>
