


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CassandraStorage</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.cassandrareaper.storage</a>
</div>

<h1>Coverage Summary for Class: CassandraStorage (io.cassandrareaper.storage)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CassandraStorage</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/612)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CassandraStorage$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CassandraStorage$RetryPolicyImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/71)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/630)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package io.cassandrareaper.storage;
&nbsp;
&nbsp;import io.cassandrareaper.AppContext;
&nbsp;import io.cassandrareaper.ReaperApplicationConfiguration;
&nbsp;import io.cassandrareaper.core.Cluster;
&nbsp;import io.cassandrareaper.core.NodeMetrics;
&nbsp;import io.cassandrareaper.core.RepairRun;
&nbsp;import io.cassandrareaper.core.RepairRun.Builder;
&nbsp;import io.cassandrareaper.core.RepairRun.RunState;
&nbsp;import io.cassandrareaper.core.RepairSchedule;
&nbsp;import io.cassandrareaper.core.RepairSegment;
&nbsp;import io.cassandrareaper.core.RepairSegment.State;
&nbsp;import io.cassandrareaper.core.RepairUnit;
&nbsp;import io.cassandrareaper.resources.view.RepairRunStatus;
&nbsp;import io.cassandrareaper.resources.view.RepairScheduleStatus;
&nbsp;import io.cassandrareaper.service.RepairParameters;
&nbsp;import io.cassandrareaper.service.RingRange;
&nbsp;import io.cassandrareaper.storage.cassandra.DateTimeCodec;
&nbsp;import io.cassandrareaper.storage.cassandra.Migration003;
&nbsp;import io.cassandrareaper.storage.cassandra.Migration009;
&nbsp;
&nbsp;import java.math.BigInteger;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import com.datastax.driver.core.BatchStatement;
&nbsp;import com.datastax.driver.core.CodecRegistry;
&nbsp;import com.datastax.driver.core.ConsistencyLevel;
&nbsp;import com.datastax.driver.core.PoolingOptions;
&nbsp;import com.datastax.driver.core.PreparedStatement;
&nbsp;import com.datastax.driver.core.QueryLogger;
&nbsp;import com.datastax.driver.core.QueryOptions;
&nbsp;import com.datastax.driver.core.ResultSet;
&nbsp;import com.datastax.driver.core.ResultSetFuture;
&nbsp;import com.datastax.driver.core.Row;
&nbsp;import com.datastax.driver.core.Session;
&nbsp;import com.datastax.driver.core.SimpleStatement;
&nbsp;import com.datastax.driver.core.Statement;
&nbsp;import com.datastax.driver.core.WriteType;
&nbsp;import com.datastax.driver.core.exceptions.DriverException;
&nbsp;import com.datastax.driver.core.policies.DefaultRetryPolicy;
&nbsp;import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
&nbsp;import com.datastax.driver.core.policies.RetryPolicy;
&nbsp;import com.datastax.driver.core.utils.UUIDs;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import com.google.common.collect.Sets;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import io.dropwizard.setup.Environment;
&nbsp;import io.dropwizard.util.Duration;
&nbsp;import org.apache.cassandra.repair.RepairParallelism;
&nbsp;import org.cognitor.cassandra.migration.Database;
&nbsp;import org.cognitor.cassandra.migration.MigrationRepository;
&nbsp;import org.cognitor.cassandra.migration.MigrationTask;
&nbsp;import org.joda.time.DateTime;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;import systems.composable.dropwizard.cassandra.CassandraFactory;
&nbsp;import systems.composable.dropwizard.cassandra.pooling.PoolingOptionsFactory;
&nbsp;import systems.composable.dropwizard.cassandra.retry.RetryPolicyFactory;
&nbsp;
<b class="nc">&nbsp;public final class CassandraStorage implements IStorage, IDistributedStorage {</b>
&nbsp;
&nbsp;  /* Simple stmts */
&nbsp;  private static final String SELECT_CLUSTER = &quot;SELECT * FROM cluster&quot;;
&nbsp;  private static final String SELECT_REPAIR_SCHEDULE = &quot;SELECT * FROM repair_schedule_v1&quot;;
&nbsp;  private static final String SELECT_REPAIR_UNIT = &quot;SELECT * FROM repair_unit_v1&quot;;
&nbsp;  private static final String SELECT_LEADERS = &quot;SELECT * FROM leader&quot;;
&nbsp;
<b class="nc">&nbsp;  private static final Logger LOG = LoggerFactory.getLogger(CassandraStorage.class);</b>
&nbsp;
&nbsp;  private final com.datastax.driver.core.Cluster cassandra;
&nbsp;  private final Session session;
&nbsp;
&nbsp;
&nbsp;  /* prepared stmts */
&nbsp;  private PreparedStatement insertClusterPrepStmt;
&nbsp;  private PreparedStatement getClusterPrepStmt;
&nbsp;  private PreparedStatement deleteClusterPrepStmt;
&nbsp;  private PreparedStatement insertRepairRunPrepStmt;
&nbsp;  private PreparedStatement insertRepairRunClusterIndexPrepStmt;
&nbsp;  private PreparedStatement insertRepairRunUnitIndexPrepStmt;
&nbsp;  private PreparedStatement getRepairRunPrepStmt;
&nbsp;  private PreparedStatement getRepairRunForClusterPrepStmt;
&nbsp;  private PreparedStatement getRepairRunForUnitPrepStmt;
&nbsp;  private PreparedStatement deleteRepairRunPrepStmt;
&nbsp;  private PreparedStatement deleteRepairRunByClusterPrepStmt;
&nbsp;  private PreparedStatement deleteRepairRunByUnitPrepStmt;
&nbsp;  private PreparedStatement insertRepairUnitPrepStmt;
&nbsp;  private PreparedStatement getRepairUnitPrepStmt;
&nbsp;  private PreparedStatement insertRepairSegmentPrepStmt;
&nbsp;  private PreparedStatement insertRepairSegmentIncrementalPrepStmt;
&nbsp;  private PreparedStatement updateRepairSegmentPrepStmt;
&nbsp;  private PreparedStatement insertRepairSegmentEndTimePrepStmt;
&nbsp;  private PreparedStatement getRepairSegmentPrepStmt;
&nbsp;  private PreparedStatement getRepairSegmentsByRunIdPrepStmt;
&nbsp;  private PreparedStatement insertRepairSchedulePrepStmt;
&nbsp;  private PreparedStatement getRepairSchedulePrepStmt;
&nbsp;  private PreparedStatement getRepairScheduleByClusterAndKsPrepStmt;
&nbsp;  private PreparedStatement insertRepairScheduleByClusterAndKsPrepStmt;
&nbsp;  private PreparedStatement deleteRepairSchedulePrepStmt;
&nbsp;  private PreparedStatement deleteRepairScheduleByClusterAndKsPrepStmt;
&nbsp;  private PreparedStatement takeLeadPrepStmt;
&nbsp;  private PreparedStatement renewLeadPrepStmt;
&nbsp;  private PreparedStatement releaseLeadPrepStmt;
&nbsp;  private PreparedStatement getRunningReapersCountPrepStmt;
&nbsp;  private PreparedStatement saveHeartbeatPrepStmt;
&nbsp;  private PreparedStatement storeNodeMetricsPrepStmt;
&nbsp;  private PreparedStatement getNodeMetricsPrepStmt;
&nbsp;  private PreparedStatement getNodeMetricsByNodePrepStmt;
&nbsp;
<b class="nc">&nbsp;  public CassandraStorage(ReaperApplicationConfiguration config, Environment environment) {</b>
<b class="nc">&nbsp;    CassandraFactory cassandraFactory = config.getCassandraFactory();</b>
<b class="nc">&nbsp;    overrideQueryOptions(cassandraFactory);</b>
<b class="nc">&nbsp;    overrideRetryPolicy(cassandraFactory);</b>
<b class="nc">&nbsp;    overridePoolingOptions(cassandraFactory);</b>
<b class="nc">&nbsp;    cassandra = cassandraFactory.build(environment);</b>
<b class="nc">&nbsp;    if (config.getActivateQueryLogger()) {</b>
<b class="nc">&nbsp;      cassandra.register(QueryLogger.builder().build());</b>
&nbsp;    }
<b class="nc">&nbsp;    CodecRegistry codecRegistry = cassandra.getConfiguration().getCodecRegistry();</b>
<b class="nc">&nbsp;    codecRegistry.register(new DateTimeCodec());</b>
<b class="nc">&nbsp;    session = cassandra.connect(config.getCassandraFactory().getKeyspace());</b>
&nbsp;
<b class="nc">&nbsp;    initializeAndUpgradeSchema(cassandra, session, config.getCassandraFactory().getKeyspace());</b>
<b class="nc">&nbsp;    prepareStatements();</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void initializeAndUpgradeSchema(
&nbsp;      com.datastax.driver.core.Cluster cassandra,
&nbsp;      Session session,
&nbsp;      String keyspace) {
&nbsp;
&nbsp;    // initialize/upgrade db schema
<b class="nc">&nbsp;    Database database = new Database(cassandra, keyspace);</b>
<b class="nc">&nbsp;    if (database.getVersion() &gt; 3 &amp;&amp; database.getVersion() &lt; 9) {</b>
&nbsp;      // only applicable after `003_switch_to_uuids.cql`
&nbsp;      // Migration009 needs to happen before `migration.migrate()` in case it fails and needs re-trying
<b class="nc">&nbsp;      Migration009.migrate(session);</b>
&nbsp;    }
<b class="nc">&nbsp;    MigrationTask migration = new MigrationTask(database, new MigrationRepository(&quot;db/cassandra&quot;));</b>
<b class="nc">&nbsp;    migration.migrate();</b>
<b class="nc">&nbsp;    Migration003.migrate(session);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void prepareStatements() {
<b class="nc">&nbsp;    insertClusterPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(&quot;INSERT INTO cluster(name, partitioner, seed_hosts) values(?, ?, ?)&quot;)</b>
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.QUORUM);</b>
<b class="nc">&nbsp;    getClusterPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(&quot;SELECT * FROM cluster WHERE name = ?&quot;)</b>
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.QUORUM)</b>
<b class="nc">&nbsp;        .setRetryPolicy(DowngradingConsistencyRetryPolicy.INSTANCE);</b>
<b class="nc">&nbsp;    deleteClusterPrepStmt = session.prepare(&quot;DELETE FROM cluster WHERE name = ?&quot;);</b>
<b class="nc">&nbsp;    insertRepairRunPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;INSERT INTO repair_run(id, cluster_name, repair_unit_id, cause, owner, state, creation_time, &quot;</b>
&nbsp;                + &quot;start_time, end_time, pause_time, intensity, last_event, segment_count, repair_parallelism) &quot;
&nbsp;                + &quot;VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;)
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.QUORUM);</b>
<b class="nc">&nbsp;    insertRepairRunClusterIndexPrepStmt</b>
<b class="nc">&nbsp;        = session.prepare(&quot;INSERT INTO repair_run_by_cluster(cluster_name, id) values(?, ?)&quot;);</b>
<b class="nc">&nbsp;    insertRepairRunUnitIndexPrepStmt</b>
<b class="nc">&nbsp;        = session.prepare(&quot;INSERT INTO repair_run_by_unit(repair_unit_id, id) values(?, ?)&quot;);</b>
<b class="nc">&nbsp;    getRepairRunPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;SELECT id,cluster_name,repair_unit_id,cause,owner,state,creation_time,start_time,end_time,&quot;</b>
&nbsp;                + &quot;pause_time,intensity,last_event,segment_count,repair_parallelism &quot;
&nbsp;                + &quot;FROM repair_run WHERE id = ? LIMIT 1&quot;)
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.QUORUM);</b>
<b class="nc">&nbsp;    getRepairRunForClusterPrepStmt = session.prepare(&quot;SELECT * FROM repair_run_by_cluster WHERE cluster_name = ?&quot;);</b>
<b class="nc">&nbsp;    getRepairRunForUnitPrepStmt = session.prepare(&quot;SELECT * FROM repair_run_by_unit WHERE repair_unit_id = ?&quot;);</b>
<b class="nc">&nbsp;    deleteRepairRunPrepStmt = session.prepare(&quot;DELETE FROM repair_run WHERE id = ?&quot;);</b>
<b class="nc">&nbsp;    deleteRepairRunByClusterPrepStmt</b>
<b class="nc">&nbsp;        = session.prepare(&quot;DELETE FROM repair_run_by_cluster WHERE id = ? and cluster_name = ?&quot;);</b>
<b class="nc">&nbsp;    deleteRepairRunByUnitPrepStmt = session.prepare(&quot;DELETE FROM repair_run_by_unit &quot;</b>
&nbsp;        + &quot;WHERE id = ? and repair_unit_id= ?&quot;);
<b class="nc">&nbsp;    insertRepairUnitPrepStmt =</b>
<b class="nc">&nbsp;        session.prepare(</b>
<b class="nc">&nbsp;            &quot;INSERT INTO repair_unit_v1(id, cluster_name, keyspace_name, column_families, &quot;</b>
&nbsp;                + &quot;incremental_repair, nodes, datacenters, blacklisted_tables) VALUES(?, ?, ?, ?, ?, ?, ?, ?)&quot;);
<b class="nc">&nbsp;    getRepairUnitPrepStmt = session.prepare(&quot;SELECT * FROM repair_unit_v1 WHERE id = ?&quot;);</b>
<b class="nc">&nbsp;    insertRepairSegmentPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;INSERT INTO repair_run&quot;</b>
&nbsp;                + &quot;(id,segment_id,repair_unit_id,start_token,end_token,segment_state,fail_count)&quot;
&nbsp;                + &quot; VALUES(?, ?, ?, ?, ?, ?, ?)&quot;)
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM);</b>
<b class="nc">&nbsp;    insertRepairSegmentIncrementalPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;INSERT INTO repair_run&quot;</b>
&nbsp;                + &quot;(id,segment_id,repair_unit_id,start_token,end_token,segment_state,coordinator_host,fail_count)&quot;
&nbsp;                + &quot; VALUES(?, ?, ?, ?, ?, ?, ?, ?)&quot;)
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM);</b>
<b class="nc">&nbsp;    updateRepairSegmentPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;INSERT INTO repair_run&quot;</b>
&nbsp;                + &quot;(id,segment_id,segment_state,coordinator_host,segment_start_time,fail_count)&quot;
&nbsp;                + &quot; VALUES(?, ?, ?, ?, ?, ?)&quot;)
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM);</b>
<b class="nc">&nbsp;    insertRepairSegmentEndTimePrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(&quot;INSERT INTO repair_run(id, segment_id, segment_end_time) VALUES(?, ?, ?)&quot;)</b>
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM);</b>
<b class="nc">&nbsp;    getRepairSegmentPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;SELECT id,repair_unit_id,segment_id,start_token,end_token,segment_state,coordinator_host,&quot;</b>
&nbsp;                + &quot;segment_start_time,segment_end_time,fail_count FROM repair_run WHERE id = ? and segment_id = ?&quot;)
<b class="nc">&nbsp;        .setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM);</b>
<b class="nc">&nbsp;    getRepairSegmentsByRunIdPrepStmt = session.prepare(</b>
<b class="nc">&nbsp;        &quot;SELECT id,repair_unit_id,segment_id,start_token,end_token,segment_state,coordinator_host,segment_start_time,&quot;</b>
&nbsp;            + &quot;segment_end_time,fail_count FROM repair_run WHERE id = ?&quot;);
<b class="nc">&nbsp;    insertRepairSchedulePrepStmt =</b>
<b class="nc">&nbsp;        session</b>
<b class="nc">&nbsp;            .prepare(</b>
<b class="nc">&nbsp;                &quot;INSERT INTO repair_schedule_v1(id, repair_unit_id, state, days_between, next_activation, run_history, &quot;</b>
&nbsp;                    + &quot;segment_count, repair_parallelism, intensity, &quot;
&nbsp;                    + &quot;creation_time, owner, pause_time, segment_count_per_node) &quot;
&nbsp;                    + &quot;VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;)
<b class="nc">&nbsp;            .setConsistencyLevel(ConsistencyLevel.QUORUM);</b>
<b class="nc">&nbsp;    getRepairSchedulePrepStmt</b>
<b class="nc">&nbsp;        = session.prepare(&quot;SELECT * FROM repair_schedule_v1 WHERE id = ?&quot;).setConsistencyLevel(ConsistencyLevel.QUORUM);</b>
<b class="nc">&nbsp;    insertRepairScheduleByClusterAndKsPrepStmt = session.prepare(</b>
<b class="nc">&nbsp;        &quot;INSERT INTO repair_schedule_by_cluster_and_keyspace(cluster_name, keyspace_name, repair_schedule_id)&quot;</b>
&nbsp;            + &quot; VALUES(?, ?, ?)&quot;);
<b class="nc">&nbsp;    getRepairScheduleByClusterAndKsPrepStmt = session.prepare(</b>
<b class="nc">&nbsp;        &quot;SELECT repair_schedule_id FROM repair_schedule_by_cluster_and_keyspace &quot;</b>
&nbsp;            + &quot;WHERE cluster_name = ? and keyspace_name = ?&quot;);
<b class="nc">&nbsp;    deleteRepairSchedulePrepStmt = session.prepare(&quot;DELETE FROM repair_schedule_v1 WHERE id = ?&quot;);</b>
<b class="nc">&nbsp;    deleteRepairScheduleByClusterAndKsPrepStmt = session.prepare(</b>
<b class="nc">&nbsp;        &quot;DELETE FROM repair_schedule_by_cluster_and_keyspace &quot;</b>
&nbsp;            + &quot;WHERE cluster_name = ? and keyspace_name = ? and repair_schedule_id = ?&quot;);
<b class="nc">&nbsp;    takeLeadPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;INSERT INTO leader(leader_id, reaper_instance_id, reaper_instance_host, last_heartbeat) &quot;</b>
&nbsp;                + &quot;VALUES(?, ?, ?, dateof(now())) IF NOT EXISTS&quot;)
<b class="nc">&nbsp;        .setIdempotent(false);</b>
<b class="nc">&nbsp;    renewLeadPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;UPDATE leader SET reaper_instance_id = ?, reaper_instance_host = ?, last_heartbeat = dateof(now()) &quot;</b>
&nbsp;                + &quot;WHERE leader_id = ? IF reaper_instance_id = ?&quot;)
<b class="nc">&nbsp;        .setIdempotent(false);</b>
<b class="nc">&nbsp;    releaseLeadPrepStmt = session.prepare(&quot;DELETE FROM leader WHERE leader_id = ? IF reaper_instance_id = ?&quot;);</b>
<b class="nc">&nbsp;    getRunningReapersCountPrepStmt = session.prepare(&quot;SELECT count(*) as nb_reapers FROM running_reapers&quot;);</b>
<b class="nc">&nbsp;    saveHeartbeatPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;INSERT INTO running_reapers(reaper_instance_id, reaper_instance_host, last_heartbeat)&quot;</b>
&nbsp;                + &quot; VALUES(?,?,dateof(now()))&quot;)
<b class="nc">&nbsp;        .setIdempotent(false);</b>
<b class="nc">&nbsp;    storeNodeMetricsPrepStmt = session</b>
<b class="nc">&nbsp;        .prepare(</b>
<b class="nc">&nbsp;            &quot;INSERT INTO node_metrics_v1 (time_partition,run_id,node,datacenter,cluster,requested,pending_compactions,&quot;</b>
&nbsp;                + &quot;has_repair_running,active_anticompactions) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;)
<b class="nc">&nbsp;        .setIdempotent(false);</b>
<b class="nc">&nbsp;    getNodeMetricsPrepStmt = session.prepare(&quot;SELECT * FROM node_metrics_v1&quot;</b>
&nbsp;        + &quot; WHERE time_partition = ? AND run_id = ?&quot;);
<b class="nc">&nbsp;    getNodeMetricsByNodePrepStmt = session.prepare(&quot;SELECT * FROM node_metrics_v1&quot;</b>
&nbsp;        + &quot; WHERE time_partition = ? AND run_id = ? AND node = ?&quot;);
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean isStorageConnected() {
<b class="nc">&nbsp;    return session != null &amp;&amp; !session.isClosed();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;Cluster&gt; getClusters() {
<b class="nc">&nbsp;    Collection&lt;Cluster&gt; clusters = Lists.&lt;Cluster&gt;newArrayList();</b>
<b class="nc">&nbsp;    Statement stmt = new SimpleStatement(SELECT_CLUSTER);</b>
<b class="nc">&nbsp;    stmt.setIdempotent(Boolean.TRUE);</b>
<b class="nc">&nbsp;    ResultSet clusterResults = session.execute(stmt);</b>
<b class="nc">&nbsp;    for (Row cluster : clusterResults) {</b>
<b class="nc">&nbsp;      clusters.add(</b>
<b class="nc">&nbsp;          new Cluster(</b>
<b class="nc">&nbsp;              cluster.getString(&quot;name&quot;), cluster.getString(&quot;partitioner&quot;), cluster.getSet(&quot;seed_hosts&quot;, String.class)));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return clusters;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean addCluster(Cluster cluster) {
<b class="nc">&nbsp;    session.execute(insertClusterPrepStmt.bind(cluster.getName(), cluster.getPartitioner(), cluster.getSeedHosts()));</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean updateCluster(Cluster newCluster) {
<b class="nc">&nbsp;    return addCluster(newCluster);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;Cluster&gt; getCluster(String clusterName) {
<b class="nc">&nbsp;    Row row = session.execute(getClusterPrepStmt.bind(clusterName)).one();</b>
&nbsp;
<b class="nc">&nbsp;    return row != null</b>
<b class="nc">&nbsp;        ? Optional.fromNullable(</b>
<b class="nc">&nbsp;            new Cluster(row.getString(&quot;name&quot;), row.getString(&quot;partitioner&quot;), row.getSet(&quot;seed_hosts&quot;, String.class)))</b>
<b class="nc">&nbsp;        : Optional.absent();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;Cluster&gt; deleteCluster(String clusterName) {
<b class="nc">&nbsp;    session.executeAsync(deleteClusterPrepStmt.bind(clusterName));</b>
<b class="nc">&nbsp;    return Optional.fromNullable(new Cluster(clusterName, null, null));</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public RepairRun addRepairRun(Builder repairRun, Collection&lt;RepairSegment.Builder&gt; newSegments) {
<b class="nc">&nbsp;    RepairRun newRepairRun = repairRun.build(UUIDs.timeBased());</b>
<b class="nc">&nbsp;    BatchStatement repairRunBatch = new BatchStatement(BatchStatement.Type.UNLOGGED);</b>
<b class="nc">&nbsp;    List&lt;ResultSetFuture&gt; futures = Lists.newArrayList();</b>
<b class="nc">&nbsp;    Boolean isIncremental = null;</b>
&nbsp;
<b class="nc">&nbsp;    repairRunBatch.add(</b>
<b class="nc">&nbsp;        insertRepairRunPrepStmt.bind(</b>
<b class="nc">&nbsp;            newRepairRun.getId(),</b>
<b class="nc">&nbsp;            newRepairRun.getClusterName(),</b>
<b class="nc">&nbsp;            newRepairRun.getRepairUnitId(),</b>
<b class="nc">&nbsp;            newRepairRun.getCause(),</b>
<b class="nc">&nbsp;            newRepairRun.getOwner(),</b>
<b class="nc">&nbsp;            newRepairRun.getRunState().toString(),</b>
<b class="nc">&nbsp;            newRepairRun.getCreationTime(),</b>
<b class="nc">&nbsp;            newRepairRun.getStartTime(),</b>
<b class="nc">&nbsp;            newRepairRun.getEndTime(),</b>
<b class="nc">&nbsp;            newRepairRun.getPauseTime(),</b>
<b class="nc">&nbsp;            newRepairRun.getIntensity(),</b>
<b class="nc">&nbsp;            newRepairRun.getLastEvent(),</b>
<b class="nc">&nbsp;            newRepairRun.getSegmentCount(),</b>
<b class="nc">&nbsp;            newRepairRun.getRepairParallelism().toString()));</b>
&nbsp;
<b class="nc">&nbsp;    for (RepairSegment.Builder builder : newSegments) {</b>
<b class="nc">&nbsp;      RepairSegment segment = builder.withRunId(newRepairRun.getId()).build(UUIDs.timeBased());</b>
<b class="nc">&nbsp;      isIncremental = null == isIncremental ? null != segment.getCoordinatorHost() : isIncremental;</b>
&nbsp;
<b class="nc">&nbsp;      assert RepairSegment.State.NOT_STARTED == segment.getState();</b>
<b class="nc">&nbsp;      assert null == segment.getStartTime();</b>
<b class="nc">&nbsp;      assert null == segment.getEndTime();</b>
<b class="nc">&nbsp;      assert 0 == segment.getFailCount();</b>
<b class="nc">&nbsp;      assert (null != segment.getCoordinatorHost()) == isIncremental;</b>
&nbsp;
<b class="nc">&nbsp;      if (isIncremental) {</b>
&nbsp;
<b class="nc">&nbsp;        repairRunBatch.add(</b>
<b class="nc">&nbsp;            insertRepairSegmentIncrementalPrepStmt.bind(</b>
<b class="nc">&nbsp;              segment.getRunId(),</b>
<b class="nc">&nbsp;              segment.getId(),</b>
<b class="nc">&nbsp;              segment.getRepairUnitId(),</b>
<b class="nc">&nbsp;              segment.getStartToken(),</b>
<b class="nc">&nbsp;              segment.getEndToken(),</b>
<b class="nc">&nbsp;              segment.getState().ordinal(),</b>
<b class="nc">&nbsp;              segment.getCoordinatorHost(),</b>
<b class="nc">&nbsp;              segment.getFailCount()));</b>
<b class="nc">&nbsp;      } else {</b>
&nbsp;
<b class="nc">&nbsp;        repairRunBatch.add(</b>
<b class="nc">&nbsp;            insertRepairSegmentPrepStmt.bind(</b>
<b class="nc">&nbsp;              segment.getRunId(),</b>
<b class="nc">&nbsp;              segment.getId(),</b>
<b class="nc">&nbsp;              segment.getRepairUnitId(),</b>
<b class="nc">&nbsp;              segment.getStartToken(),</b>
<b class="nc">&nbsp;              segment.getEndToken(),</b>
<b class="nc">&nbsp;              segment.getState().ordinal(),</b>
<b class="nc">&nbsp;              segment.getFailCount()));</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (100 &lt;= repairRunBatch.size()) {</b>
<b class="nc">&nbsp;        futures.add(session.executeAsync(repairRunBatch));</b>
<b class="nc">&nbsp;        repairRunBatch = new BatchStatement(BatchStatement.Type.UNLOGGED);</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    assert getRepairUnit(newRepairRun.getRepairUnitId()).get().getIncrementalRepair() == isIncremental.booleanValue();</b>
&nbsp;
<b class="nc">&nbsp;    futures.add(session.executeAsync(repairRunBatch));</b>
<b class="nc">&nbsp;    futures.add(</b>
<b class="nc">&nbsp;        session.executeAsync(</b>
<b class="nc">&nbsp;            insertRepairRunClusterIndexPrepStmt.bind(newRepairRun.getClusterName(), newRepairRun.getId())));</b>
<b class="nc">&nbsp;    futures.add(</b>
<b class="nc">&nbsp;        session.executeAsync(</b>
<b class="nc">&nbsp;            insertRepairRunUnitIndexPrepStmt.bind(newRepairRun.getRepairUnitId(), newRepairRun.getId())));</b>
&nbsp;
&nbsp;    try {
<b class="nc">&nbsp;      Futures.allAsList(futures).get();</b>
<b class="nc">&nbsp;    } catch (InterruptedException | ExecutionException ex) {</b>
<b class="nc">&nbsp;      LOG.error(&quot;failed to quorum insert new repair run &quot; + newRepairRun.getId(), ex);</b>
&nbsp;    }
<b class="nc">&nbsp;    return newRepairRun;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean updateRepairRun(RepairRun repairRun) {
<b class="nc">&nbsp;    session.execute(</b>
<b class="nc">&nbsp;          insertRepairRunPrepStmt.bind(</b>
<b class="nc">&nbsp;              repairRun.getId(),</b>
<b class="nc">&nbsp;              repairRun.getClusterName(),</b>
<b class="nc">&nbsp;              repairRun.getRepairUnitId(),</b>
<b class="nc">&nbsp;              repairRun.getCause(),</b>
<b class="nc">&nbsp;              repairRun.getOwner(),</b>
<b class="nc">&nbsp;              repairRun.getRunState().toString(),</b>
<b class="nc">&nbsp;              repairRun.getCreationTime(),</b>
<b class="nc">&nbsp;              repairRun.getStartTime(),</b>
<b class="nc">&nbsp;              repairRun.getEndTime(),</b>
<b class="nc">&nbsp;              repairRun.getPauseTime(),</b>
<b class="nc">&nbsp;              repairRun.getIntensity(),</b>
<b class="nc">&nbsp;              repairRun.getLastEvent(),</b>
<b class="nc">&nbsp;              repairRun.getSegmentCount(),</b>
<b class="nc">&nbsp;            repairRun.getRepairParallelism().toString()));</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;RepairRun&gt; getRepairRun(UUID id) {
<b class="nc">&nbsp;    RepairRun repairRun = null;</b>
<b class="nc">&nbsp;    Row repairRunResult = session.execute(getRepairRunPrepStmt.bind(id)).one();</b>
<b class="nc">&nbsp;    if (repairRunResult != null) {</b>
&nbsp;      try {
<b class="nc">&nbsp;        repairRun = buildRepairRunFromRow(repairRunResult, id);</b>
<b class="nc">&nbsp;      } catch (RuntimeException ignore) {</b>
&nbsp;        // has been since deleted, but zombie segments has been re-inserted
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return Optional.fromNullable(repairRun);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairRun&gt; getRepairRunsForCluster(String clusterName) {
<b class="nc">&nbsp;    List&lt;ResultSetFuture&gt; repairRunFutures = Lists.&lt;ResultSetFuture&gt;newArrayList();</b>
&nbsp;
&nbsp;    // Grab all ids for the given cluster name
<b class="nc">&nbsp;    Collection&lt;UUID&gt; repairRunIds = getRepairRunIdsForCluster(clusterName);</b>
&nbsp;    // Grab repair runs asynchronously for all the ids returned by the index table
<b class="nc">&nbsp;    for (UUID repairRunId : repairRunIds) {</b>
<b class="nc">&nbsp;      repairRunFutures.add(session.executeAsync(getRepairRunPrepStmt.bind(repairRunId)));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return getRepairRunsAsync(repairRunFutures);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairRun&gt; getRepairRunsForUnit(UUID repairUnitId) {
<b class="nc">&nbsp;    List&lt;ResultSetFuture&gt; repairRunFutures = Lists.&lt;ResultSetFuture&gt;newArrayList();</b>
&nbsp;
&nbsp;    // Grab all ids for the given cluster name
<b class="nc">&nbsp;    ResultSet repairRunIds = session.execute(getRepairRunForUnitPrepStmt.bind(repairUnitId));</b>
&nbsp;
&nbsp;    // Grab repair runs asynchronously for all the ids returned by the index table
<b class="nc">&nbsp;    for (Row repairRunId : repairRunIds) {</b>
<b class="nc">&nbsp;      repairRunFutures.add(session.executeAsync(getRepairRunPrepStmt.bind(repairRunId.getUUID(&quot;id&quot;))));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return getRepairRunsAsync(repairRunFutures);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Create a collection of RepairRun objects out of a list of ResultSetFuture. Used to handle async queries on the
&nbsp;   * repair_run table with a list of ids.
&nbsp;   */
&nbsp;  private Collection&lt;RepairRun&gt; getRepairRunsAsync(List&lt;ResultSetFuture&gt; repairRunFutures) {
<b class="nc">&nbsp;    Collection&lt;RepairRun&gt; repairRuns = Lists.&lt;RepairRun&gt;newArrayList();</b>
&nbsp;
<b class="nc">&nbsp;    for (ResultSetFuture repairRunFuture : repairRunFutures) {</b>
<b class="nc">&nbsp;      Row repairRunResult = repairRunFuture.getUninterruptibly().one();</b>
<b class="nc">&nbsp;      if (repairRunResult != null) {</b>
<b class="nc">&nbsp;        RepairRun repairRun = buildRepairRunFromRow(repairRunResult, repairRunResult.getUUID(&quot;id&quot;));</b>
<b class="nc">&nbsp;        repairRuns.add(repairRun);</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return repairRuns;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairRun&gt; getRepairRunsWithState(RunState runState) {
<b class="nc">&nbsp;    Set&lt;RepairRun&gt; repairRunsWithState = Sets.newHashSet();</b>
&nbsp;
<b class="nc">&nbsp;    List&lt;Collection&lt;UUID&gt;&gt; repairRunIds = getClusters()</b>
<b class="nc">&nbsp;        .stream()</b>
&nbsp;        // Grab all ids for the given cluster name
<b class="nc">&nbsp;        .map(cluster -&gt; getRepairRunIdsForCluster(cluster.getName()))</b>
<b class="nc">&nbsp;        .collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;    for (Collection&lt;UUID&gt; clusterRepairRunIds : repairRunIds) {</b>
<b class="nc">&nbsp;      repairRunsWithState.addAll(getRepairRunsWithStateForCluster(clusterRepairRunIds, runState));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return repairRunsWithState;</b>
&nbsp;  }
&nbsp;
&nbsp;  private Collection&lt;? extends RepairRun&gt; getRepairRunsWithStateForCluster(
&nbsp;      Collection&lt;UUID&gt; clusterRepairRunsId,
&nbsp;      RunState runState) {
&nbsp;
<b class="nc">&nbsp;    Collection&lt;RepairRun&gt; repairRuns = Sets.newHashSet();</b>
<b class="nc">&nbsp;    List&lt;ResultSetFuture&gt; futures = Lists.newArrayList();</b>
&nbsp;
<b class="nc">&nbsp;    for (UUID repairRunId : clusterRepairRunsId) {</b>
<b class="nc">&nbsp;      futures.add(session.executeAsync(getRepairRunPrepStmt.bind(repairRunId)));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    for (ResultSetFuture future : futures) {</b>
<b class="nc">&nbsp;      ResultSet repairRunResult = future.getUninterruptibly();</b>
<b class="nc">&nbsp;      for (Row row : repairRunResult) {</b>
<b class="nc">&nbsp;        repairRuns.add(buildRepairRunFromRow(row, row.getUUID(&quot;id&quot;)));</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return repairRuns.stream().filter(repairRun -&gt; repairRun.getRunState() == runState).collect(Collectors.toSet());</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;RepairRun&gt; deleteRepairRun(UUID id) {
<b class="nc">&nbsp;    Optional&lt;RepairRun&gt; repairRun = getRepairRun(id);</b>
<b class="nc">&nbsp;    if (repairRun.isPresent()) {</b>
<b class="nc">&nbsp;      session.executeAsync(deleteRepairRunByUnitPrepStmt.bind(id, repairRun.get().getRepairUnitId()));</b>
<b class="nc">&nbsp;      session.executeAsync(deleteRepairRunByClusterPrepStmt.bind(id, repairRun.get().getClusterName()));</b>
&nbsp;    }
<b class="nc">&nbsp;    session.executeAsync(deleteRepairRunPrepStmt.bind(id));</b>
<b class="nc">&nbsp;    return repairRun;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public RepairUnit addRepairUnit(RepairUnit.Builder newRepairUnit) {
<b class="nc">&nbsp;    RepairUnit repairUnit = newRepairUnit.build(UUIDs.timeBased());</b>
<b class="nc">&nbsp;    session.execute(</b>
<b class="nc">&nbsp;        insertRepairUnitPrepStmt.bind(</b>
<b class="nc">&nbsp;            repairUnit.getId(),</b>
<b class="nc">&nbsp;            repairUnit.getClusterName(),</b>
<b class="nc">&nbsp;            repairUnit.getKeyspaceName(),</b>
<b class="nc">&nbsp;            repairUnit.getColumnFamilies(),</b>
<b class="nc">&nbsp;            repairUnit.getIncrementalRepair(),</b>
<b class="nc">&nbsp;            repairUnit.getNodes(),</b>
<b class="nc">&nbsp;            repairUnit.getDatacenters(),</b>
<b class="nc">&nbsp;            repairUnit.getBlacklistedTables()));</b>
<b class="nc">&nbsp;    return repairUnit;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;RepairUnit&gt; getRepairUnit(UUID id) {
<b class="nc">&nbsp;    RepairUnit repairUnit = null;</b>
<b class="nc">&nbsp;    Row repairUnitRow = session.execute(getRepairUnitPrepStmt.bind(id)).one();</b>
<b class="nc">&nbsp;    if (repairUnitRow != null) {</b>
<b class="nc">&nbsp;      repairUnit =</b>
<b class="nc">&nbsp;          new RepairUnit.Builder(</b>
<b class="nc">&nbsp;                  repairUnitRow.getString(&quot;cluster_name&quot;),</b>
<b class="nc">&nbsp;                  repairUnitRow.getString(&quot;keyspace_name&quot;),</b>
<b class="nc">&nbsp;                  repairUnitRow.getSet(&quot;column_families&quot;, String.class),</b>
<b class="nc">&nbsp;                  repairUnitRow.getBool(&quot;incremental_repair&quot;),</b>
<b class="nc">&nbsp;                  repairUnitRow.getSet(&quot;nodes&quot;, String.class),</b>
<b class="nc">&nbsp;                  repairUnitRow.getSet(&quot;datacenters&quot;, String.class),</b>
<b class="nc">&nbsp;                  repairUnitRow.getSet(&quot;blacklisted_tables&quot;, String.class))</b>
<b class="nc">&nbsp;              .build(id);</b>
&nbsp;    }
<b class="nc">&nbsp;    return Optional.fromNullable(repairUnit);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;RepairUnit&gt; getRepairUnit(
&nbsp;      String cluster,
&nbsp;      String keyspace,
&nbsp;      Set&lt;String&gt; columnFamilyNames,
&nbsp;      Set&lt;String&gt; nodes,
&nbsp;      Set&lt;String&gt; datacenters,
&nbsp;      Set&lt;String&gt; blacklistedTables) {
&nbsp;    // brute force again
<b class="nc">&nbsp;    RepairUnit repairUnit = null;</b>
<b class="nc">&nbsp;    Statement stmt = new SimpleStatement(SELECT_REPAIR_UNIT);</b>
<b class="nc">&nbsp;    stmt.setIdempotent(Boolean.TRUE);</b>
<b class="nc">&nbsp;    ResultSet results = session.execute(stmt);</b>
<b class="nc">&nbsp;    for (Row repairUnitRow : results) {</b>
<b class="nc">&nbsp;      if (repairUnitRow.getString(&quot;cluster_name&quot;).equals(cluster)</b>
<b class="nc">&nbsp;          &amp;&amp; repairUnitRow.getString(&quot;keyspace_name&quot;).equals(keyspace)</b>
<b class="nc">&nbsp;          &amp;&amp; repairUnitRow.getSet(&quot;column_families&quot;, String.class).equals(columnFamilyNames)</b>
<b class="nc">&nbsp;          &amp;&amp; repairUnitRow.getSet(&quot;nodes&quot;, String.class).equals(nodes)</b>
<b class="nc">&nbsp;          &amp;&amp; repairUnitRow.getSet(&quot;datacenters&quot;, String.class).equals(datacenters)</b>
<b class="nc">&nbsp;          &amp;&amp; repairUnitRow.getSet(&quot;blacklisted_tables&quot;, String.class).equals(blacklistedTables)) {</b>
<b class="nc">&nbsp;        repairUnit =</b>
<b class="nc">&nbsp;            new RepairUnit.Builder(</b>
<b class="nc">&nbsp;                    repairUnitRow.getString(&quot;cluster_name&quot;),</b>
<b class="nc">&nbsp;                    repairUnitRow.getString(&quot;keyspace_name&quot;),</b>
<b class="nc">&nbsp;                    repairUnitRow.getSet(&quot;column_families&quot;, String.class),</b>
<b class="nc">&nbsp;                    repairUnitRow.getBool(&quot;incremental_repair&quot;),</b>
<b class="nc">&nbsp;                    repairUnitRow.getSet(&quot;nodes&quot;, String.class),</b>
<b class="nc">&nbsp;                    repairUnitRow.getSet(&quot;datacenters&quot;, String.class),</b>
<b class="nc">&nbsp;                    repairUnitRow.getSet(&quot;blacklisted_tables&quot;, String.class))</b>
<b class="nc">&nbsp;                .build(repairUnitRow.getUUID(&quot;id&quot;));</b>
&nbsp;        // exit the loop once we find a match
<b class="nc">&nbsp;        break;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return Optional.fromNullable(repairUnit);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean updateRepairSegment(RepairSegment segment) {
&nbsp;
<b class="nc">&nbsp;    assert hasLeadOnSegment(segment.getId())</b>
<b class="nc">&nbsp;        || (hasLeadOnSegment(segment.getRunId())</b>
<b class="nc">&nbsp;          &amp;&amp; getRepairUnit(segment.getRepairUnitId()).get().getIncrementalRepair())</b>
<b class="nc">&nbsp;        : &quot;non-leader trying to update repair segment &quot; + segment.getId() + &quot; of run &quot; + segment.getRunId();</b>
&nbsp;
<b class="nc">&nbsp;    BatchStatement updateRepairSegmentBatch = new BatchStatement(BatchStatement.Type.UNLOGGED);</b>
&nbsp;
<b class="nc">&nbsp;    updateRepairSegmentBatch.add(</b>
<b class="nc">&nbsp;        updateRepairSegmentPrepStmt.bind(</b>
<b class="nc">&nbsp;            segment.getRunId(),</b>
<b class="nc">&nbsp;            segment.getId(),</b>
<b class="nc">&nbsp;            segment.getState().ordinal(),</b>
<b class="nc">&nbsp;            segment.getCoordinatorHost(),</b>
<b class="nc">&nbsp;            segment.hasStartTime() ? segment.getStartTime().toDate() : null,</b>
<b class="nc">&nbsp;            segment.getFailCount()));</b>
&nbsp;
<b class="nc">&nbsp;    if (null != segment.getEndTime() || State.NOT_STARTED == segment.getState()) {</b>
&nbsp;
<b class="nc">&nbsp;      Preconditions.checkArgument(</b>
<b class="nc">&nbsp;          RepairSegment.State.RUNNING != segment.getState() ,</b>
<b class="nc">&nbsp;          &quot;un/setting endTime not permitted when state is RUNNING&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      Preconditions.checkArgument(</b>
<b class="nc">&nbsp;          RepairSegment.State.NOT_STARTED != segment.getState() || !segment.hasEndTime(),</b>
<b class="nc">&nbsp;          &quot;endTime can only be nulled when state is NOT_STARTED&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      Preconditions.checkArgument(</b>
<b class="nc">&nbsp;          RepairSegment.State.DONE != segment.getState() || segment.hasEndTime(),</b>
<b class="nc">&nbsp;          &quot;endTime can&#39;t be null when state is DONE&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      updateRepairSegmentBatch.add(</b>
<b class="nc">&nbsp;          insertRepairSegmentEndTimePrepStmt.bind(</b>
<b class="nc">&nbsp;              segment.getRunId(),</b>
<b class="nc">&nbsp;              segment.getId(),</b>
<b class="nc">&nbsp;              segment.hasEndTime() ? segment.getEndTime().toDate() : null));</b>
&nbsp;    }
<b class="nc">&nbsp;    session.execute(updateRepairSegmentBatch);</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;RepairSegment&gt; getRepairSegment(UUID runId, UUID segmentId) {
<b class="nc">&nbsp;    RepairSegment segment = null;</b>
<b class="nc">&nbsp;    Row segmentRow = session.execute(getRepairSegmentPrepStmt.bind(runId, segmentId)).one();</b>
<b class="nc">&nbsp;    if (segmentRow != null) {</b>
<b class="nc">&nbsp;      segment = createRepairSegmentFromRow(segmentRow);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return Optional.fromNullable(segment);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairSegment&gt; getRepairSegmentsForRun(UUID runId) {
<b class="nc">&nbsp;    Collection&lt;RepairSegment&gt; segments = Lists.newArrayList();</b>
&nbsp;    // First gather segments ids
<b class="nc">&nbsp;    ResultSet segmentsIdResultSet = session.execute(getRepairSegmentsByRunIdPrepStmt.bind(runId));</b>
<b class="nc">&nbsp;    for (Row segmentRow : segmentsIdResultSet) {</b>
<b class="nc">&nbsp;      segments.add(createRepairSegmentFromRow(segmentRow));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return segments;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean segmentIsWithinRange(RepairSegment segment, RingRange range) {
<b class="nc">&nbsp;    return range.encloses(new RingRange(segment.getStartToken(), segment.getEndToken()));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static RepairSegment createRepairSegmentFromRow(Row segmentRow) {
&nbsp;
<b class="nc">&nbsp;    RepairSegment.Builder builder = RepairSegment.builder(</b>
<b class="nc">&nbsp;          new RingRange(</b>
<b class="nc">&nbsp;              new BigInteger(segmentRow.getVarint(&quot;start_token&quot;) + &quot;&quot;),</b>
<b class="nc">&nbsp;              new BigInteger(segmentRow.getVarint(&quot;end_token&quot;) + &quot;&quot;)),</b>
<b class="nc">&nbsp;          segmentRow.getUUID(&quot;repair_unit_id&quot;))</b>
<b class="nc">&nbsp;        .withRunId(segmentRow.getUUID(&quot;id&quot;))</b>
<b class="nc">&nbsp;        .state(State.values()[segmentRow.getInt(&quot;segment_state&quot;)])</b>
<b class="nc">&nbsp;        .failCount(segmentRow.getInt(&quot;fail_count&quot;));</b>
&nbsp;
<b class="nc">&nbsp;    if (null != segmentRow.getString(&quot;coordinator_host&quot;)) {</b>
<b class="nc">&nbsp;      builder = builder.coordinatorHost(segmentRow.getString(&quot;coordinator_host&quot;));</b>
&nbsp;    }
<b class="nc">&nbsp;    if (null != segmentRow.getTimestamp(&quot;segment_start_time&quot;)) {</b>
<b class="nc">&nbsp;      builder = builder.startTime(new DateTime(segmentRow.getTimestamp(&quot;segment_start_time&quot;)));</b>
&nbsp;    }
<b class="nc">&nbsp;    if (null != segmentRow.getTimestamp(&quot;segment_end_time&quot;)) {</b>
<b class="nc">&nbsp;      builder = builder.endTime(new DateTime(segmentRow.getTimestamp(&quot;segment_end_time&quot;)));</b>
&nbsp;    }
<b class="nc">&nbsp;    return builder.build(segmentRow.getUUID(&quot;segment_id&quot;));</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;RepairSegment&gt; getNextFreeSegmentInRange(UUID runId, Optional&lt;RingRange&gt; range) {
<b class="nc">&nbsp;    List&lt;RepairSegment&gt; segments = Lists.&lt;RepairSegment&gt;newArrayList(getRepairSegmentsForRun(runId));</b>
<b class="nc">&nbsp;    Collections.shuffle(segments);</b>
&nbsp;
<b class="nc">&nbsp;    for (RepairSegment seg : segments) {</b>
<b class="nc">&nbsp;      if (seg.getState().equals(State.NOT_STARTED) &amp;&amp; withinRange(seg, range)) {</b>
<b class="nc">&nbsp;        return Optional.of(seg);</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return Optional.absent();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairSegment&gt; getSegmentsWithState(UUID runId, State segmentState) {
<b class="nc">&nbsp;    Collection&lt;RepairSegment&gt; foundSegments = Lists.&lt;RepairSegment&gt;newArrayList();</b>
<b class="nc">&nbsp;    List&lt;RepairSegment&gt; segments = Lists.&lt;RepairSegment&gt;newArrayList();</b>
&nbsp;
<b class="nc">&nbsp;    segments.addAll(getRepairSegmentsForRun(runId));</b>
&nbsp;
<b class="nc">&nbsp;    for (RepairSegment seg : segments) {</b>
<b class="nc">&nbsp;      if (seg.getState().equals(segmentState)) {</b>
<b class="nc">&nbsp;        foundSegments.add(seg);</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return foundSegments;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairParameters&gt; getOngoingRepairsInCluster(String clusterName) {
<b class="nc">&nbsp;    Collection&lt;RepairParameters&gt; repairs = Lists.&lt;RepairParameters&gt;newArrayList();</b>
&nbsp;
<b class="nc">&nbsp;    Collection&lt;RepairRun&gt; repairRuns = getRepairRunsForCluster(clusterName);</b>
&nbsp;
<b class="nc">&nbsp;    for (RepairRun repairRun : repairRuns) {</b>
<b class="nc">&nbsp;      Collection&lt;RepairSegment&gt; runningSegments = getSegmentsWithState(repairRun.getId(), State.RUNNING);</b>
<b class="nc">&nbsp;      for (RepairSegment segment : runningSegments) {</b>
<b class="nc">&nbsp;        Optional&lt;RepairUnit&gt; repairUnit = getRepairUnit(repairRun.getRepairUnitId());</b>
<b class="nc">&nbsp;        repairs.add(</b>
<b class="nc">&nbsp;            new RepairParameters(</b>
<b class="nc">&nbsp;                new RingRange(segment.getStartToken(), segment.getEndToken()),</b>
<b class="nc">&nbsp;                repairUnit.get().getKeyspaceName(),</b>
<b class="nc">&nbsp;                repairUnit.get().getColumnFamilies(),</b>
<b class="nc">&nbsp;                repairRun.getRepairParallelism()));</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    LOG.trace(&quot;found ongoing repairs {} {}&quot;, repairs.size(), repairs);</b>
&nbsp;
<b class="nc">&nbsp;    return repairs;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;UUID&gt; getRepairRunIdsForCluster(String clusterName) {
<b class="nc">&nbsp;    Collection&lt;UUID&gt; repairRunIds = Lists.&lt;UUID&gt;newArrayList();</b>
<b class="nc">&nbsp;    ResultSet results = session.execute(getRepairRunForClusterPrepStmt.bind(clusterName));</b>
<b class="nc">&nbsp;    for (Row result : results) {</b>
<b class="nc">&nbsp;      repairRunIds.add(result.getUUID(&quot;id&quot;));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    LOG.trace(&quot;repairRunIds : {}&quot;, repairRunIds);</b>
<b class="nc">&nbsp;    return repairRunIds;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public int getSegmentAmountForRepairRun(UUID runId) {
<b class="nc">&nbsp;    return getRepairSegmentsForRun(runId).size();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public int getSegmentAmountForRepairRunWithState(UUID runId, State state) {
<b class="nc">&nbsp;    return getSegmentsWithState(runId, state).size();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public RepairSchedule addRepairSchedule(io.cassandrareaper.core.RepairSchedule.Builder repairSchedule) {
<b class="nc">&nbsp;    RepairSchedule schedule = repairSchedule.build(UUIDs.timeBased());</b>
<b class="nc">&nbsp;    updateRepairSchedule(schedule);</b>
&nbsp;
<b class="nc">&nbsp;    return schedule;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;RepairSchedule&gt; getRepairSchedule(UUID repairScheduleId) {
<b class="nc">&nbsp;    Row sched = session.execute(getRepairSchedulePrepStmt.bind(repairScheduleId)).one();</b>
&nbsp;
<b class="nc">&nbsp;    return sched != null ? Optional.fromNullable(createRepairScheduleFromRow(sched)) : Optional.absent();</b>
&nbsp;  }
&nbsp;
&nbsp;  private RepairSchedule createRepairScheduleFromRow(Row repairScheduleRow) {
<b class="nc">&nbsp;    return new RepairSchedule.Builder(</b>
<b class="nc">&nbsp;            repairScheduleRow.getUUID(&quot;repair_unit_id&quot;),</b>
<b class="nc">&nbsp;            RepairSchedule.State.valueOf(repairScheduleRow.getString(&quot;state&quot;)),</b>
<b class="nc">&nbsp;            repairScheduleRow.getInt(&quot;days_between&quot;),</b>
<b class="nc">&nbsp;            new DateTime(repairScheduleRow.getTimestamp(&quot;next_activation&quot;)),</b>
<b class="nc">&nbsp;            ImmutableList.copyOf(repairScheduleRow.getSet(&quot;run_history&quot;, UUID.class)),</b>
<b class="nc">&nbsp;            repairScheduleRow.getInt(&quot;segment_count&quot;),</b>
<b class="nc">&nbsp;            RepairParallelism.fromName(repairScheduleRow.getString(&quot;repair_parallelism&quot;)),</b>
<b class="nc">&nbsp;            repairScheduleRow.getDouble(&quot;intensity&quot;),</b>
<b class="nc">&nbsp;            new DateTime(repairScheduleRow.getTimestamp(&quot;creation_time&quot;)),</b>
<b class="nc">&nbsp;            repairScheduleRow.getInt(&quot;segment_count_per_node&quot;))</b>
<b class="nc">&nbsp;        .owner(repairScheduleRow.getString(&quot;owner&quot;))</b>
<b class="nc">&nbsp;        .pauseTime(new DateTime(repairScheduleRow.getTimestamp(&quot;pause_time&quot;)))</b>
<b class="nc">&nbsp;        .build(repairScheduleRow.getUUID(&quot;id&quot;));</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairSchedule&gt; getRepairSchedulesForCluster(String clusterName) {
<b class="nc">&nbsp;    Collection&lt;RepairSchedule&gt; schedules = Lists.&lt;RepairSchedule&gt;newArrayList();</b>
<b class="nc">&nbsp;    ResultSet scheduleIds = session.execute(getRepairScheduleByClusterAndKsPrepStmt.bind(clusterName, &quot; &quot;));</b>
<b class="nc">&nbsp;    for (Row scheduleId : scheduleIds) {</b>
<b class="nc">&nbsp;      Optional&lt;RepairSchedule&gt; schedule = getRepairSchedule(scheduleId.getUUID(&quot;repair_schedule_id&quot;));</b>
<b class="nc">&nbsp;      if (schedule.isPresent()) {</b>
<b class="nc">&nbsp;        schedules.add(schedule.get());</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return schedules;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairSchedule&gt; getRepairSchedulesForKeyspace(String keyspaceName) {
<b class="nc">&nbsp;    Collection&lt;RepairSchedule&gt; schedules = Lists.&lt;RepairSchedule&gt;newArrayList();</b>
<b class="nc">&nbsp;    ResultSet scheduleIds = session.execute(getRepairScheduleByClusterAndKsPrepStmt.bind(&quot; &quot;, keyspaceName));</b>
<b class="nc">&nbsp;    for (Row scheduleId : scheduleIds) {</b>
<b class="nc">&nbsp;      Optional&lt;RepairSchedule&gt; schedule = getRepairSchedule(scheduleId.getUUID(&quot;repair_schedule_id&quot;));</b>
<b class="nc">&nbsp;      if (schedule.isPresent()) {</b>
<b class="nc">&nbsp;        schedules.add(schedule.get());</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return schedules;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairSchedule&gt; getRepairSchedulesForClusterAndKeyspace(String clusterName, String keyspaceName) {
<b class="nc">&nbsp;    Collection&lt;RepairSchedule&gt; schedules = Lists.&lt;RepairSchedule&gt;newArrayList();</b>
<b class="nc">&nbsp;    ResultSet scheduleIds = session.execute(getRepairScheduleByClusterAndKsPrepStmt.bind(clusterName, keyspaceName));</b>
<b class="nc">&nbsp;    for (Row scheduleId : scheduleIds) {</b>
<b class="nc">&nbsp;      Optional&lt;RepairSchedule&gt; schedule = getRepairSchedule(scheduleId.getUUID(&quot;repair_schedule_id&quot;));</b>
<b class="nc">&nbsp;      if (schedule.isPresent()) {</b>
<b class="nc">&nbsp;        schedules.add(schedule.get());</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return schedules;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairSchedule&gt; getAllRepairSchedules() {
<b class="nc">&nbsp;    Collection&lt;RepairSchedule&gt; schedules = Lists.&lt;RepairSchedule&gt;newArrayList();</b>
<b class="nc">&nbsp;    Statement stmt = new SimpleStatement(SELECT_REPAIR_SCHEDULE);</b>
<b class="nc">&nbsp;    stmt.setIdempotent(Boolean.TRUE);</b>
<b class="nc">&nbsp;    ResultSet scheduleResults = session.execute(stmt);</b>
<b class="nc">&nbsp;    for (Row scheduleRow : scheduleResults) {</b>
<b class="nc">&nbsp;      schedules.add(createRepairScheduleFromRow(scheduleRow));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return schedules;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean updateRepairSchedule(RepairSchedule newRepairSchedule) {
<b class="nc">&nbsp;    final Set&lt;UUID&gt; repairHistory = Sets.newHashSet();</b>
<b class="nc">&nbsp;    repairHistory.addAll(newRepairSchedule.getRunHistory());</b>
<b class="nc">&nbsp;    RepairUnit repairUnit = getRepairUnit(newRepairSchedule.getRepairUnitId()).get();</b>
<b class="nc">&nbsp;    List&lt;ResultSetFuture&gt; futures = Lists.newArrayList();</b>
&nbsp;
<b class="nc">&nbsp;    futures.add(</b>
<b class="nc">&nbsp;        session.executeAsync(</b>
<b class="nc">&nbsp;            insertRepairSchedulePrepStmt.bind(</b>
<b class="nc">&nbsp;                newRepairSchedule.getId(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getRepairUnitId(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getState().toString(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getDaysBetween(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getNextActivation(),</b>
<b class="nc">&nbsp;                repairHistory,</b>
<b class="nc">&nbsp;                newRepairSchedule.getSegmentCount(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getRepairParallelism().toString(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getIntensity(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getCreationTime(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getOwner(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getPauseTime(),</b>
<b class="nc">&nbsp;                newRepairSchedule.getSegmentCountPerNode())));</b>
&nbsp;
<b class="nc">&nbsp;    futures.add(</b>
<b class="nc">&nbsp;        session.executeAsync(</b>
<b class="nc">&nbsp;            insertRepairScheduleByClusterAndKsPrepStmt.bind(</b>
<b class="nc">&nbsp;                repairUnit.getClusterName(), repairUnit.getKeyspaceName(), newRepairSchedule.getId())));</b>
&nbsp;
<b class="nc">&nbsp;    futures.add(</b>
<b class="nc">&nbsp;        session.executeAsync(</b>
<b class="nc">&nbsp;            insertRepairScheduleByClusterAndKsPrepStmt.bind(</b>
<b class="nc">&nbsp;                repairUnit.getClusterName(), &quot; &quot;, newRepairSchedule.getId())));</b>
&nbsp;
<b class="nc">&nbsp;    futures.add(</b>
<b class="nc">&nbsp;        session.executeAsync(</b>
<b class="nc">&nbsp;            insertRepairScheduleByClusterAndKsPrepStmt.bind(</b>
<b class="nc">&nbsp;                &quot; &quot;, repairUnit.getKeyspaceName(), newRepairSchedule.getId())));</b>
&nbsp;
&nbsp;    try {
<b class="nc">&nbsp;      Futures.allAsList(futures).get();</b>
<b class="nc">&nbsp;    } catch (InterruptedException | ExecutionException ex) {</b>
<b class="nc">&nbsp;      LOG.error(&quot;failed to quorum update repair schedule &quot; + newRepairSchedule.getId(), ex);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;RepairSchedule&gt; deleteRepairSchedule(UUID id) {
<b class="nc">&nbsp;    Optional&lt;RepairSchedule&gt; repairSchedule = getRepairSchedule(id);</b>
<b class="nc">&nbsp;    if (repairSchedule.isPresent()) {</b>
<b class="nc">&nbsp;      RepairUnit repairUnit = getRepairUnit(repairSchedule.get().getRepairUnitId()).get();</b>
&nbsp;
<b class="nc">&nbsp;      session.executeAsync(</b>
<b class="nc">&nbsp;          deleteRepairScheduleByClusterAndKsPrepStmt.bind(</b>
<b class="nc">&nbsp;              repairUnit.getClusterName(), repairUnit.getKeyspaceName(), repairSchedule.get().getId()));</b>
&nbsp;
<b class="nc">&nbsp;      session.executeAsync(</b>
<b class="nc">&nbsp;          deleteRepairScheduleByClusterAndKsPrepStmt.bind(</b>
<b class="nc">&nbsp;              repairUnit.getClusterName(), &quot; &quot;, repairSchedule.get().getId()));</b>
&nbsp;
<b class="nc">&nbsp;      session.executeAsync(</b>
<b class="nc">&nbsp;          deleteRepairScheduleByClusterAndKsPrepStmt.bind(</b>
<b class="nc">&nbsp;              &quot; &quot;, repairUnit.getKeyspaceName(), repairSchedule.get().getId()));</b>
&nbsp;
<b class="nc">&nbsp;      session.executeAsync(deleteRepairSchedulePrepStmt.bind(repairSchedule.get().getId()));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return repairSchedule;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairRunStatus&gt; getClusterRunStatuses(String clusterName, int limit) {
<b class="nc">&nbsp;    Collection&lt;RepairRunStatus&gt; repairRunStatuses = Lists.&lt;RepairRunStatus&gt;newArrayList();</b>
<b class="nc">&nbsp;    Collection&lt;RepairRun&gt; repairRuns = getRepairRunsForCluster(clusterName);</b>
<b class="nc">&nbsp;    for (RepairRun repairRun : repairRuns) {</b>
<b class="nc">&nbsp;      Collection&lt;RepairSegment&gt; segments = getRepairSegmentsForRun(repairRun.getId());</b>
<b class="nc">&nbsp;      Optional&lt;RepairUnit&gt; repairUnit = getRepairUnit(repairRun.getRepairUnitId());</b>
&nbsp;
<b class="nc">&nbsp;      int segmentsRepaired</b>
<b class="nc">&nbsp;          = (int) segments.stream().filter(seg -&gt; seg.getState().equals(RepairSegment.State.DONE)).count();</b>
&nbsp;
<b class="nc">&nbsp;      repairRunStatuses.add(new RepairRunStatus(repairRun, repairUnit.get(), segmentsRepaired));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return repairRunStatuses;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;RepairScheduleStatus&gt; getClusterScheduleStatuses(String clusterName) {
<b class="nc">&nbsp;    Collection&lt;RepairSchedule&gt; repairSchedules = getRepairSchedulesForCluster(clusterName);</b>
&nbsp;
<b class="nc">&nbsp;    Collection&lt;RepairScheduleStatus&gt; repairScheduleStatuses = repairSchedules</b>
<b class="nc">&nbsp;        .stream()</b>
<b class="nc">&nbsp;        .map(sched -&gt; new RepairScheduleStatus(sched, getRepairUnit(sched.getRepairUnitId()).get()))</b>
<b class="nc">&nbsp;        .collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;    return repairScheduleStatuses;</b>
&nbsp;  }
&nbsp;
&nbsp;  private RepairRun buildRepairRunFromRow(Row repairRunResult, UUID id) {
<b class="nc">&nbsp;    LOG.trace(&quot;buildRepairRunFromRow {} / {}&quot;, id, repairRunResult);</b>
<b class="nc">&nbsp;    return new RepairRun.Builder(</b>
<b class="nc">&nbsp;        repairRunResult.getString(&quot;cluster_name&quot;),</b>
<b class="nc">&nbsp;        repairRunResult.getUUID(&quot;repair_unit_id&quot;),</b>
<b class="nc">&nbsp;        new DateTime(repairRunResult.getTimestamp(&quot;creation_time&quot;)),</b>
<b class="nc">&nbsp;        repairRunResult.getDouble(&quot;intensity&quot;),</b>
<b class="nc">&nbsp;        repairRunResult.getInt(&quot;segment_count&quot;),</b>
<b class="nc">&nbsp;        RepairParallelism.fromName(repairRunResult.getString(&quot;repair_parallelism&quot;)))</b>
<b class="nc">&nbsp;        .cause(repairRunResult.getString(&quot;cause&quot;))</b>
<b class="nc">&nbsp;        .owner(repairRunResult.getString(&quot;owner&quot;))</b>
<b class="nc">&nbsp;        .endTime(new DateTime(repairRunResult.getTimestamp(&quot;end_time&quot;)))</b>
<b class="nc">&nbsp;        .lastEvent(repairRunResult.getString(&quot;last_event&quot;))</b>
<b class="nc">&nbsp;        .pauseTime(new DateTime(repairRunResult.getTimestamp(&quot;pause_time&quot;)))</b>
<b class="nc">&nbsp;        .runState(RunState.valueOf(repairRunResult.getString(&quot;state&quot;)))</b>
<b class="nc">&nbsp;        .startTime(new DateTime(repairRunResult.getTimestamp(&quot;start_time&quot;)))</b>
<b class="nc">&nbsp;        .build(id);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean takeLead(UUID leaderId) {
<b class="nc">&nbsp;    LOG.debug(&quot;Trying to take lead on segment {}&quot;, leaderId);</b>
<b class="nc">&nbsp;    ResultSet lwtResult = session.execute(</b>
<b class="nc">&nbsp;        takeLeadPrepStmt.bind(leaderId, AppContext.REAPER_INSTANCE_ID, AppContext.REAPER_INSTANCE_ADDRESS));</b>
&nbsp;
<b class="nc">&nbsp;    if (lwtResult.wasApplied()) {</b>
<b class="nc">&nbsp;      LOG.debug(&quot;Took lead on segment {}&quot;, leaderId);</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Another instance took the lead on the segmen
<b class="nc">&nbsp;    LOG.debug(&quot;Could not take lead on segment {}&quot;, leaderId);</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean renewLead(UUID leaderId) {
<b class="nc">&nbsp;    ResultSet lwtResult = session.execute(</b>
<b class="nc">&nbsp;        renewLeadPrepStmt.bind(</b>
<b class="nc">&nbsp;            AppContext.REAPER_INSTANCE_ID,</b>
<b class="nc">&nbsp;            AppContext.REAPER_INSTANCE_ADDRESS,</b>
<b class="nc">&nbsp;            leaderId,</b>
<b class="nc">&nbsp;            AppContext.REAPER_INSTANCE_ID));</b>
&nbsp;
<b class="nc">&nbsp;    if (lwtResult.wasApplied()) {</b>
<b class="nc">&nbsp;      LOG.debug(&quot;Renewed lead on segment {}&quot;, leaderId);</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    assert false : &quot;Could not renew lead on segment &quot; + leaderId;</b>
<b class="nc">&nbsp;    LOG.error(&quot;Failed to renew lead on segment {}&quot;, leaderId);</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public List&lt;UUID&gt; getLeaders() {
<b class="nc">&nbsp;    return session.execute(new SimpleStatement(SELECT_LEADERS))</b>
<b class="nc">&nbsp;        .all()</b>
<b class="nc">&nbsp;        .stream()</b>
<b class="nc">&nbsp;        .map(leader -&gt; leader.getUUID(&quot;leader_id&quot;))</b>
<b class="nc">&nbsp;        .collect(Collectors.toList());</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public void releaseLead(UUID leaderId) {
<b class="nc">&nbsp;    ResultSet lwtResult = session.execute(releaseLeadPrepStmt.bind(leaderId, AppContext.REAPER_INSTANCE_ID));</b>
&nbsp;
<b class="nc">&nbsp;    if (lwtResult.wasApplied()) {</b>
<b class="nc">&nbsp;      LOG.debug(&quot;Released lead on segment {}&quot;, leaderId);</b>
<b class="nc">&nbsp;    } else {</b>
<b class="nc">&nbsp;      assert false : &quot;Could not release lead on segment &quot; + leaderId;</b>
<b class="nc">&nbsp;      LOG.error(&quot;Could not release lead on segment {}&quot;, leaderId);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean hasLeadOnSegment(UUID leaderId) {
<b class="nc">&nbsp;    ResultSet lwtResult = session.execute(</b>
<b class="nc">&nbsp;        renewLeadPrepStmt.bind(</b>
<b class="nc">&nbsp;            AppContext.REAPER_INSTANCE_ID,</b>
<b class="nc">&nbsp;            AppContext.REAPER_INSTANCE_ADDRESS,</b>
<b class="nc">&nbsp;            leaderId,</b>
<b class="nc">&nbsp;            AppContext.REAPER_INSTANCE_ID));</b>
&nbsp;
<b class="nc">&nbsp;    return lwtResult.wasApplied();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public void storeNodeMetrics(UUID runId, NodeMetrics nodeMetrics) {
<b class="nc">&nbsp;    long minute = TimeUnit.MILLISECONDS.toMinutes(System.currentTimeMillis());</b>
<b class="nc">&nbsp;    storeNodeMetricsImpl(runId, nodeMetrics, minute);</b>
<b class="nc">&nbsp;    storeNodeMetricsImpl(runId, nodeMetrics, minute + 1);</b>
<b class="nc">&nbsp;    storeNodeMetricsImpl(runId, nodeMetrics, minute + 2);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void storeNodeMetricsImpl(UUID runId, NodeMetrics nodeMetrics, long minute) {
<b class="nc">&nbsp;    session.executeAsync(</b>
<b class="nc">&nbsp;        storeNodeMetricsPrepStmt.bind(</b>
<b class="nc">&nbsp;            minute,</b>
<b class="nc">&nbsp;            runId,</b>
<b class="nc">&nbsp;            nodeMetrics.getNode(),</b>
<b class="nc">&nbsp;            nodeMetrics.getDatacenter(),</b>
<b class="nc">&nbsp;            nodeMetrics.getCluster(),</b>
<b class="nc">&nbsp;            nodeMetrics.isRequested(),</b>
<b class="nc">&nbsp;            nodeMetrics.getPendingCompactions(),</b>
<b class="nc">&nbsp;            nodeMetrics.hasRepairRunning(),</b>
<b class="nc">&nbsp;            nodeMetrics.getActiveAnticompactions()));</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Collection&lt;NodeMetrics&gt; getNodeMetrics(UUID runId) {
<b class="nc">&nbsp;    long minute = TimeUnit.MILLISECONDS.toMinutes(System.currentTimeMillis());</b>
&nbsp;
<b class="nc">&nbsp;    return session.execute(getNodeMetricsPrepStmt.bind(minute, runId)).all().stream()</b>
<b class="nc">&nbsp;        .map((row) -&gt; createNodeMetrics(row))</b>
<b class="nc">&nbsp;        .collect(Collectors.toSet());</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Optional&lt;NodeMetrics&gt; getNodeMetrics(UUID runId, String node) {
<b class="nc">&nbsp;    long minute = TimeUnit.MILLISECONDS.toMinutes(System.currentTimeMillis());</b>
<b class="nc">&nbsp;    Row row = session.execute(getNodeMetricsByNodePrepStmt.bind(minute, runId, node)).one();</b>
<b class="nc">&nbsp;    return null != row ? Optional.of(createNodeMetrics(row)) : Optional.absent();</b>
&nbsp;  }
&nbsp;
&nbsp;  private static NodeMetrics createNodeMetrics(Row row) {
<b class="nc">&nbsp;    return NodeMetrics.builder()</b>
<b class="nc">&nbsp;        .withNode(row.getString(&quot;node&quot;))</b>
<b class="nc">&nbsp;        .withDatacenter(row.getString(&quot;datacenter&quot;))</b>
<b class="nc">&nbsp;        .withCluster(row.getString(&quot;cluster&quot;))</b>
<b class="nc">&nbsp;        .withRequested(row.getBool(&quot;requested&quot;))</b>
<b class="nc">&nbsp;        .withPendingCompactions(row.getInt(&quot;pending_compactions&quot;))</b>
<b class="nc">&nbsp;        .withHasRepairRunning(row.getBool(&quot;has_repair_running&quot;))</b>
<b class="nc">&nbsp;        .withActiveAnticompactions(row.getInt(&quot;active_anticompactions&quot;))</b>
<b class="nc">&nbsp;        .build();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public int countRunningReapers() {
<b class="nc">&nbsp;    ResultSet result = session.execute(getRunningReapersCountPrepStmt.bind());</b>
<b class="nc">&nbsp;    int runningReapers = (int) result.one().getLong(&quot;nb_reapers&quot;);</b>
<b class="nc">&nbsp;    LOG.debug(&quot;Running reapers = {}&quot;, runningReapers);</b>
<b class="nc">&nbsp;    return runningReapers &gt; 0 ? runningReapers : 1;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public void saveHeartbeat() {
<b class="nc">&nbsp;    session.executeAsync(</b>
<b class="nc">&nbsp;        saveHeartbeatPrepStmt.bind(AppContext.REAPER_INSTANCE_ID, AppContext.REAPER_INSTANCE_ADDRESS));</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  private static void overrideQueryOptions(CassandraFactory cassandraFactory) {
&nbsp;    // all INSERT and DELETE stmt prepared in this class are idempoten
<b class="nc">&nbsp;    if (cassandraFactory.getQueryOptions().isPresent()</b>
<b class="nc">&nbsp;        &amp;&amp; ConsistencyLevel.LOCAL_ONE != cassandraFactory.getQueryOptions().get().getConsistencyLevel()) {</b>
<b class="nc">&nbsp;      LOG.warn(&quot;Customization of cassandra&#39;s queryOptions is not supported and will be overridden&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    cassandraFactory.setQueryOptions(java.util.Optional.of(new QueryOptions().setDefaultIdempotence(true)));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void overrideRetryPolicy(CassandraFactory cassandraFactory) {
<b class="nc">&nbsp;    if (cassandraFactory.getRetryPolicy().isPresent()) {</b>
<b class="nc">&nbsp;      LOG.warn(&quot;Customization of cassandra&#39;s retry policy is not supported and will be overridden&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    cassandraFactory.setRetryPolicy(java.util.Optional.of((RetryPolicyFactory) () -&gt; new RetryPolicyImpl()));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void overridePoolingOptions(CassandraFactory cassandraFactory) {
<b class="nc">&nbsp;    PoolingOptionsFactory newPoolingOptionsFactory = new PoolingOptionsFactory() {</b>
&nbsp;      @Override
&nbsp;      public PoolingOptions build() {
<b class="nc">&nbsp;        if (null == getPoolTimeout()) {</b>
<b class="nc">&nbsp;          setPoolTimeout(Duration.minutes(2));</b>
&nbsp;        }
<b class="nc">&nbsp;        return super.build().setMaxQueueSize(40960);</b>
&nbsp;      }
&nbsp;    };
<b class="nc">&nbsp;    cassandraFactory.getPoolingOptions().ifPresent((originalPoolingOptions) -&gt; {</b>
<b class="nc">&nbsp;      newPoolingOptionsFactory.setHeartbeatInterval(originalPoolingOptions.getHeartbeatInterval());</b>
<b class="nc">&nbsp;      newPoolingOptionsFactory.setIdleTimeout(originalPoolingOptions.getIdleTimeout());</b>
<b class="nc">&nbsp;      newPoolingOptionsFactory.setLocal(originalPoolingOptions.getLocal());</b>
<b class="nc">&nbsp;      newPoolingOptionsFactory.setRemote(originalPoolingOptions.getRemote());</b>
<b class="nc">&nbsp;      newPoolingOptionsFactory.setPoolTimeout(originalPoolingOptions.getPoolTimeout());</b>
&nbsp;    });
<b class="nc">&nbsp;    cassandraFactory.setPoolingOptions(java.util.Optional.of(newPoolingOptionsFactory));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean withinRange(RepairSegment segment, Optional&lt;RingRange&gt; range) {
<b class="nc">&nbsp;    return !range.isPresent() || segmentIsWithinRange(segment, range.get());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retry all statements.
&nbsp;   *
&nbsp;   * &lt;p&gt;
&nbsp;   * All reaper statements are idempotent. Reaper generates few read and writes requests, so it&#39;s ok to keep
&nbsp;   * retrying.
&nbsp;   *
&nbsp;   * &lt;p&gt;
&nbsp;   * Sleep 100 milliseconds in between subsequent read retries. Fail after the tenth read retry.
&nbsp;   *
&nbsp;   * &lt;p&gt;
&nbsp;   * Writes keep retrying forever.
&nbsp;   */
<b class="nc">&nbsp;  private static class RetryPolicyImpl implements RetryPolicy {</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public RetryDecision onReadTimeout(
&nbsp;        Statement stmt,
&nbsp;        ConsistencyLevel cl,
&nbsp;        int required,
&nbsp;        int received,
&nbsp;        boolean retrieved,
&nbsp;        int retry) {
&nbsp;
<b class="nc">&nbsp;      if (retry &gt; 1) {</b>
&nbsp;        try {
<b class="nc">&nbsp;          Thread.sleep(100);</b>
<b class="nc">&nbsp;        } catch (InterruptedException expected) { }</b>
&nbsp;      }
<b class="nc">&nbsp;      return null != stmt &amp;&amp; stmt.isIdempotent()</b>
<b class="nc">&nbsp;          ? retry &lt; 10 ? RetryDecision.retry(cl) : RetryDecision.rethrow()</b>
<b class="nc">&nbsp;          : DefaultRetryPolicy.INSTANCE.onReadTimeout(stmt, cl, required, received, retrieved, retry);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RetryDecision onWriteTimeout(
&nbsp;        Statement stmt,
&nbsp;        ConsistencyLevel cl,
&nbsp;        WriteType type,
&nbsp;        int required,
&nbsp;        int received,
&nbsp;        int retry) {
&nbsp;
<b class="nc">&nbsp;      return null != stmt &amp;&amp; stmt.isIdempotent()</b>
<b class="nc">&nbsp;          ? RetryDecision.retry(cl)</b>
<b class="nc">&nbsp;          : DefaultRetryPolicy.INSTANCE.onWriteTimeout(stmt, cl, type, required, received, retry);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RetryDecision onUnavailable(Statement stmt, ConsistencyLevel cl, int required, int aliveReplica, int retry) {
<b class="nc">&nbsp;      return DefaultRetryPolicy.INSTANCE.onUnavailable(stmt, cl, required, aliveReplica, retry == 1 ? 0 : retry);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RetryDecision onRequestError(Statement stmt, ConsistencyLevel cl, DriverException ex, int nbRetry) {
<b class="nc">&nbsp;      return DefaultRetryPolicy.INSTANCE.onRequestError(stmt, cl, ex, nbRetry);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void init(com.datastax.driver.core.Cluster cluster) {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void close() {
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 22:17</div>
</div>
</body>
</html>
