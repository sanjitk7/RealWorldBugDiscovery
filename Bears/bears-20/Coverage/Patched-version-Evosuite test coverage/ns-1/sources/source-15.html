


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > NumberDeserializers</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.deser.std</a>
</div>

<h1>Coverage Summary for Class: NumberDeserializers (com.fasterxml.jackson.databind.deser.std)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">NumberDeserializers</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.9%
  </span>
  <span class="absValue">
    (7/47)
  </span>
</td>
</tr>
  <tr>
    <td class="name">NumberDeserializers$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$BigDecimalDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.3%
  </span>
  <span class="absValue">
    (1/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$BigIntegerDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.9%
  </span>
  <span class="absValue">
    (1/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$BooleanDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$ByteDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$CharacterDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    13.3%
  </span>
  <span class="absValue">
    (2/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$DoubleDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$FloatDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$IntegerDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.4%
  </span>
  <span class="absValue">
    (4/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$LongDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$NumberDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7.7%
  </span>
  <span class="absValue">
    (3/39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$PrimitiveOrWrapperDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (4/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NumberDeserializers$ShortDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    34.8%
  </span>
  <span class="absValue">
    (16/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18%
  </span>
  <span class="absValue">
    (34/189)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.deser.std;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.util.HashSet;
&nbsp;
&nbsp;import com.fasterxml.jackson.core.*;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
&nbsp;import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
&nbsp;
&nbsp;/**
&nbsp; * Container class for deserializers that handle core JDK primitive
&nbsp; * (and matching wrapper) types, as well as standard &quot;big&quot; numeric types.
&nbsp; * Note that this includes types such as {@link java.lang.Boolean}
&nbsp; * and {@link java.lang.Character} which are not strictly numeric,
&nbsp; * but are part of primitive/wrapper types.
&nbsp; */
<b class="nc">&nbsp;public class NumberDeserializers</b>
&nbsp;{
<b class="fc">&nbsp;    private final static HashSet&lt;String&gt; _classNames = new HashSet&lt;String&gt;();</b>
&nbsp;    static {
&nbsp;        // note: can skip primitive types; other ways to check them:
<b class="fc">&nbsp;        Class&lt;?&gt;[] numberTypes = new Class&lt;?&gt;[] {</b>
&nbsp;            Boolean.class,
&nbsp;            Byte.class,
&nbsp;            Short.class,
&nbsp;            Character.class,
&nbsp;            Integer.class,
&nbsp;            Long.class,
&nbsp;            Float.class,
&nbsp;            Double.class,
&nbsp;            // and more generic ones
&nbsp;            Number.class, BigDecimal.class, BigInteger.class
&nbsp;        };
<b class="fc">&nbsp;        for (Class&lt;?&gt; cls : numberTypes) {</b>
<b class="fc">&nbsp;            _classNames.add(cls.getName());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JsonDeserializer&lt;?&gt; find(Class&lt;?&gt; rawType, String clsName) {
<b class="fc">&nbsp;        if (rawType.isPrimitive()) {</b>
<b class="nc">&nbsp;            if (rawType == Integer.TYPE) {</b>
<b class="nc">&nbsp;                return IntegerDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Boolean.TYPE) {</b>
<b class="nc">&nbsp;                return BooleanDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Long.TYPE) {</b>
<b class="nc">&nbsp;                return LongDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Double.TYPE) {</b>
<b class="nc">&nbsp;                return DoubleDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Character.TYPE) {</b>
<b class="nc">&nbsp;                return CharacterDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Byte.TYPE) {</b>
<b class="nc">&nbsp;                return ByteDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Short.TYPE) {</b>
<b class="nc">&nbsp;                return ShortDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Float.TYPE) {</b>
<b class="nc">&nbsp;                return FloatDeserializer.primitiveInstance;</b>
&nbsp;            }
<b class="fc">&nbsp;        } else if (_classNames.contains(clsName)) {</b>
&nbsp;            // Start with most common types; int, boolean, long, double
<b class="nc">&nbsp;            if (rawType == Integer.class) {</b>
<b class="nc">&nbsp;                return IntegerDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Boolean.class) {</b>
<b class="nc">&nbsp;                return BooleanDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Long.class) {</b>
<b class="nc">&nbsp;                return LongDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Double.class) {</b>
<b class="nc">&nbsp;                return DoubleDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Character.class) {</b>
<b class="nc">&nbsp;                return CharacterDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Byte.class) {</b>
<b class="nc">&nbsp;                return ByteDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Short.class) {</b>
<b class="nc">&nbsp;                return ShortDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Float.class) {</b>
<b class="nc">&nbsp;                return FloatDeserializer.wrapperInstance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == Number.class) {</b>
<b class="nc">&nbsp;                return NumberDeserializer.instance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == BigDecimal.class) {</b>
<b class="nc">&nbsp;                return BigDecimalDeserializer.instance;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rawType == BigInteger.class) {</b>
<b class="nc">&nbsp;                return BigIntegerDeserializer.instance;</b>
&nbsp;            }
&nbsp;        } else {
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // should never occur
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Internal error: can&#39;t find deserializer for &quot;+rawType.getName());</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Then one intermediate base class for things that have
&nbsp;    /* both primitive and wrapper types
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    protected abstract static class PrimitiveOrWrapperDeserializer&lt;T&gt;
&nbsp;        extends StdScalarDeserializer&lt;T&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        protected final T _nullValue;
&nbsp;        protected final boolean _primitive;
&nbsp;
&nbsp;        protected PrimitiveOrWrapperDeserializer(Class&lt;T&gt; vc, T nvl) {
<b class="fc">&nbsp;            super(vc);</b>
<b class="fc">&nbsp;            _nullValue = nvl;</b>
<b class="fc">&nbsp;            _primitive = vc.isPrimitive();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException
&nbsp;        {
<b class="nc">&nbsp;            if (_primitive &amp;&amp; ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {</b>
<b class="nc">&nbsp;                ctxt.reportMappingException(</b>
&nbsp;                        &quot;Can not map JSON null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to &#39;false&#39; to allow)&quot;,
<b class="nc">&nbsp;                        handledType().toString());</b>
&nbsp;            }
<b class="nc">&nbsp;            return _nullValue;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {
&nbsp;            // [databind#1095]: Should not allow coercion from into null from Empty String
&nbsp;            // either, if `null` not allowed
<b class="nc">&nbsp;            if (_primitive &amp;&amp; ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {</b>
<b class="nc">&nbsp;                ctxt.reportMappingException(</b>
&nbsp;                        &quot;Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to &#39;false&#39; to allow)&quot;,
<b class="nc">&nbsp;                        handledType().toString());</b>
&nbsp;            }
<b class="nc">&nbsp;            return _nullValue;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Then primitive/wrapper types
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public final static class BooleanDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Boolean&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="nc">&nbsp;        final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.TYPE, Boolean.FALSE);</b>
<b class="nc">&nbsp;        final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.class, null);</b>
&nbsp;
&nbsp;        public BooleanDeserializer(Class&lt;Boolean&gt; cls, Boolean nvl)
&nbsp;        {
<b class="fc">&nbsp;            super(cls, nvl);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;        
&nbsp;        @Override
&nbsp;        public Boolean deserialize(JsonParser j, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="nc">&nbsp;            return _parseBoolean(j, ctxt);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Since we can never have type info (&quot;natural type&quot;; String, Boolean, Integer, Double):
&nbsp;        // (is it an error to even call this version?)
&nbsp;        @Override
&nbsp;        public Boolean deserializeWithType(JsonParser p, DeserializationContext ctxt,
&nbsp;                TypeDeserializer typeDeserializer)
&nbsp;            throws IOException
&nbsp;        {
<b class="nc">&nbsp;            return _parseBoolean(p, ctxt);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public static class ByteDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Byte&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="nc">&nbsp;        final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);</b>
<b class="nc">&nbsp;        final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);</b>
&nbsp;        
&nbsp;        public ByteDeserializer(Class&lt;Byte&gt; cls, Byte nvl)
&nbsp;        {
<b class="fc">&nbsp;            super(cls, nvl);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Byte deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
<b class="nc">&nbsp;            return _parseByte(p, ctxt);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public static class ShortDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Short&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="nc">&nbsp;        final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.TYPE, Short.valueOf((short)0));</b>
<b class="nc">&nbsp;        final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.class, null);</b>
&nbsp;        
&nbsp;        public ShortDeserializer(Class&lt;Short&gt; cls, Short nvl)
&nbsp;        {
<b class="fc">&nbsp;            super(cls, nvl);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Short deserialize(JsonParser jp, DeserializationContext ctxt)
&nbsp;            throws IOException
&nbsp;        {
<b class="nc">&nbsp;            return _parseShort(jp, ctxt);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @JacksonStdImpl
&nbsp;    public static class CharacterDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Character&gt;
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="nc">&nbsp;        final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.TYPE, &#39;\0&#39;);</b>
<b class="nc">&nbsp;        final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.class, null);</b>
&nbsp;        
&nbsp;        public CharacterDeserializer(Class&lt;Character&gt; cls, Character nvl)
&nbsp;        {
<b class="fc">&nbsp;            super(cls, nvl);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Character deserialize(JsonParser p, DeserializationContext ctxt)
&nbsp;            throws IOException
&nbsp;        {
<b class="nc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            case JsonTokenId.ID_NUMBER_INT: // ok iff ascii value
<b class="nc">&nbsp;                int value = p.getIntValue();</b>
<b class="nc">&nbsp;                if (value &gt;= 0 &amp;&amp; value &lt;= 0xFFFF) {</b>
<b class="nc">&nbsp;                    return Character.valueOf((char) value);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case JsonTokenId.ID_STRING: // this is the usual type
&nbsp;                // But does it have to be exactly one char?
<b class="nc">&nbsp;                String text = p.getText();</b>
<b class="nc">&nbsp;                if (text.length() == 1) {</b>
<b class="nc">&nbsp;                    return Character.valueOf(text.charAt(0));</b>
&nbsp;                }
&nbsp;                // actually, empty should become null?
<b class="nc">&nbsp;                if (text.length() == 0) {</b>
<b class="nc">&nbsp;                    return (Character) getEmptyValue(ctxt);</b>
&nbsp;                }               
&nbsp;                break;
&nbsp;            case JsonTokenId.ID_START_ARRAY:
<b class="nc">&nbsp;                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
&nbsp;                    p.nextToken();
&nbsp;                    final Character C = deserialize(p, ctxt);
<b class="nc">&nbsp;                    if (p.nextToken() != JsonToken.END_ARRAY) {</b>
&nbsp;                        handleMissingEndArrayForSingle(p, ctxt);
&nbsp;                    }
&nbsp;                    return C;
&nbsp;                }
&nbsp;            default:
&nbsp;            }
&nbsp;            return (Character) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    @JacksonStdImpl</b>
&nbsp;    public final static class IntegerDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Integer&gt;
<b class="fc">&nbsp;    {</b>
<b class="fc">&nbsp;        private static final long serialVersionUID = 1L;</b>
&nbsp;
&nbsp;        final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.TYPE, Integer.valueOf(0));
&nbsp;        final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.class, null);
<b class="nc">&nbsp;        </b>
&nbsp;        public IntegerDeserializer(Class&lt;Integer&gt; cls, Integer nvl) {
&nbsp;            super(cls, nvl);
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        // since 2.6, slightly faster lookups for this very common type</b>
&nbsp;        @Override
<b class="nc">&nbsp;        public boolean isCachable() { return true; }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
&nbsp;            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {
&nbsp;                return p.getIntValue();
&nbsp;            }
&nbsp;            return _parseInteger(p, ctxt);
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        // Since we can never have type info (&quot;natural type&quot;; String, Boolean, Integer, Double):</b>
&nbsp;        // (is it an error to even call this version?)
<b class="nc">&nbsp;        @Override</b>
&nbsp;        public Integer deserializeWithType(JsonParser p, DeserializationContext ctxt,
&nbsp;                TypeDeserializer typeDeserializer) throws IOException
&nbsp;        {
&nbsp;            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {
&nbsp;                return p.getIntValue();
&nbsp;            }
&nbsp;            return _parseInteger(p, ctxt);
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @JacksonStdImpl</b>
&nbsp;    public final static class LongDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Long&gt;
<b class="fc">&nbsp;    {</b>
<b class="fc">&nbsp;        private static final long serialVersionUID = 1L;</b>
&nbsp;
&nbsp;        final static LongDeserializer primitiveInstance = new LongDeserializer(Long.TYPE, Long.valueOf(0L));
&nbsp;        final static LongDeserializer wrapperInstance = new LongDeserializer(Long.class, null);
<b class="nc">&nbsp;        </b>
&nbsp;        public LongDeserializer(Class&lt;Long&gt; cls, Long nvl) {
&nbsp;            super(cls, nvl);
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        // since 2.6, slightly faster lookups for this very common type</b>
&nbsp;        @Override
<b class="nc">&nbsp;        public boolean isCachable() { return true; }</b>
&nbsp;        
&nbsp;        @Override
&nbsp;        public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
&nbsp;            if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {
&nbsp;                return p.getLongValue();
&nbsp;            }
&nbsp;            return _parseLong(p, ctxt);
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @JacksonStdImpl</b>
&nbsp;    public static class FloatDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Float&gt;
<b class="fc">&nbsp;    {</b>
<b class="fc">&nbsp;        private static final long serialVersionUID = 1L;</b>
&nbsp;
&nbsp;        final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.TYPE, 0.f);
&nbsp;        final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.class, null);
&nbsp;        
<b class="nc">&nbsp;        public FloatDeserializer(Class&lt;Float&gt; cls, Float nvl) {</b>
&nbsp;            super(cls, nvl);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Float deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
&nbsp;        {
&nbsp;            return _parseFloat(p, ctxt);
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @JacksonStdImpl</b>
&nbsp;    public static class DoubleDeserializer
&nbsp;        extends PrimitiveOrWrapperDeserializer&lt;Double&gt;
<b class="fc">&nbsp;    {</b>
<b class="fc">&nbsp;        private static final long serialVersionUID = 1L;</b>
&nbsp;
&nbsp;        final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.TYPE, 0.d);
&nbsp;        final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.class, null);
<b class="nc">&nbsp;        </b>
&nbsp;        public DoubleDeserializer(Class&lt;Double&gt; cls, Double nvl) {
&nbsp;            super(cls, nvl);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
&nbsp;            return _parseDouble(jp, ctxt);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        // Since we can never have type info (&quot;natural type&quot;; String, Boolean, Integer, Double):
&nbsp;        // (is it an error to even call this version?)
&nbsp;        @Override
&nbsp;        public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt,
&nbsp;                TypeDeserializer typeDeserializer) throws IOException
&nbsp;        {
&nbsp;            return _parseDouble(jp, ctxt);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For type &lt;code&gt;Number.class&lt;/code&gt;, we can just rely on type
&nbsp;     * mappings that plain {@link JsonParser#getNumberValue} returns.
&nbsp;     *&lt;p&gt;
&nbsp;     * There is one additional complication: some numeric
&nbsp;     * types (specifically, int/Integer and double/Double) are &quot;non-typed&quot;;
&nbsp;     * meaning that they will NEVER be output with type information.
&nbsp;     * But other numeric types may need such type information.
<b class="fc">&nbsp;     * This is why {@link #deserializeWithType} must be overridden.</b>
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<b class="fc">&nbsp;    @JacksonStdImpl</b>
<b class="fc">&nbsp;    public static class NumberDeserializer</b>
&nbsp;        extends StdScalarDeserializer&lt;Object&gt;
&nbsp;    {
&nbsp;        public final static NumberDeserializer instance = new NumberDeserializer();
&nbsp;        
<b class="nc">&nbsp;        public NumberDeserializer() {</b>
&nbsp;            super(Number.class);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        @Override
<b class="nc">&nbsp;        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException</b>
&nbsp;        {
&nbsp;            switch (p.getCurrentTokenId()) {
<b class="nc">&nbsp;            case JsonTokenId.ID_NUMBER_INT:</b>
<b class="nc">&nbsp;                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {</b>
&nbsp;                    return _coerceIntegral(p, ctxt);
<b class="nc">&nbsp;                }</b>
&nbsp;                return p.getNumberValue();
&nbsp;
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:
&nbsp;                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
&nbsp;                    return p.getDecimalValue();
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return Double.valueOf(p.getDoubleValue());</b>
<b class="nc">&nbsp;</b>
&nbsp;            case JsonTokenId.ID_STRING:
<b class="nc">&nbsp;                /* Textual values are more difficult... not parsing itself, but figuring</b>
<b class="nc">&nbsp;                 * out &#39;minimal&#39; type to use </b>
&nbsp;                 */
<b class="nc">&nbsp;                String text = p.getText().trim();</b>
<b class="nc">&nbsp;                if (text.length() == 0) {</b>
&nbsp;                    return getEmptyValue(ctxt);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (_hasTextualNull(text)) {</b>
&nbsp;                    return getNullValue(ctxt);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (_isPosInf(text)) {</b>
&nbsp;                    return Double.POSITIVE_INFINITY;
&nbsp;                }
<b class="nc">&nbsp;                if (_isNegInf(text)) {</b>
<b class="nc">&nbsp;                    return Double.NEGATIVE_INFINITY;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                if (_isNaN(text)) {
<b class="nc">&nbsp;                    return Double.NaN;</b>
&nbsp;                }
<b class="nc">&nbsp;                try {</b>
<b class="nc">&nbsp;                    if (!_isIntNumber(text)) {</b>
&nbsp;                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
<b class="nc">&nbsp;                            return new BigDecimal(text);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        return new Double(text);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                    if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {
&nbsp;                        return new BigInteger(text);
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    long value = Long.parseLong(text);</b>
<b class="nc">&nbsp;                    if (!ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {</b>
&nbsp;                        if (value &lt;= Integer.MAX_VALUE &amp;&amp; value &gt;= Integer.MIN_VALUE) {
&nbsp;                            return Integer.valueOf((int) value);
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    return Long.valueOf(value);
&nbsp;                } catch (IllegalArgumentException iae) {
<b class="nc">&nbsp;                    return ctxt.handleWeirdStringValue(_valueClass, text,</b>
&nbsp;                            &quot;not a valid number&quot;);
&nbsp;                }
&nbsp;            case JsonTokenId.ID_START_ARRAY:
&nbsp;                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
&nbsp;                    p.nextToken();
&nbsp;                    final Object value = deserialize(p, ctxt);
&nbsp;                    if (p.nextToken() != JsonToken.END_ARRAY) {
&nbsp;                        handleMissingEndArrayForSingle(p, ctxt);
&nbsp;                    }
&nbsp;                    return value;
&nbsp;                }
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            // Otherwise, no can do:</b>
&nbsp;            return ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;        }
&nbsp;
&nbsp;        /**
<b class="nc">&nbsp;         * As mentioned in class Javadoc, there is additional complexity in</b>
&nbsp;         * handling potentially mixed type information here. Because of this,
<b class="nc">&nbsp;         * we must actually check for &quot;raw&quot; integers and doubles first, before</b>
&nbsp;         * calling type deserializer.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
&nbsp;                                          TypeDeserializer typeDeserializer)
&nbsp;            throws IOException
&nbsp;        {
&nbsp;            switch (jp.getCurrentTokenId()) {
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:
&nbsp;            case JsonTokenId.ID_STRING:
&nbsp;                // can not point to type information: hence must be non-typed (int/double)
&nbsp;                return deserialize(jp, ctxt);
&nbsp;            }
&nbsp;            return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
<b class="nc">&nbsp;    /**********************************************************</b>
&nbsp;    /* And then bit more complicated (but non-structured) number
<b class="fc">&nbsp;    /* types</b>
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * This is bit trickier to implement efficiently, while avoiding
<b class="nc">&nbsp;     * overflow problems.</b>
&nbsp;     */
<b class="nc">&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
&nbsp;    @JacksonStdImpl
&nbsp;    public static class BigIntegerDeserializer
&nbsp;        extends StdScalarDeserializer&lt;BigInteger&gt;
<b class="nc">&nbsp;    {</b>
&nbsp;        public final static BigIntegerDeserializer instance = new BigIntegerDeserializer();
<b class="nc">&nbsp;</b>
&nbsp;        public BigIntegerDeserializer() { super(BigInteger.class); }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @SuppressWarnings(&quot;incomplete-switch&quot;)</b>
&nbsp;        @Override
<b class="nc">&nbsp;        public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException</b>
&nbsp;        {
<b class="nc">&nbsp;            switch (p.getCurrentTokenId()) {</b>
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
<b class="nc">&nbsp;                switch (p.getNumberType()) {</b>
<b class="nc">&nbsp;                case INT:</b>
<b class="nc">&nbsp;                case LONG:</b>
&nbsp;                case BIG_INTEGER:
&nbsp;                    return p.getBigIntegerValue();
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                break;</b>
<b class="nc">&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:</b>
&nbsp;                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {
&nbsp;                    _failDoubleToIntCoercion(p, ctxt, &quot;java.math.BigInteger&quot;);
&nbsp;                }
&nbsp;                return p.getDecimalValue().toBigInteger();
<b class="nc">&nbsp;            case JsonTokenId.ID_START_ARRAY:</b>
&nbsp;                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
&nbsp;                    p.nextToken();
&nbsp;                    final BigInteger value = deserialize(p, ctxt);
&nbsp;                    if (p.nextToken() != JsonToken.END_ARRAY) {
&nbsp;                        handleMissingEndArrayForSingle(p, ctxt);
&nbsp;                    }
&nbsp;                    return value;
&nbsp;                }
<b class="nc">&nbsp;                break;</b>
&nbsp;            case JsonTokenId.ID_STRING: // let&#39;s do implicit re-parse
<b class="fc">&nbsp;                String text = p.getText().trim();</b>
&nbsp;                if (text.length() == 0) {
&nbsp;                    return null;
&nbsp;                }
&nbsp;                try {
&nbsp;                    return new BigInteger(text);
<b class="nc">&nbsp;                } catch (IllegalArgumentException iae) {</b>
&nbsp;                    return (BigInteger) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                            &quot;not a valid representation&quot;);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            // String is ok too, can easily convert; otherwise, no can do:</b>
<b class="nc">&nbsp;            return (BigInteger) ctxt.handleUnexpectedToken(_valueClass, p);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;    
<b class="nc">&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc">&nbsp;    @JacksonStdImpl</b>
<b class="nc">&nbsp;    public static class BigDecimalDeserializer</b>
&nbsp;        extends StdScalarDeserializer&lt;BigDecimal&gt;
&nbsp;    {
&nbsp;        public final static BigDecimalDeserializer instance = new BigDecimalDeserializer();
<b class="nc">&nbsp; </b>
&nbsp;        public BigDecimalDeserializer() { super(BigDecimal.class); }
&nbsp;
<b class="nc">&nbsp;        @Override</b>
&nbsp;        public BigDecimal deserialize(JsonParser p, DeserializationContext ctxt)
&nbsp;            throws IOException
&nbsp;        {
&nbsp;            switch (p.getCurrentTokenId()) {
&nbsp;            case JsonTokenId.ID_NUMBER_INT:
&nbsp;            case JsonTokenId.ID_NUMBER_FLOAT:
&nbsp;                return p.getDecimalValue();
&nbsp;            case JsonTokenId.ID_STRING:
&nbsp;                String text = p.getText().trim();
&nbsp;                if (text.length() == 0) {
&nbsp;                    return null;
&nbsp;                }
&nbsp;                try {
&nbsp;                    return new BigDecimal(text);
&nbsp;                } catch (IllegalArgumentException iae) {
&nbsp;                    return (BigDecimal) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                            &quot;not a valid representation&quot;);
&nbsp;                }
&nbsp;            case JsonTokenId.ID_START_ARRAY:
&nbsp;                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
&nbsp;                    p.nextToken();
&nbsp;                    final BigDecimal value = deserialize(p, ctxt);
&nbsp;                    if (p.nextToken() != JsonToken.END_ARRAY) {
&nbsp;                        handleMissingEndArrayForSingle(p, ctxt);
&nbsp;                    }
&nbsp;                    return value;
&nbsp;                }
&nbsp;                break;
&nbsp;            }
&nbsp;            // Otherwise, no can do:
&nbsp;            return (BigDecimal) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 23:30</div>
</div>
</body>
</html>
