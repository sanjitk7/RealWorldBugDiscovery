


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > RepairRunResource</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.cassandrareaper.resources</a>
</div>

<h1>Coverage Summary for Class: RepairRunResource (io.cassandrareaper.resources)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RepairRunResource</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/311)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package io.cassandrareaper.resources;
&nbsp;
&nbsp;import io.cassandrareaper.AppContext;
&nbsp;import io.cassandrareaper.ReaperException;
&nbsp;import io.cassandrareaper.core.Cluster;
&nbsp;import io.cassandrareaper.core.RepairRun;
&nbsp;import io.cassandrareaper.core.RepairRun.RunState;
&nbsp;import io.cassandrareaper.core.RepairSegment;
&nbsp;import io.cassandrareaper.core.RepairUnit;
&nbsp;import io.cassandrareaper.resources.view.RepairRunStatus;
&nbsp;import io.cassandrareaper.service.RepairRunService;
&nbsp;import io.cassandrareaper.service.RepairUnitService;
&nbsp;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URI;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.net.URL;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.validation.ValidationException;
&nbsp;import javax.ws.rs.DELETE;
&nbsp;import javax.ws.rs.GET;
&nbsp;import javax.ws.rs.POST;
&nbsp;import javax.ws.rs.PUT;
&nbsp;import javax.ws.rs.Path;
&nbsp;import javax.ws.rs.PathParam;
&nbsp;import javax.ws.rs.Produces;
&nbsp;import javax.ws.rs.QueryParam;
&nbsp;import javax.ws.rs.core.Context;
&nbsp;import javax.ws.rs.core.MediaType;
&nbsp;import javax.ws.rs.core.Response;
&nbsp;import javax.ws.rs.core.Response.Status;
&nbsp;import javax.ws.rs.core.UriInfo;
&nbsp;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import com.google.common.collect.Sets;
&nbsp;import org.apache.cassandra.repair.RepairParallelism;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;import static com.google.common.base.Preconditions.checkNotNull;
&nbsp;
&nbsp;@Path(&quot;/repair_run&quot;)
&nbsp;@Produces(MediaType.APPLICATION_JSON)
&nbsp;public final class RepairRunResource {
&nbsp;
<b class="nc">&nbsp;  private static final Logger LOG = LoggerFactory.getLogger(RepairRunResource.class);</b>
&nbsp;
&nbsp;  private final AppContext context;
&nbsp;  private final RepairUnitService repairUnitService;
&nbsp;  private final RepairRunService repairRunService;
&nbsp;
<b class="nc">&nbsp;  public RepairRunResource(AppContext context) {</b>
<b class="nc">&nbsp;    this.context = context;</b>
<b class="nc">&nbsp;    this.repairUnitService = RepairUnitService.create(context);</b>
<b class="nc">&nbsp;    this.repairRunService = RepairRunService.create(context);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Endpoint used to create a repair run. Does not allow triggering the run. triggerRepairRun()
&nbsp;   * must be called to initiate the repair. Creating a repair run includes generating the repair
&nbsp;   * segments.
&nbsp;   *
&nbsp;   * &lt;p&gt;Notice that query parameter &quot;tables&quot; can be a single String, or a comma-separated list of
&nbsp;   * table names. If the &quot;tables&quot; parameter is omitted, and only the keyspace is defined, then
&nbsp;   * created repair run will target all the tables in the keyspace.
&nbsp;   *
&nbsp;   * @return repair run ID in case of everything going well, and a status code 500 in case of
&nbsp;   *     errors.
&nbsp;   */
&nbsp;  @POST
&nbsp;  public Response addRepairRun(
&nbsp;      @Context UriInfo uriInfo,
&nbsp;      @QueryParam(&quot;clusterName&quot;) Optional&lt;String&gt; clusterName,
&nbsp;      @QueryParam(&quot;keyspace&quot;) Optional&lt;String&gt; keyspace,
&nbsp;      @QueryParam(&quot;tables&quot;) Optional&lt;String&gt; tableNamesParam,
&nbsp;      @QueryParam(&quot;owner&quot;) Optional&lt;String&gt; owner,
&nbsp;      @QueryParam(&quot;cause&quot;) Optional&lt;String&gt; cause,
&nbsp;      @QueryParam(&quot;segmentCount&quot;) Optional&lt;Integer&gt; segmentCountPerNode,
&nbsp;      @QueryParam(&quot;repairParallelism&quot;) Optional&lt;String&gt; repairParallelism,
&nbsp;      @QueryParam(&quot;intensity&quot;) Optional&lt;String&gt; intensityStr,
&nbsp;      @QueryParam(&quot;incrementalRepair&quot;) Optional&lt;String&gt; incrementalRepairStr,
&nbsp;      @QueryParam(&quot;nodes&quot;) Optional&lt;String&gt; nodesToRepairParam,
&nbsp;      @QueryParam(&quot;datacenters&quot;) Optional&lt;String&gt; datacentersToRepairParam,
&nbsp;      @QueryParam(&quot;blacklistedTables&quot;) Optional&lt;String&gt; blacklistedTableNamesParam) {
&nbsp;
&nbsp;    try {
<b class="nc">&nbsp;      final Response possibleFailedResponse = RepairRunResource.checkRequestForAddRepair(</b>
&nbsp;          context,
&nbsp;          clusterName,
&nbsp;          keyspace,
&nbsp;          owner,
&nbsp;          segmentCountPerNode,
&nbsp;          repairParallelism,
&nbsp;          intensityStr,
&nbsp;          incrementalRepairStr,
&nbsp;          nodesToRepairParam,
&nbsp;          datacentersToRepairParam);
<b class="nc">&nbsp;      if (null != possibleFailedResponse) {</b>
<b class="nc">&nbsp;        return possibleFailedResponse;</b>
&nbsp;      }
&nbsp;
&nbsp;      Double intensity;
<b class="nc">&nbsp;      if (intensityStr.isPresent()) {</b>
<b class="nc">&nbsp;        intensity = Double.parseDouble(intensityStr.get());</b>
&nbsp;      } else {
<b class="nc">&nbsp;        intensity = context.config.getRepairIntensity();</b>
<b class="nc">&nbsp;        LOG.debug(&quot;no intensity given, so using default value: {}&quot;, intensity);</b>
&nbsp;      }
&nbsp;
&nbsp;      Boolean incrementalRepair;
<b class="nc">&nbsp;      if (incrementalRepairStr.isPresent()) {</b>
<b class="nc">&nbsp;        incrementalRepair = Boolean.parseBoolean(incrementalRepairStr.get());</b>
&nbsp;      } else {
<b class="nc">&nbsp;        incrementalRepair = context.config.getIncrementalRepair();</b>
<b class="nc">&nbsp;        LOG.debug(&quot;no incremental repair given, so using default value: {}&quot;, incrementalRepair);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      int segments = context.config.getSegmentCountPerNode();</b>
<b class="nc">&nbsp;      if (!incrementalRepair) {</b>
<b class="nc">&nbsp;        if (segmentCountPerNode.isPresent()) {</b>
<b class="nc">&nbsp;          LOG.debug(</b>
&nbsp;              &quot;using given segment count {} instead of configured value {}&quot;,
<b class="nc">&nbsp;              segmentCountPerNode.get(),</b>
<b class="nc">&nbsp;              context.config.getSegmentCount());</b>
<b class="nc">&nbsp;          segments = segmentCountPerNode.get();</b>
&nbsp;        }
&nbsp;      } else {
&nbsp;        // hijack the segment count in case of incremental repair
<b class="nc">&nbsp;        segments = -1;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      final Cluster cluster = context.storage.getCluster(Cluster.toSymbolicName(clusterName.get())).get();</b>
&nbsp;      Set&lt;String&gt; tableNames;
&nbsp;      try {
<b class="nc">&nbsp;        tableNames = repairRunService.getTableNamesBasedOnParam(cluster, keyspace.get(), tableNamesParam);</b>
<b class="nc">&nbsp;      } catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;        LOG.error(ex.getMessage(), ex);</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.NOT_FOUND).entity(ex.getMessage()).build();</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
&nbsp;      Set&lt;String&gt; blacklistedTableNames;
&nbsp;      try {
<b class="nc">&nbsp;        blacklistedTableNames</b>
<b class="nc">&nbsp;            = repairRunService.getTableNamesBasedOnParam(cluster, keyspace.get(), blacklistedTableNamesParam);</b>
<b class="nc">&nbsp;      } catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;        LOG.error(ex.getMessage(), ex);</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.NOT_FOUND).entity(ex.getMessage()).build();</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
&nbsp;      final Set&lt;String&gt; nodesToRepair;
&nbsp;      try {
<b class="nc">&nbsp;        nodesToRepair = repairRunService.getNodesToRepairBasedOnParam(cluster, nodesToRepairParam);</b>
<b class="nc">&nbsp;      } catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;        LOG.error(ex.getMessage(), ex);</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.NOT_FOUND).entity(ex.getMessage()).build();</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
&nbsp;      final Set&lt;String&gt; datacentersToRepair;
&nbsp;      try {
<b class="nc">&nbsp;        datacentersToRepair = RepairRunService</b>
<b class="nc">&nbsp;            .getDatacentersToRepairBasedOnParam(cluster, datacentersToRepairParam);</b>
&nbsp;
<b class="nc">&nbsp;      } catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;        LOG.error(ex.getMessage(), ex);</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.NOT_FOUND).entity(ex.getMessage()).build();</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      final RepairUnit theRepairUnit =</b>
<b class="nc">&nbsp;          repairUnitService.getNewOrExistingRepairUnit(</b>
&nbsp;              cluster,
<b class="nc">&nbsp;              keyspace.get(),</b>
&nbsp;              tableNames,
&nbsp;              incrementalRepair,
&nbsp;              nodesToRepair,
&nbsp;              datacentersToRepair,
&nbsp;              blacklistedTableNames);
&nbsp;
<b class="nc">&nbsp;      if (theRepairUnit.getIncrementalRepair().booleanValue() != incrementalRepair) {</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.BAD_REQUEST)</b>
<b class="nc">&nbsp;            .entity(</b>
&nbsp;                &quot;A repair run already exist for the same cluster/keyspace/table&quot;
&nbsp;                + &quot; but with a different incremental repair value. Requested value: &quot;
&nbsp;                + incrementalRepair
&nbsp;                + &quot; | Existing value: &quot;
<b class="nc">&nbsp;                + theRepairUnit.getIncrementalRepair())</b>
<b class="nc">&nbsp;            .build();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      RepairParallelism parallelism = context.config.getRepairParallelism();</b>
<b class="nc">&nbsp;      if (repairParallelism.isPresent()) {</b>
<b class="nc">&nbsp;        LOG.debug(</b>
&nbsp;            &quot;using given repair parallelism {} instead of configured value {}&quot;,
<b class="nc">&nbsp;            repairParallelism.get(),</b>
<b class="nc">&nbsp;            context.config.getRepairParallelism());</b>
&nbsp;
<b class="nc">&nbsp;        parallelism = RepairParallelism.valueOf(repairParallelism.get().toUpperCase());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (incrementalRepair) {</b>
<b class="nc">&nbsp;        parallelism = RepairParallelism.PARALLEL;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      final RepairRun newRepairRun =</b>
<b class="nc">&nbsp;          repairRunService.registerRepairRun(</b>
&nbsp;              cluster,
&nbsp;              theRepairUnit,
&nbsp;              cause,
<b class="nc">&nbsp;              owner.get(),</b>
&nbsp;              0,
&nbsp;              segments,
&nbsp;              parallelism,
&nbsp;              intensity);
&nbsp;
<b class="nc">&nbsp;      return Response.created(buildRepairRunUri(uriInfo, newRepairRun))</b>
<b class="nc">&nbsp;          .entity(new RepairRunStatus(newRepairRun, theRepairUnit, 0))</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;
<b class="nc">&nbsp;    } catch (ReaperException e) {</b>
<b class="nc">&nbsp;      LOG.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;      return Response.status(500).entity(e.getMessage()).build();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return Response instance in case there is a problem, or null if everything is ok.
&nbsp;   */
&nbsp;  @Nullable
&nbsp;  static Response checkRequestForAddRepair(
&nbsp;      AppContext context,
&nbsp;      Optional&lt;String&gt; clusterName,
&nbsp;      Optional&lt;String&gt; keyspace,
&nbsp;      Optional&lt;String&gt; owner,
&nbsp;      Optional&lt;Integer&gt; segmentCountPerNode,
&nbsp;      Optional&lt;String&gt; repairParallelism,
&nbsp;      Optional&lt;String&gt; intensityStr,
&nbsp;      Optional&lt;String&gt; incrementalRepairStr,
&nbsp;      Optional&lt;String&gt; nodesStr,
&nbsp;      Optional&lt;String&gt; datacentersStr) {
&nbsp;
<b class="nc">&nbsp;    if (!clusterName.isPresent()) {</b>
<b class="nc">&nbsp;      return createMissingArgumentResponse(&quot;clusterName&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (!keyspace.isPresent()) {</b>
<b class="nc">&nbsp;      return createMissingArgumentResponse(&quot;keyspace&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (!owner.isPresent()) {</b>
<b class="nc">&nbsp;      return createMissingArgumentResponse(&quot;owner&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (segmentCountPerNode.isPresent()</b>
<b class="nc">&nbsp;        &amp;&amp; (segmentCountPerNode.get() &lt; 0 || segmentCountPerNode.get() &gt; 1000)) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.BAD_REQUEST)</b>
<b class="nc">&nbsp;          .entity(&quot;invalid query parameter \&quot;segmentCountPerNode\&quot;, maximum value is 100000&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
<b class="nc">&nbsp;    if (repairParallelism.isPresent()) {</b>
&nbsp;      try {
<b class="nc">&nbsp;        checkRepairParallelismString(repairParallelism.get());</b>
<b class="nc">&nbsp;      } catch (ReaperException ex) {</b>
<b class="nc">&nbsp;        LOG.error(ex.getMessage(), ex);</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.BAD_REQUEST).entity(ex.getMessage()).build();</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (intensityStr.isPresent()) {</b>
&nbsp;      try {
&nbsp;        // @todo all BAD_REQUEST responses should be instead thrown ValidationExceptions, so this method returns void
<b class="nc">&nbsp;        parseIntensity(intensityStr.get());</b>
<b class="nc">&nbsp;      } catch (ValidationException ex) {</b>
<b class="nc">&nbsp;        return Response.status(Status.BAD_REQUEST).entity(ex.getMessage()).build();</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (incrementalRepairStr.isPresent()</b>
<b class="nc">&nbsp;        &amp;&amp; (!incrementalRepairStr.get().toUpperCase().contentEquals(&quot;TRUE&quot;)</b>
<b class="nc">&nbsp;        &amp;&amp; !incrementalRepairStr.get().toUpperCase().contentEquals(&quot;FALSE&quot;))) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.BAD_REQUEST)</b>
<b class="nc">&nbsp;          .entity(&quot;invalid query parameter \&quot;incrementalRepair\&quot;, expecting [True,False]&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
<b class="nc">&nbsp;    final Optional&lt;Cluster&gt; cluster = context.storage.getCluster(Cluster.toSymbolicName(clusterName.get()));</b>
<b class="nc">&nbsp;    if (!cluster.isPresent()) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.NOT_FOUND)</b>
<b class="nc">&nbsp;          .entity(&quot;No cluster found with name \&quot;&quot; + clusterName.get() + &quot;\&quot;, did you register your cluster first?&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (!datacentersStr.or(&quot;&quot;).isEmpty() &amp;&amp; !nodesStr.or(&quot;&quot;).isEmpty()) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.BAD_REQUEST)</b>
<b class="nc">&nbsp;          .entity(</b>
&nbsp;              &quot;Parameters \&quot;datacenters\&quot; and \&quot;nodes\&quot; are mutually exclusive. Please fill just one between the two.&quot;)
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Modifies a state of the repair run.
&nbsp;   *
&nbsp;   * &lt;p&gt;
&nbsp;   * Currently supports NOT_STARTED|PAUSED -&gt; RUNNING and RUNNING -&gt; PAUSED.
&nbsp;   *
&nbsp;   * @return OK if all goes well NOT_MODIFIED if new state is the same as the old one, and 501 (NOT_IMPLEMENTED) if
&nbsp;   *        transition is not supported.
&nbsp;   */
&nbsp;  @PUT
&nbsp;  @Path(&quot;/{id}/state/{state}&quot;)
&nbsp;  public Response modifyRunState(
&nbsp;      @Context UriInfo uriInfo,
&nbsp;      @PathParam(&quot;id&quot;) UUID repairRunId,
&nbsp;      @PathParam(&quot;state&quot;) Optional&lt;String&gt; stateStr)
&nbsp;      throws ReaperException {
&nbsp;
<b class="nc">&nbsp;    LOG.info(&quot;modify repair run state called with: id = {}, state = {}&quot;, repairRunId, stateStr);</b>
&nbsp;    try {
<b class="nc">&nbsp;      if (!stateStr.isPresent()) {</b>
<b class="nc">&nbsp;        return createMissingArgumentResponse(&quot;state&quot;);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      Optional&lt;RepairRun&gt; repairRun = context.storage.getRepairRun(repairRunId);</b>
<b class="nc">&nbsp;      if (!repairRun.isPresent()) {</b>
<b class="nc">&nbsp;        return Response.status(Status.NOT_FOUND).entity(&quot;repair run &quot; + repairRunId + &quot; doesn&#39;t exist&quot;).build();</b>
&nbsp;      }
<b class="nc">&nbsp;      final RepairRun.RunState newState = parseRunState(stateStr.get());</b>
&nbsp;
<b class="nc">&nbsp;      Optional&lt;RepairUnit&gt; repairUnit = context.storage.getRepairUnit(repairRun.get().getRepairUnitId());</b>
<b class="nc">&nbsp;      if (!repairUnit.isPresent()) {</b>
<b class="nc">&nbsp;        String errMsg = &quot;repair unit with id &quot; + repairRun.get().getRepairUnitId() + &quot; not found&quot;;</b>
<b class="nc">&nbsp;        LOG.error(errMsg);</b>
<b class="nc">&nbsp;        return Response.status(Status.CONFLICT).entity(errMsg).build();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (isUnitAlreadyRepairing(repairRun.get())) {</b>
<b class="nc">&nbsp;        String errMsg = &quot;repair unit already has run &quot; + repairRun.get().getRepairUnitId() + &quot; in RUNNING state&quot;;</b>
<b class="nc">&nbsp;        LOG.error(errMsg);</b>
<b class="nc">&nbsp;        return Response.status(Status.CONFLICT).entity(errMsg).build();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      final RunState oldState = repairRun.get().getRunState();</b>
<b class="nc">&nbsp;      if (oldState == newState) {</b>
<b class="nc">&nbsp;        String msg = &quot;given \&quot;state\&quot; &quot; + stateStr + &quot; is same as the current run state&quot;;</b>
<b class="nc">&nbsp;        return Response.status(Status.NOT_MODIFIED).entity(msg).build();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      int segmentsRepaired = getSegmentAmountForRepairRun(repairRunId);</b>
<b class="nc">&nbsp;      if (isStarting(oldState, newState)) {</b>
<b class="nc">&nbsp;        return startRun(repairRun.get(), repairUnit.get(), segmentsRepaired);</b>
<b class="nc">&nbsp;      } else if (isPausing(oldState, newState)) {</b>
<b class="nc">&nbsp;        return pauseRun(repairRun.get(), repairUnit.get(), segmentsRepaired);</b>
<b class="nc">&nbsp;      } else if (isResuming(oldState, newState) || isRetrying(oldState, newState)) {</b>
<b class="nc">&nbsp;        return resumeRun(repairRun.get(), repairUnit.get(), segmentsRepaired);</b>
<b class="nc">&nbsp;      } else if (isAborting(oldState, newState)) {</b>
<b class="nc">&nbsp;        return abortRun(repairRun.get(), repairUnit.get(), segmentsRepaired);</b>
&nbsp;      } else {
<b class="nc">&nbsp;        String errMsg = String.format(&quot;Transition %s-&gt;%s not supported.&quot;, oldState.toString(), newState.toString());</b>
<b class="nc">&nbsp;        LOG.error(errMsg);</b>
<b class="nc">&nbsp;        return Response.status(Status.METHOD_NOT_ALLOWED).entity(errMsg).build();</b>
&nbsp;      }
<b class="nc">&nbsp;    } catch (ValidationException ex) {</b>
<b class="nc">&nbsp;      return Response.status(Status.BAD_REQUEST).entity(ex.getMessage()).build();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Modifies a state of the repair run.
&nbsp;   *
&nbsp;   * &lt;p&gt;
&nbsp;   * Currently supports NOT_STARTED|PAUSED -&gt; RUNNING and RUNNING -&gt; PAUSED.
&nbsp;   *
&nbsp;   * @return OK if all goes well NOT_MODIFIED if new state is the same as the old one, and 501 (NOT_IMPLEMENTED) if
&nbsp;   *        transition is not supported.
&nbsp;   */
&nbsp;  @PUT
&nbsp;  @Path(&quot;/{id}/intensity/{intensity}&quot;)
&nbsp;  public Response modifyRunIntensity(
&nbsp;      @Context UriInfo uriInfo,
&nbsp;      @PathParam(&quot;id&quot;) UUID repairRunId,
&nbsp;      @PathParam(&quot;intensity&quot;) Optional&lt;String&gt; intensityStr) throws ReaperException {
&nbsp;
<b class="nc">&nbsp;    LOG.info(&quot;modify repair run intensity called with: id = {}, state = {}&quot;, repairRunId, intensityStr);</b>
&nbsp;    try {
<b class="nc">&nbsp;      if (!intensityStr.isPresent()) {</b>
<b class="nc">&nbsp;        return createMissingArgumentResponse(&quot;intensity&quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      final double intensity = parseIntensity(intensityStr.get());</b>
&nbsp;
<b class="nc">&nbsp;      Optional&lt;RepairRun&gt; repairRun = context.storage.getRepairRun(repairRunId);</b>
<b class="nc">&nbsp;      if (!repairRun.isPresent()) {</b>
<b class="nc">&nbsp;        return Response.status(Status.NOT_FOUND).entity(&quot;repair run &quot; + repairRunId + &quot; doesn&#39;t exist&quot;).build();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      Optional&lt;RepairUnit&gt; repairUnit = context.storage.getRepairUnit(repairRun.get().getRepairUnitId());</b>
<b class="nc">&nbsp;      if (!repairUnit.isPresent()) {</b>
<b class="nc">&nbsp;        String errMsg = &quot;repair unit with id &quot; + repairRun.get().getRepairUnitId() + &quot; not found&quot;;</b>
<b class="nc">&nbsp;        LOG.error(errMsg);</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.NOT_FOUND).entity(errMsg).build();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (RunState.PAUSED != repairRun.get().getRunState()) {</b>
<b class="nc">&nbsp;        return Response.status(Status.CONFLICT).entity(&quot;repair run must first be paused&quot;).build();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      int segmentsRepaired = getSegmentAmountForRepairRun(repairRunId);</b>
<b class="nc">&nbsp;      return updateRunIntensity(repairRun.get(), repairUnit.get(), segmentsRepaired, intensity);</b>
<b class="nc">&nbsp;    } catch (ValidationException ex) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.BAD_REQUEST).entity(ex.getMessage()).build();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * MOVED_PERMANENTLY to PUT repair_run/{id}/state/{state}
&nbsp;   */
&nbsp;  @PUT
&nbsp;  @Path(&quot;/{id}&quot;)
&nbsp;  @Deprecated
&nbsp;  public Response oldModifyRunState(
&nbsp;      @Context UriInfo uriInfo,
&nbsp;      @PathParam(&quot;id&quot;) UUID repairRunId,
&nbsp;      @QueryParam(&quot;state&quot;) Optional&lt;String&gt; stateStr)
&nbsp;      throws ReaperException {
&nbsp;
&nbsp;    try {
<b class="nc">&nbsp;      if (!stateStr.isPresent()) {</b>
<b class="nc">&nbsp;        return createMissingArgumentResponse(&quot;state&quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      RepairRun.RunState state = parseRunState(stateStr.get());</b>
&nbsp;
<b class="nc">&nbsp;      Optional&lt;RepairRun&gt; repairRun = context.storage.getRepairRun(repairRunId);</b>
<b class="nc">&nbsp;      if (!repairRun.isPresent()) {</b>
<b class="nc">&nbsp;        return Response.status(Status.NOT_FOUND).entity(&quot;repair run &quot; + repairRunId + &quot; doesn&#39;t exist&quot;).build();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      URI redirectUri = uriInfo</b>
<b class="nc">&nbsp;          .getRequestUriBuilder()</b>
<b class="nc">&nbsp;          .replacePath(String.format(&quot;repair_run/%s/state/%s&quot;, repairRun.get().getId().toString(), state))</b>
<b class="nc">&nbsp;          .replaceQuery(&quot;&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;
<b class="nc">&nbsp;      return Response.seeOther(redirectUri).build();</b>
<b class="nc">&nbsp;    } catch (ValidationException ex) {</b>
<b class="nc">&nbsp;      return Response.status(Status.BAD_REQUEST).entity(ex.getMessage()).build();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isStarting(RepairRun.RunState oldState, RepairRun.RunState newState) {
<b class="nc">&nbsp;    return oldState == RepairRun.RunState.NOT_STARTED &amp;&amp; newState == RepairRun.RunState.RUNNING;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isPausing(RepairRun.RunState oldState, RepairRun.RunState newState) {
<b class="nc">&nbsp;    return oldState == RepairRun.RunState.RUNNING &amp;&amp; newState == RepairRun.RunState.PAUSED;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isResuming(RepairRun.RunState oldState, RepairRun.RunState newState) {
<b class="nc">&nbsp;    return oldState == RepairRun.RunState.PAUSED &amp;&amp; newState == RepairRun.RunState.RUNNING;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isRetrying(RepairRun.RunState oldState, RepairRun.RunState newState) {
<b class="nc">&nbsp;    return oldState == RepairRun.RunState.ERROR &amp;&amp; newState == RepairRun.RunState.RUNNING;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isAborting(RepairRun.RunState oldState, RepairRun.RunState newState) {
<b class="nc">&nbsp;    return oldState != RepairRun.RunState.ERROR &amp;&amp; newState == RepairRun.RunState.ABORTED;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isUnitAlreadyRepairing(RepairRun repairRun) {
<b class="nc">&nbsp;    return context.storage.getRepairRunsForUnit(repairRun.getRepairUnitId()).stream()</b>
<b class="nc">&nbsp;        .anyMatch((run) -&gt; (!run.getId().equals(repairRun.getId()) &amp;&amp; run.getRunState().equals(RunState.RUNNING)));</b>
&nbsp;  }
&nbsp;
&nbsp;  private int getSegmentAmountForRepairRun(UUID repairRunId) {
<b class="nc">&nbsp;    return context.storage.getSegmentAmountForRepairRunWithState(repairRunId, RepairSegment.State.DONE);</b>
&nbsp;  }
&nbsp;
&nbsp;  private Response startRun(RepairRun repairRun, RepairUnit repairUnit, int segmentsRepaired) throws ReaperException {
<b class="nc">&nbsp;    LOG.info(&quot;Starting run {}&quot;, repairRun.getId());</b>
<b class="nc">&nbsp;    final RepairRun newRun = context.repairManager.startRepairRun(repairRun);</b>
<b class="nc">&nbsp;    return Response.status(Response.Status.OK)</b>
<b class="nc">&nbsp;        .entity(new RepairRunStatus(newRun, repairUnit, segmentsRepaired))</b>
<b class="nc">&nbsp;        .build();</b>
&nbsp;  }
&nbsp;
&nbsp;  private Response pauseRun(RepairRun repairRun, RepairUnit repairUnit, int segmentsRepaired) throws ReaperException {
<b class="nc">&nbsp;    LOG.info(&quot;Pausing run {}&quot;, repairRun.getId());</b>
<b class="nc">&nbsp;    final RepairRun newRun = context.repairManager.pauseRepairRun(repairRun);</b>
<b class="nc">&nbsp;    return Response.ok().entity(new RepairRunStatus(newRun, repairUnit, segmentsRepaired)).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  private Response resumeRun(RepairRun repairRun, RepairUnit repairUnit, int segmentsRepaired) throws ReaperException {
<b class="nc">&nbsp;    LOG.info(&quot;Resuming run {}&quot;, repairRun.getId());</b>
<b class="nc">&nbsp;    final RepairRun newRun = context.repairManager.startRepairRun(repairRun);</b>
<b class="nc">&nbsp;    return Response.ok().entity(new RepairRunStatus(newRun, repairUnit, segmentsRepaired)).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  private Response abortRun(RepairRun repairRun, RepairUnit repairUnit, int segmentsRepaired) throws ReaperException {
<b class="nc">&nbsp;    LOG.info(&quot;Aborting run {}&quot;, repairRun.getId());</b>
<b class="nc">&nbsp;    final RepairRun newRun = context.repairManager.abortRepairRun(repairRun);</b>
<b class="nc">&nbsp;    return Response.ok().entity(new RepairRunStatus(newRun, repairUnit, segmentsRepaired)).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  private Response updateRunIntensity(RepairRun run, RepairUnit unit, int repaired, double intensity)
&nbsp;      throws ReaperException {
&nbsp;
<b class="nc">&nbsp;    LOG.info(&quot;Editing run {}&quot;, run.getId());</b>
<b class="nc">&nbsp;    RepairRun newRun = context.repairManager.updateRepairRunIntensity(run, intensity);</b>
<b class="nc">&nbsp;    return Response.ok().entity(new RepairRunStatus(newRun, unit, repaired)).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return detailed information about a repair run.
&nbsp;   */
&nbsp;  @GET
&nbsp;  @Path(&quot;/{id}&quot;)
&nbsp;  public Response getRepairRun(
&nbsp;      @PathParam(&quot;id&quot;) UUID repairRunId) {
&nbsp;
<b class="nc">&nbsp;    LOG.debug(&quot;get repair_run called with: id = {}&quot;, repairRunId);</b>
<b class="nc">&nbsp;    final Optional&lt;RepairRun&gt; repairRun = context.storage.getRepairRun(repairRunId);</b>
<b class="nc">&nbsp;    if (repairRun.isPresent()) {</b>
<b class="nc">&nbsp;      RepairRunStatus repairRunStatus = getRepairRunStatus(repairRun.get());</b>
<b class="nc">&nbsp;      return Response.ok().entity(repairRunStatus).build();</b>
&nbsp;    } else {
<b class="nc">&nbsp;      return Response.status(404).entity(&quot;repair run with id &quot; + repairRunId + &quot; doesn&#39;t exist&quot;).build();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return all know repair runs for a cluster.
&nbsp;   */
&nbsp;  @GET
&nbsp;  @Path(&quot;/cluster/{cluster_name}&quot;)
&nbsp;  public Response getRepairRunsForCluster(
&nbsp;      @PathParam(&quot;cluster_name&quot;) String clusterName) {
&nbsp;
<b class="nc">&nbsp;    LOG.debug(&quot;get repair run for cluster called with: cluster_name = {}&quot;, clusterName);</b>
<b class="nc">&nbsp;    final Collection&lt;RepairRun&gt; repairRuns = context.storage.getRepairRunsForCluster(clusterName);</b>
<b class="nc">&nbsp;    final Collection&lt;RepairRunStatus&gt; repairRunViews = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    for (final RepairRun repairRun : repairRuns) {</b>
<b class="nc">&nbsp;      repairRunViews.add(getRepairRunStatus(repairRun));</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return Response.ok().entity(repairRunViews).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return only a status of a repair run, not the entire repair run info.
&nbsp;   */
&nbsp;  private RepairRunStatus getRepairRunStatus(RepairRun repairRun) {
<b class="nc">&nbsp;    final Optional&lt;RepairUnit&gt; repairUnit = context.storage.getRepairUnit(repairRun.getRepairUnitId());</b>
<b class="nc">&nbsp;    Preconditions.checkState(repairUnit.isPresent(), &quot;no repair unit found with id: %s&quot;, repairRun.getRepairUnitId());</b>
<b class="nc">&nbsp;    final int segmentsRepaired = getSegmentAmountForRepairRun(repairRun.getId());</b>
<b class="nc">&nbsp;    return new RepairRunStatus(repairRun, repairUnit.get(), segmentsRepaired);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Crafts an URI used to identify given repair run.
&nbsp;   *
&nbsp;   * @return The created resource URI.
&nbsp;   */
&nbsp;  private URI buildRepairRunUri(UriInfo uriInfo, RepairRun repairRun) {
<b class="nc">&nbsp;    final String newRepairRunPathPart = &quot;repair_run/&quot; + repairRun.getId();</b>
<b class="nc">&nbsp;    URI runUri = null;</b>
&nbsp;    try {
<b class="nc">&nbsp;      runUri = new URL(uriInfo.getBaseUri().toURL(), newRepairRunPathPart).toURI();</b>
<b class="nc">&nbsp;    } catch (MalformedURLException | URISyntaxException e) {</b>
<b class="nc">&nbsp;      LOG.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    checkNotNull(runUri, &quot;failed to build repair run uri&quot;);</b>
<b class="nc">&nbsp;    return runUri;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @param state comma-separated list of states to return. These states must match names of {@link
&nbsp;   *     io.cassandrareaper.core.RepairRun.RunState}.
&nbsp;   * @return All repair runs in the system if the param is absent, repair runs with state included in the state
&nbsp;   *       parameter otherwise.
&nbsp;   *        If the state parameter contains non-existing run states, BAD_REQUEST response is returned.
&nbsp;   */
&nbsp;  @GET
&nbsp;  public Response listRepairRuns(
&nbsp;      @QueryParam(&quot;state&quot;) Optional&lt;String&gt; state) {
&nbsp;
&nbsp;    try {
<b class="nc">&nbsp;      final List&lt;RepairRunStatus&gt; runStatuses = Lists.newArrayList();</b>
<b class="nc">&nbsp;      final Set desiredStates = splitStateParam(state);</b>
<b class="nc">&nbsp;      if (desiredStates == null) {</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.BAD_REQUEST).build();</b>
&nbsp;      }
&nbsp;      Collection&lt;RepairRun&gt; runs;
&nbsp;
<b class="nc">&nbsp;      final Collection&lt;Cluster&gt; clusters = context.storage.getClusters();</b>
<b class="nc">&nbsp;      for (final Cluster cluster : clusters) {</b>
<b class="nc">&nbsp;        runs = context.storage.getRepairRunsForCluster(cluster.getName());</b>
<b class="nc">&nbsp;        runStatuses.addAll(getRunStatuses(runs, desiredStates));</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return Response.status(Response.Status.OK).entity(runStatuses).build();</b>
<b class="nc">&nbsp;    } catch (ReaperException e) {</b>
<b class="nc">&nbsp;      LOG.error(&quot;Failed listing cluster statuses&quot;, e);</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;RepairRunStatus&gt; getRunStatuses(Collection&lt;RepairRun&gt; runs, Set desiredStates) throws ReaperException {
<b class="nc">&nbsp;    final List&lt;RepairRunStatus&gt; runStatuses = Lists.newArrayList();</b>
<b class="nc">&nbsp;    for (final RepairRun run : runs) {</b>
<b class="nc">&nbsp;      if (!desiredStates.isEmpty() &amp;&amp; !desiredStates.contains(run.getRunState().name())) {</b>
<b class="nc">&nbsp;        continue;</b>
&nbsp;      }
<b class="nc">&nbsp;      final Optional&lt;RepairUnit&gt; runsUnit = context.storage.getRepairUnit(run.getRepairUnitId());</b>
<b class="nc">&nbsp;      if (runsUnit.isPresent()) {</b>
<b class="nc">&nbsp;        int segmentsRepaired = run.getSegmentCount();</b>
<b class="nc">&nbsp;        if (!run.getRunState().equals(RepairRun.RunState.DONE)) {</b>
<b class="nc">&nbsp;          segmentsRepaired = getSegmentAmountForRepairRun(run.getId());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        runStatuses.add(new RepairRunStatus(run, runsUnit.get(), segmentsRepaired));</b>
<b class="nc">&nbsp;      } else {</b>
<b class="nc">&nbsp;        final String errMsg = String.format(&quot;Found repair run %s with no associated repair unit&quot;, run.getId());</b>
<b class="nc">&nbsp;        LOG.error(errMsg);</b>
<b class="nc">&nbsp;        throw new ReaperException(&quot;Internal server error : &quot; + errMsg);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    return runStatuses;</b>
&nbsp;  }
&nbsp;
&nbsp;  static Set splitStateParam(Optional&lt;String&gt; state) {
<b class="nc">&nbsp;    if (state.isPresent()) {</b>
<b class="nc">&nbsp;      final Iterable&lt;String&gt; chunks = RepairRunService.COMMA_SEPARATED_LIST_SPLITTER.split(state.get());</b>
<b class="nc">&nbsp;      for (final String chunk : chunks) {</b>
&nbsp;        try {
<b class="nc">&nbsp;          RepairRun.RunState.valueOf(chunk.toUpperCase());</b>
<b class="nc">&nbsp;        } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;          LOG.warn(&quot;Listing repair runs called with erroneous states: {}&quot;, state.get(), e);</b>
<b class="nc">&nbsp;          return null;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return Sets.newHashSet(chunks);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      return Sets.newHashSet();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Delete a RepairRun object with given id.
&nbsp;   *
&nbsp;   * &lt;p&gt;
&nbsp;   * Repair run can be only deleted when it is not running. When Repair run is deleted, all the related RepairSegmen
&nbsp;   * instances will be deleted also.
&nbsp;   *
&nbsp;   * @param runId The id for the RepairRun instance to delete.
&nbsp;   * @param owner The assigned owner of the deleted resource. Must match the stored one.
&nbsp;   * @return The deleted RepairRun instance, with state overwritten to string &quot;DELETED&quot;.
&nbsp;   */
&nbsp;  @DELETE
&nbsp;  @Path(&quot;/{id}&quot;)
&nbsp;  public Response deleteRepairRun(
&nbsp;      @PathParam(&quot;id&quot;) UUID runId,
&nbsp;      @QueryParam(&quot;owner&quot;) Optional&lt;String&gt; owner) {
&nbsp;
<b class="nc">&nbsp;    LOG.info(&quot;delete repair run called with runId: {}, and owner: {}&quot;, runId, owner);</b>
<b class="nc">&nbsp;    if (!owner.isPresent()) {</b>
<b class="nc">&nbsp;      return Response.status(Response.Status.BAD_REQUEST)</b>
<b class="nc">&nbsp;          .entity(&quot;required query parameter \&quot;owner\&quot; is missing&quot;)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
<b class="nc">&nbsp;    final Optional&lt;RepairRun&gt; runToDelete = context.storage.getRepairRun(runId);</b>
<b class="nc">&nbsp;    if (runToDelete.isPresent()) {</b>
<b class="nc">&nbsp;      if (runToDelete.get().getRunState() == RepairRun.RunState.RUNNING) {</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.FORBIDDEN)</b>
<b class="nc">&nbsp;            .entity(&quot;Repair run with id \&quot;&quot; + runId + &quot;\&quot; is currently running, and must be stopped before deleting&quot;)</b>
<b class="nc">&nbsp;            .build();</b>
&nbsp;      }
<b class="nc">&nbsp;      if (!runToDelete.get().getOwner().equalsIgnoreCase(owner.get())) {</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.FORBIDDEN)</b>
<b class="nc">&nbsp;            .entity(&quot;Repair run with id \&quot;&quot; + runId + &quot;\&quot; is not owned by the user you defined: &quot; + owner.get())</b>
<b class="nc">&nbsp;            .build();</b>
&nbsp;      }
<b class="nc">&nbsp;      if (context.storage.getSegmentAmountForRepairRunWithState(runId, RepairSegment.State.RUNNING) &gt; 0) {</b>
<b class="nc">&nbsp;        return Response.status(Response.Status.FORBIDDEN)</b>
<b class="nc">&nbsp;            .entity(</b>
&nbsp;                &quot;Repair run with id \&quot;&quot;
&nbsp;                + runId
&nbsp;                + &quot;\&quot; has a running segment, which must be waited to finish before deleting&quot;)
<b class="nc">&nbsp;            .build();</b>
&nbsp;      }
&nbsp;      // Need to get the RepairUnit before it&#39;s possibly deleted.
<b class="nc">&nbsp;      final Optional&lt;RepairUnit&gt; unitPossiblyDeleted</b>
<b class="nc">&nbsp;          = context.storage.getRepairUnit(runToDelete.get().getRepairUnitId());</b>
&nbsp;
<b class="nc">&nbsp;      final int segmentsRepaired = getSegmentAmountForRepairRun(runId);</b>
<b class="nc">&nbsp;      final Optional&lt;RepairRun&gt; deletedRun = context.storage.deleteRepairRun(runId);</b>
<b class="nc">&nbsp;      if (deletedRun.isPresent()) {</b>
<b class="nc">&nbsp;        final RepairRunStatus repairRunStatus</b>
<b class="nc">&nbsp;            = new RepairRunStatus(deletedRun.get(), unitPossiblyDeleted.get(), segmentsRepaired);</b>
&nbsp;
<b class="nc">&nbsp;        return Response.ok().entity(repairRunStatus).build();</b>
&nbsp;      }
&nbsp;    }
&nbsp;    try {
&nbsp;      // safety clean, in case of zombie segments
<b class="nc">&nbsp;      context.storage.deleteRepairRun(runId);</b>
<b class="nc">&nbsp;    } catch (RuntimeException ignore) { }</b>
<b class="nc">&nbsp;    return Response.status(Response.Status.NOT_FOUND).entity(&quot;Repair run with id \&quot;&quot; + runId + &quot;\&quot; not found&quot;).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void checkRepairParallelismString(String repairParallelism) throws ReaperException {
&nbsp;    try {
<b class="nc">&nbsp;      RepairParallelism.valueOf(repairParallelism.toUpperCase());</b>
<b class="nc">&nbsp;    } catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;      throw new ReaperException(</b>
&nbsp;          &quot;invalid repair parallelism given \&quot;&quot;
&nbsp;          + repairParallelism
&nbsp;          + &quot;\&quot;, must be one of: &quot;
<b class="nc">&nbsp;          + Arrays.toString(RepairParallelism.values()),</b>
&nbsp;          ex);
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private static Response createMissingArgumentResponse(String argumentName) {
<b class="nc">&nbsp;    return Response.status(Status.BAD_REQUEST).entity(argumentName + &quot; argument missing&quot;).build();</b>
&nbsp;  }
&nbsp;
&nbsp;  private static RunState parseRunState(String input) throws ValidationException {
&nbsp;    try {
<b class="nc">&nbsp;      return RunState.valueOf(input.toUpperCase());</b>
<b class="nc">&nbsp;    } catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;invalid \&quot;state\&quot; argument: &quot; + input, ex);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static double parseIntensity(String input) throws ValidationException {
&nbsp;    try {
<b class="nc">&nbsp;      double intensity = Double.parseDouble(input);</b>
<b class="nc">&nbsp;      if (intensity &lt;= 0.0 || intensity &gt; 1.0) {</b>
<b class="nc">&nbsp;        throw new ValidationException(&quot;query parameter \&quot;intensity\&quot; must be in range (0.0, 1.0]: &quot; + input);</b>
&nbsp;      }
<b class="nc">&nbsp;      return intensity;</b>
<b class="nc">&nbsp;    } catch (NumberFormatException ex) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;invalid value for query parameter \&quot;intensity\&quot;: &quot; + input, ex);</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-02 20:50</div>
</div>
</body>
</html>
