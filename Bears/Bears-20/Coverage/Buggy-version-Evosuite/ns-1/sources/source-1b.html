


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > StdDeserializer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.deser.std</a>
</div>

<h1>Coverage Summary for Class: StdDeserializer (com.fasterxml.jackson.databind.deser.std)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StdDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.7%
  </span>
  <span class="absValue">
    (2/43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.3%
  </span>
  <span class="absValue">
    (6/461)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.deser.std;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import com.fasterxml.jackson.annotation.JsonFormat;
&nbsp;import com.fasterxml.jackson.core.*;
&nbsp;import com.fasterxml.jackson.core.JsonParser.NumberType;
&nbsp;import com.fasterxml.jackson.core.io.NumberInput;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
&nbsp;import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
&nbsp;import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
&nbsp;import com.fasterxml.jackson.databind.util.ClassUtil;
&nbsp;import com.fasterxml.jackson.databind.util.Converter;
&nbsp;
&nbsp;/**
&nbsp; * Base class for common deserializers. Contains shared
&nbsp; * base functionality for dealing with primitive values, such
&nbsp; * as (re)parsing from String.
&nbsp; */
&nbsp;public abstract class StdDeserializer&lt;T&gt;
&nbsp;    extends JsonDeserializer&lt;T&gt;
&nbsp;    implements java.io.Serializable
&nbsp;{
&nbsp;    private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;    /**
&nbsp;     * Bitmask that covers {@link DeserializationFeature#USE_BIG_INTEGER_FOR_INTS}
&nbsp;     * and {@link DeserializationFeature#USE_LONG_FOR_INTS}, used for more efficient
&nbsp;     * cheks when coercing integral values for untyped deserialization.
&nbsp;     *
&nbsp;     * @since 2.6
<b class="fc">&nbsp;     */</b>
<b class="fc">&nbsp;    protected final static int F_MASK_INT_COERCIONS = </b>
<b class="fc">&nbsp;            DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.getMask()</b>
&nbsp;            | DeserializationFeature.USE_LONG_FOR_INTS.getMask();
&nbsp;    
&nbsp;    /**
&nbsp;     * Type of values this deserializer handles: sometimes
&nbsp;     * exact types, other time most specific supertype of
&nbsp;     * types deserializer handles (which may be as generic
&nbsp;     * as {@link Object} in some case)
&nbsp;     */
&nbsp;    final protected Class&lt;?&gt; _valueClass;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    protected StdDeserializer(Class&lt;?&gt; vc) {</b>
<b class="fc">&nbsp;        _valueClass = vc;</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    protected StdDeserializer(JavaType valueType) {</b>
<b class="nc">&nbsp;        _valueClass = (valueType == null) ? null : valueType.getRawClass();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy-constructor for sub-classes to use, most often when creating
&nbsp;     * new instances for {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}.
&nbsp;     * 
&nbsp;     * @since 2.5
<b class="nc">&nbsp;     */</b>
<b class="nc">&nbsp;    protected StdDeserializer(StdDeserializer&lt;?&gt; src) {</b>
<b class="nc">&nbsp;        _valueClass = src._valueClass;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Accessors
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
<b class="nc">&nbsp;    @Override</b>
&nbsp;    public Class&lt;?&gt; handledType() { return _valueClass; }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended API
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.3 use {@link #handledType} instead
&nbsp;     */
<b class="nc">&nbsp;    @Deprecated</b>
&nbsp;    public final Class&lt;?&gt; getValueClass() { return _valueClass; }
&nbsp;
&nbsp;    /**
&nbsp;     * Exact structured type deserializer handles, if known.
&nbsp;     *&lt;p&gt;
&nbsp;     * Default implementation just returns null.
<b class="nc">&nbsp;     */</b>
&nbsp;    public JavaType getValueType() { return null; }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be called to determine if given deserializer is the default
&nbsp;     * deserializer Jackson uses; as opposed to a custom deserializer installed by
&nbsp;     * a module or calling application. Determination is done using
&nbsp;     * {@link JacksonStdImpl} annotation on deserializer class.
&nbsp;     */
<b class="nc">&nbsp;    protected boolean isDefaultDeserializer(JsonDeserializer&lt;?&gt; deserializer) {</b>
&nbsp;        return ClassUtil.isJacksonStdImpl(deserializer);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser) {</b>
&nbsp;        return ClassUtil.isJacksonStdImpl(keyDeser);
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Partial JsonDeserializer implementation 
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Base implementation that does not assume specific type
&nbsp;     * inclusion mechanism. Sub-classes are expected to override
&nbsp;     * this method if they are to handle type information.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
<b class="nc">&nbsp;            TypeDeserializer typeDeserializer) throws IOException {</b>
&nbsp;        return typeDeserializer.deserializeTypedFromAny(p, ctxt);
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper methods for sub-classes, parsing: while mostly
&nbsp;    /* useful for numeric types, can be also useful for dealing
&nbsp;    /* with things serialized as numbers (such as Dates).
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    protected final boolean _parseBooleanPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_TRUE) return true;</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_FALSE) return false;</b>
&nbsp;        if (t == JsonToken.VALUE_NULL) return false;
&nbsp;
<b class="nc">&nbsp;        // should accept ints too, (0 == false, otherwise true)</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT) {</b>
&nbsp;            return _parseBooleanFromInt(p, ctxt);
&nbsp;        }
<b class="nc">&nbsp;        // And finally, let&#39;s allow Strings to be converted too</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) {</b>
&nbsp;            String text = p.getText().trim();
<b class="nc">&nbsp;            // [databind#422]: Allow aliases</b>
<b class="nc">&nbsp;            if (&quot;true&quot;.equals(text) || &quot;True&quot;.equals(text)) {</b>
&nbsp;                return true;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (&quot;false&quot;.equals(text) || &quot;False&quot;.equals(text) || text.length() == 0) {</b>
&nbsp;                return false;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (_hasTextualNull(text)) {</b>
&nbsp;                return false;
<b class="nc">&nbsp;            }</b>
&nbsp;            Boolean b = (Boolean) ctxt.handleWeirdStringValue(_valueClass, text,
<b class="nc">&nbsp;                    &quot;only \&quot;true\&quot; or \&quot;false\&quot; recognized&quot;);</b>
&nbsp;            return (b == null) ? false : b.booleanValue();
&nbsp;        }
<b class="nc">&nbsp;        // [databind#381]</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final boolean parsed = _parseBooleanPrimitive(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return ((Boolean) ctxt.handleUnexpectedToken(_valueClass, p)).booleanValue();
&nbsp;    }
&nbsp;
&nbsp;    protected final Boolean _parseBoolean(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_TRUE) {</b>
&nbsp;            return Boolean.TRUE;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_FALSE) {</b>
&nbsp;            return Boolean.FALSE;
&nbsp;        }
<b class="nc">&nbsp;        // should accept ints too, (0 == false, otherwise true)</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT) {</b>
&nbsp;            return Boolean.valueOf(_parseBooleanFromInt(p, ctxt));
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return (Boolean) getNullValue(ctxt);
&nbsp;        }
<b class="nc">&nbsp;        // And finally, let&#39;s allow Strings to be converted too</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) {</b>
&nbsp;            String text = p.getText().trim();
<b class="nc">&nbsp;            // [databind#422]: Allow aliases</b>
<b class="nc">&nbsp;            if (&quot;true&quot;.equals(text) || &quot;True&quot;.equals(text)) {</b>
&nbsp;                return Boolean.TRUE;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (&quot;false&quot;.equals(text) || &quot;False&quot;.equals(text)) {</b>
&nbsp;                return Boolean.FALSE;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (text.length() == 0) {</b>
&nbsp;                return (Boolean) getEmptyValue(ctxt);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (_hasTextualNull(text)) {</b>
&nbsp;                return (Boolean) getNullValue(ctxt);
<b class="nc">&nbsp;            }</b>
&nbsp;            return (Boolean) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                    &quot;only \&quot;true\&quot; or \&quot;false\&quot; recognized&quot;);
&nbsp;        }
<b class="nc">&nbsp;        // [databind#381]</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final Boolean parsed = _parseBoolean(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return (Boolean) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;    }
&nbsp;
&nbsp;    protected boolean _parseBooleanFromInt(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
&nbsp;    {
&nbsp;        // 13-Oct-2016, tatu: As per [databind#1324], need to be careful wrt
&nbsp;        //    degenerate case of huge integers, legal in JSON.
&nbsp;        //  ... this is, on the other hand, probably wrong/sub-optimal for non-JSON
&nbsp;        //  input. For now, no rea
&nbsp;
&nbsp;        // Anyway, note that since we know it&#39;s valid (JSON) integer, it can&#39;t have
<b class="nc">&nbsp;        // extra whitespace to trim.</b>
&nbsp;        return !&quot;0&quot;.equals(p.getText());
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated // since 2.8.4
&nbsp;    protected boolean _parseBooleanFromOther(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
&nbsp;        return _parseBooleanFromInt(p, ctxt);
&nbsp;    }
&nbsp;
&nbsp;    protected Byte _parseByte(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT) {</b>
&nbsp;            return p.getByteValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) { // let&#39;s do implicit re-parse</b>
<b class="nc">&nbsp;            String text = p.getText().trim();</b>
<b class="nc">&nbsp;            if (_hasTextualNull(text)) {</b>
&nbsp;                return (Byte) getNullValue(ctxt);
&nbsp;            }
&nbsp;            int value;
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                int len = text.length();</b>
<b class="nc">&nbsp;                if (len == 0) {</b>
&nbsp;                    return (Byte) getEmptyValue(ctxt);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                value = NumberInput.parseInt(text);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) {</b>
&nbsp;                return (Byte) ctxt.handleWeirdStringValue(_valueClass, text,
<b class="nc">&nbsp;                        &quot;not a valid Byte value&quot;);</b>
&nbsp;            }
&nbsp;            // So far so good: but does it fit?
<b class="nc">&nbsp;            // as per [JACKSON-804], allow range up to 255, inclusive</b>
<b class="nc">&nbsp;            if (value &lt; Byte.MIN_VALUE || value &gt; 255) {</b>
&nbsp;                return (Byte) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                        &quot;overflow, value can not be represented as 8-bit value&quot;);
&nbsp;                // fall-through for deferred fails
<b class="nc">&nbsp;            }</b>
&nbsp;            return Byte.valueOf((byte) value);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_FLOAT) {</b>
<b class="nc">&nbsp;            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
&nbsp;                _failDoubleToIntCoercion(p, ctxt, &quot;Byte&quot;);
<b class="nc">&nbsp;            }</b>
&nbsp;            return p.getByteValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return (Byte) getNullValue(ctxt);
&nbsp;        }
<b class="nc">&nbsp;        // [databind#381]</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final Byte parsed = _parseByte(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
<b class="nc">&nbsp;        }</b>
&nbsp;        return (Byte) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;    }
&nbsp;    
&nbsp;    protected Short _parseShort(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT) {</b>
&nbsp;            return p.getShortValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) { // let&#39;s do implicit re-parse</b>
&nbsp;            String text = p.getText().trim();
&nbsp;            int value;
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                int len = text.length();</b>
<b class="nc">&nbsp;                if (len == 0) {</b>
&nbsp;                    return (Short) getEmptyValue(ctxt);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (_hasTextualNull(text)) {</b>
&nbsp;                    return (Short) getNullValue(ctxt);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                value = NumberInput.parseInt(text);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) {</b>
&nbsp;                return (Short) ctxt.handleWeirdStringValue(_valueClass, text,
<b class="nc">&nbsp;                        &quot;not a valid Short value&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            // So far so good: but does it fit?</b>
<b class="nc">&nbsp;            if (value &lt; Short.MIN_VALUE || value &gt; Short.MAX_VALUE) {</b>
&nbsp;                return (Short) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                        &quot;overflow, value can not be represented as 16-bit value&quot;);
<b class="nc">&nbsp;            }</b>
&nbsp;            return Short.valueOf((short) value);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_FLOAT) {</b>
<b class="nc">&nbsp;            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
&nbsp;                _failDoubleToIntCoercion(p, ctxt, &quot;Short&quot;);
<b class="nc">&nbsp;            }</b>
&nbsp;            return p.getShortValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return (Short) getNullValue(ctxt);
&nbsp;        }
<b class="nc">&nbsp;        // [databind#381]</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final Short parsed = _parseShort(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
<b class="nc">&nbsp;        }</b>
&nbsp;        return (Short) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;    }
&nbsp;
&nbsp;    protected final short _parseShortPrimitive(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
&nbsp;        int value = _parseIntPrimitive(p, ctxt);
<b class="nc">&nbsp;        // So far so good: but does it fit?</b>
<b class="nc">&nbsp;        if (value &lt; Short.MIN_VALUE || value &gt; Short.MAX_VALUE) {</b>
&nbsp;            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, String.valueOf(value),
<b class="nc">&nbsp;                    &quot;overflow, value can not be represented as 16-bit value&quot;);</b>
&nbsp;            return (v == null) ? (short) 0 : v.shortValue();
<b class="nc">&nbsp;        }</b>
&nbsp;        return (short) value;
&nbsp;    }
&nbsp;
&nbsp;    protected final int _parseIntPrimitive(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {</b>
&nbsp;            return p.getIntValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) { // let&#39;s do implicit re-parse</b>
<b class="nc">&nbsp;            String text = p.getText().trim();</b>
<b class="nc">&nbsp;            if (_hasTextualNull(text)) {</b>
&nbsp;                return 0;
&nbsp;            }
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                int len = text.length();</b>
<b class="nc">&nbsp;                if (len &gt; 9) {</b>
<b class="nc">&nbsp;                    long l = Long.parseLong(text);</b>
<b class="nc">&nbsp;                    if (l &lt; Integer.MIN_VALUE || l &gt; Integer.MAX_VALUE) {</b>
&nbsp;                        Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,
<b class="nc">&nbsp;                            &quot;Overflow: numeric value (%s) out of range of int (%d -%d)&quot;,</b>
<b class="nc">&nbsp;                            text, Integer.MIN_VALUE, Integer.MAX_VALUE);</b>
&nbsp;                        return (v == null) ? 0 : v.intValue();
<b class="nc">&nbsp;                    }</b>
&nbsp;                    return (int) l;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (len == 0) {</b>
&nbsp;                    return 0;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return NumberInput.parseInt(text);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) {</b>
&nbsp;                Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,
<b class="nc">&nbsp;                        &quot;not a valid int value&quot;);</b>
&nbsp;                return (v == null) ? 0 : v.intValue();
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_FLOAT) {</b>
<b class="nc">&nbsp;            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
&nbsp;                _failDoubleToIntCoercion(p, ctxt, &quot;int&quot;);
<b class="nc">&nbsp;            }</b>
&nbsp;            return p.getValueAsInt();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return 0;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final int parsed = _parseIntPrimitive(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).intValue();
&nbsp;    }
&nbsp;
&nbsp;    protected final Integer _parseInteger(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
&nbsp;        switch (p.getCurrentTokenId()) {
&nbsp;        // NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path
<b class="nc">&nbsp;        case JsonTokenId.ID_NUMBER_INT:</b>
&nbsp;            return Integer.valueOf(p.getIntValue());
<b class="nc">&nbsp;        case JsonTokenId.ID_NUMBER_FLOAT: // coercing may work too</b>
<b class="nc">&nbsp;            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
&nbsp;                _failDoubleToIntCoercion(p, ctxt, &quot;Integer&quot;);
<b class="nc">&nbsp;            }</b>
&nbsp;            return Integer.valueOf(p.getValueAsInt());
<b class="nc">&nbsp;        case JsonTokenId.ID_STRING: // let&#39;s do implicit re-parse</b>
&nbsp;            String text = p.getText().trim();
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                int len = text.length();</b>
<b class="nc">&nbsp;                if (_hasTextualNull(text)) {</b>
&nbsp;                    return (Integer) getNullValue(ctxt);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (len &gt; 9) {</b>
<b class="nc">&nbsp;                    long l = Long.parseLong(text);</b>
<b class="nc">&nbsp;                    if (l &lt; Integer.MIN_VALUE || l &gt; Integer.MAX_VALUE) {</b>
&nbsp;                        return (Integer) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                            &quot;Overflow: numeric value (&quot;+text+&quot;) out of range of Integer (&quot;+Integer.MIN_VALUE+&quot; - &quot;+Integer.MAX_VALUE+&quot;)&quot;);
&nbsp;                        // fall-through
<b class="nc">&nbsp;                    }</b>
&nbsp;                    return Integer.valueOf((int) l);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (len == 0) {</b>
&nbsp;                    return (Integer) getEmptyValue(ctxt);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return Integer.valueOf(NumberInput.parseInt(text));</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) {</b>
&nbsp;                return (Integer) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                        &quot;not a valid Integer value&quot;);
&nbsp;            }
&nbsp;            // fall-through
<b class="nc">&nbsp;        case JsonTokenId.ID_NULL:</b>
&nbsp;            return (Integer) getNullValue(ctxt);
<b class="nc">&nbsp;        case JsonTokenId.ID_START_ARRAY:</b>
<b class="nc">&nbsp;            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;                p.nextToken();</b>
<b class="nc">&nbsp;                final Integer parsed = _parseInteger(p, ctxt);</b>
<b class="nc">&nbsp;                if (p.nextToken() != JsonToken.END_ARRAY) {</b>
&nbsp;                    handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;                }            </b>
&nbsp;                return parsed;            
&nbsp;            }
&nbsp;            break;
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return (Integer) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;    }
&nbsp;
&nbsp;    protected final Long _parseLong(JsonParser p, DeserializationContext ctxt) throws IOException
<b class="nc">&nbsp;    {</b>
&nbsp;        switch (p.getCurrentTokenId()) {
&nbsp;        // NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path
<b class="nc">&nbsp;        case JsonTokenId.ID_NUMBER_INT:</b>
&nbsp;            return p.getLongValue();
<b class="nc">&nbsp;        case JsonTokenId.ID_NUMBER_FLOAT:</b>
<b class="nc">&nbsp;            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
&nbsp;                _failDoubleToIntCoercion(p, ctxt, &quot;Long&quot;);
<b class="nc">&nbsp;            }</b>
&nbsp;            return p.getValueAsLong();
&nbsp;        case JsonTokenId.ID_STRING:
&nbsp;            // let&#39;s allow Strings to be converted too
<b class="nc">&nbsp;            // !!! 05-Jan-2009, tatu: Should we try to limit value space, JDK is too lenient?</b>
<b class="nc">&nbsp;            String text = p.getText().trim();</b>
<b class="nc">&nbsp;            if (text.length() == 0) {</b>
&nbsp;                return (Long) getEmptyValue(ctxt);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (_hasTextualNull(text)) {</b>
&nbsp;                return (Long) getNullValue(ctxt);
&nbsp;            }
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                return Long.valueOf(NumberInput.parseLong(text));</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) { }</b>
&nbsp;            return (Long) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                    &quot;not a valid Long value&quot;);
&nbsp;            // fall-through
<b class="nc">&nbsp;        case JsonTokenId.ID_NULL:</b>
&nbsp;            return (Long) getNullValue(ctxt);
<b class="nc">&nbsp;        case JsonTokenId.ID_START_ARRAY:</b>
<b class="nc">&nbsp;            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;                p.nextToken();</b>
<b class="nc">&nbsp;                final Long parsed = _parseLong(p, ctxt);</b>
<b class="nc">&nbsp;                JsonToken t = p.nextToken();</b>
<b class="nc">&nbsp;                if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                    handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;                }            </b>
&nbsp;                return parsed;            
&nbsp;            }
&nbsp;            break;
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return (Long) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;    }
&nbsp;
&nbsp;    protected final long _parseLongPrimitive(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
&nbsp;        switch (p.getCurrentTokenId()) {
<b class="nc">&nbsp;        case JsonTokenId.ID_NUMBER_INT:</b>
&nbsp;            return p.getLongValue();
<b class="nc">&nbsp;        case JsonTokenId.ID_NUMBER_FLOAT:</b>
<b class="nc">&nbsp;            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {</b>
&nbsp;                _failDoubleToIntCoercion(p, ctxt, &quot;long&quot;);
<b class="nc">&nbsp;            }</b>
&nbsp;            return p.getValueAsLong();
<b class="nc">&nbsp;        case JsonTokenId.ID_STRING:</b>
<b class="nc">&nbsp;            String text = p.getText().trim();</b>
<b class="nc">&nbsp;            if (text.length() == 0 || _hasTextualNull(text)) {</b>
&nbsp;                return 0L;
&nbsp;            }
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                return NumberInput.parseLong(text);</b>
&nbsp;            } catch (IllegalArgumentException iae) { }
<b class="nc">&nbsp;            {</b>
&nbsp;                Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,
<b class="nc">&nbsp;                        &quot;not a valid long value&quot;);</b>
&nbsp;                return (v == null) ? 0 : v.longValue();
&nbsp;            }
<b class="nc">&nbsp;        case JsonTokenId.ID_NULL:</b>
&nbsp;            return 0L;
<b class="nc">&nbsp;        case JsonTokenId.ID_START_ARRAY:</b>
<b class="nc">&nbsp;            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;                p.nextToken();</b>
<b class="nc">&nbsp;                final long parsed = _parseLongPrimitive(p, ctxt);</b>
<b class="nc">&nbsp;                JsonToken t = p.nextToken();</b>
<b class="nc">&nbsp;                if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                    handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;                }</b>
&nbsp;                return parsed;
&nbsp;            }
&nbsp;            break;
<b class="nc">&nbsp;        }</b>
&nbsp;        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).longValue();
&nbsp;    }
&nbsp;
&nbsp;    protected final Float _parseFloat(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        // We accept couple of different types; obvious ones first:</b>
&nbsp;        JsonToken t = p.getCurrentToken();
<b class="nc">&nbsp;        </b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too</b>
&nbsp;            return p.getFloatValue();
&nbsp;        }
<b class="nc">&nbsp;        // And finally, let&#39;s allow Strings to be converted too</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) {</b>
<b class="nc">&nbsp;            String text = p.getText().trim();</b>
<b class="nc">&nbsp;            if (text.length() == 0) {</b>
&nbsp;                return (Float) getEmptyValue(ctxt);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (_hasTextualNull(text)) {</b>
&nbsp;                return (Float) getNullValue(ctxt);
<b class="nc">&nbsp;            }</b>
&nbsp;            switch (text.charAt(0)) {
<b class="nc">&nbsp;            case &#39;I&#39;:</b>
<b class="nc">&nbsp;                if (_isPosInf(text)) {</b>
&nbsp;                    return Float.POSITIVE_INFINITY;
&nbsp;                }
&nbsp;                break;
<b class="nc">&nbsp;            case &#39;N&#39;:</b>
<b class="nc">&nbsp;                if (_isNaN(text)) {</b>
&nbsp;                    return Float.NaN;
&nbsp;                }
&nbsp;                break;
<b class="nc">&nbsp;            case &#39;-&#39;:</b>
<b class="nc">&nbsp;                if (_isNegInf(text)) {</b>
&nbsp;                    return Float.NEGATIVE_INFINITY;
&nbsp;                }
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                return Float.parseFloat(text);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) { }</b>
&nbsp;            return (Float) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                    &quot;not a valid Float value&quot;);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return (Float) getNullValue(ctxt);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final Float parsed = _parseFloat(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return (Float) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;    }
&nbsp;
&nbsp;    protected final float _parseFloatPrimitive(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
&nbsp;        JsonToken t = p.getCurrentToken();
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too</b>
&nbsp;            return p.getFloatValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) {</b>
<b class="nc">&nbsp;            String text = p.getText().trim();</b>
<b class="nc">&nbsp;            if (text.length() == 0 || _hasTextualNull(text)) {</b>
&nbsp;                return 0.0f;
<b class="nc">&nbsp;            }</b>
&nbsp;            switch (text.charAt(0)) {
<b class="nc">&nbsp;            case &#39;I&#39;:</b>
<b class="nc">&nbsp;                if (_isPosInf(text)) {</b>
&nbsp;                    return Float.POSITIVE_INFINITY;
&nbsp;                }
&nbsp;                break;
<b class="nc">&nbsp;            case &#39;N&#39;:</b>
&nbsp;                if (_isNaN(text)) { return Float.NaN; }
&nbsp;                break;
<b class="nc">&nbsp;            case &#39;-&#39;:</b>
<b class="nc">&nbsp;                if (_isNegInf(text)) {</b>
&nbsp;                    return Float.NEGATIVE_INFINITY;
&nbsp;                }
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                return Float.parseFloat(text);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) { }</b>
&nbsp;            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text,
<b class="nc">&nbsp;                    &quot;not a valid float value&quot;);</b>
&nbsp;            return (v == null) ? 0 : v.floatValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return 0.0f;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final float parsed = _parseFloatPrimitive(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).floatValue();
&nbsp;    }
&nbsp;
&nbsp;    protected final Double _parseDouble(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
&nbsp;        JsonToken t = p.getCurrentToken();
<b class="nc">&nbsp;        </b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too</b>
&nbsp;            return p.getDoubleValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) {</b>
<b class="nc">&nbsp;            String text = p.getText().trim();</b>
<b class="nc">&nbsp;            if (text.length() == 0) {</b>
&nbsp;                return (Double) getEmptyValue(ctxt);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (_hasTextualNull(text)) {</b>
&nbsp;                return (Double) getNullValue(ctxt);
<b class="nc">&nbsp;            }</b>
&nbsp;            switch (text.charAt(0)) {
<b class="nc">&nbsp;            case &#39;I&#39;:</b>
<b class="nc">&nbsp;                if (_isPosInf(text)) {</b>
&nbsp;                    return Double.POSITIVE_INFINITY;
&nbsp;                }
&nbsp;                break;
<b class="nc">&nbsp;            case &#39;N&#39;:</b>
<b class="nc">&nbsp;                if (_isNaN(text)) {</b>
&nbsp;                    return Double.NaN;
&nbsp;                }
&nbsp;                break;
<b class="nc">&nbsp;            case &#39;-&#39;:</b>
<b class="nc">&nbsp;                if (_isNegInf(text)) {</b>
&nbsp;                    return Double.NEGATIVE_INFINITY;
&nbsp;                }
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                return parseDouble(text);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) { }</b>
&nbsp;            return (Double) ctxt.handleWeirdStringValue(_valueClass, text,
&nbsp;                    &quot;not a valid Double value&quot;);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return (Double) getNullValue(ctxt);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final Double parsed = _parseDouble(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return (Double) ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;    }
&nbsp;
&nbsp;    protected final double _parseDoublePrimitive(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        // We accept couple of different types; obvious ones first:</b>
&nbsp;        JsonToken t = p.getCurrentToken();
<b class="nc">&nbsp;        </b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too</b>
&nbsp;            return p.getDoubleValue();
&nbsp;        }
<b class="nc">&nbsp;        // And finally, let&#39;s allow Strings to be converted too</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) {</b>
<b class="nc">&nbsp;            String text = p.getText().trim();</b>
<b class="nc">&nbsp;            if (text.length() == 0 || _hasTextualNull(text)) {</b>
&nbsp;                return 0.0;
<b class="nc">&nbsp;            }</b>
&nbsp;            switch (text.charAt(0)) {
<b class="nc">&nbsp;            case &#39;I&#39;:</b>
<b class="nc">&nbsp;                if (_isPosInf(text)) {</b>
&nbsp;                    return Double.POSITIVE_INFINITY;
&nbsp;                }
&nbsp;                break;
<b class="nc">&nbsp;            case &#39;N&#39;:</b>
<b class="nc">&nbsp;                if (_isNaN(text)) {</b>
&nbsp;                    return Double.NaN;
&nbsp;                }
&nbsp;                break;
<b class="nc">&nbsp;            case &#39;-&#39;:</b>
<b class="nc">&nbsp;                if (_isNegInf(text)) {</b>
&nbsp;                    return Double.NEGATIVE_INFINITY;
&nbsp;                }
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            try {</b>
<b class="nc">&nbsp;                return parseDouble(text);</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException iae) { }</b>
&nbsp;            Number v = (Number) ctxt.handleWeirdStringValue(_valueClass, text, 
<b class="nc">&nbsp;                    &quot;not a valid double value&quot;);</b>
&nbsp;            return (v == null) ? 0 : v.doubleValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return 0.0;
&nbsp;        }
<b class="nc">&nbsp;        // [databind#381]</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final double parsed = _parseDoublePrimitive(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
&nbsp;        }
<b class="nc">&nbsp;        // Otherwise, no can do:</b>
&nbsp;        return ((Number) ctxt.handleUnexpectedToken(_valueClass, p)).doubleValue();
&nbsp;    }
&nbsp;
&nbsp;    protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NUMBER_INT) {</b>
&nbsp;            return new java.util.Date(p.getLongValue());
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            return (java.util.Date) getNullValue(ctxt);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) {</b>
&nbsp;            return _parseDate(p.getText().trim(), ctxt);
&nbsp;        }
<b class="nc">&nbsp;        // [databind#381]</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final Date parsed = _parseDate(p, ctxt);</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
<b class="nc">&nbsp;        }</b>
&nbsp;        return (java.util.Date)  ctxt.handleUnexpectedToken(_valueClass, p);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    protected java.util.Date _parseDate(String value, DeserializationContext ctxt)
&nbsp;        throws IOException
&nbsp;    {
&nbsp;        try {
<b class="nc">&nbsp;            // Take empty Strings to mean &#39;empty&#39; Value, usually &#39;null&#39;:</b>
<b class="nc">&nbsp;            if (value.length() == 0) {</b>
&nbsp;                return (Date) getEmptyValue(ctxt);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (_hasTextualNull(value)) {</b>
&nbsp;                return (java.util.Date) getNullValue(ctxt);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return ctxt.parseDate(value);</b>
<b class="nc">&nbsp;        } catch (IllegalArgumentException iae) {</b>
<b class="nc">&nbsp;            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,</b>
&nbsp;                    &quot;not a valid representation (error: %s)&quot;, iae.getMessage());
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method for encapsulating calls to low-level double value parsing; single place
&nbsp;     * just because we need a work-around that must be applied to all calls.
&nbsp;     */
&nbsp;    protected final static double parseDouble(String numStr) throws NumberFormatException
&nbsp;    {
<b class="nc">&nbsp;        // avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?</b>
<b class="nc">&nbsp;        if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) {</b>
&nbsp;            return Double.MIN_NORMAL; // since 2.7; was MIN_VALUE prior
<b class="nc">&nbsp;        }</b>
&nbsp;        return Double.parseDouble(numStr);
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper method used for accessing String value, if possible, doing
&nbsp;     * necessary conversion or throwing exception as necessary.
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    protected final String _parseString(JsonParser p, DeserializationContext ctxt) throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_STRING) {</b>
&nbsp;            return p.getText();
&nbsp;        }
<b class="nc">&nbsp;        // [databind#381]</b>
<b class="nc">&nbsp;        if ((t == JsonToken.START_ARRAY) &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {</b>
<b class="nc">&nbsp;            p.nextToken();</b>
<b class="nc">&nbsp;            final String parsed = _parseString(p, ctxt);</b>
<b class="nc">&nbsp;            if (p.nextToken() != JsonToken.END_ARRAY) {</b>
&nbsp;                handleMissingEndArrayForSingle(p, ctxt);
<b class="nc">&nbsp;            }            </b>
&nbsp;            return parsed;            
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        String value = p.getValueAsString();</b>
<b class="nc">&nbsp;        if (value != null) {</b>
&nbsp;            return value;
<b class="nc">&nbsp;        }</b>
&nbsp;        return (String) ctxt.handleUnexpectedToken(String.class, p);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method that may be used to support fallback for Empty String / Empty Array
&nbsp;     * non-standard representations; usually for things serialized as JSON Objects.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected T _deserializeFromEmpty(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == JsonToken.START_ARRAY) {</b>
<b class="nc">&nbsp;            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {</b>
<b class="nc">&nbsp;                t = p.nextToken();</b>
<b class="nc">&nbsp;                if (t == JsonToken.END_ARRAY) {</b>
&nbsp;                    return null;
<b class="nc">&nbsp;                }</b>
&nbsp;                return (T) ctxt.handleUnexpectedToken(handledType(), p);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else if (t == JsonToken.VALUE_STRING) {</b>
<b class="nc">&nbsp;            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {</b>
<b class="nc">&nbsp;                String str = p.getText().trim();</b>
<b class="nc">&nbsp;                if (str.isEmpty()) {</b>
&nbsp;                    return null;
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        return (T) ctxt.handleUnexpectedToken(handledType(), p);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method called to determine if we are seeing String value of
&nbsp;     * &quot;null&quot;, and, further, that it should be coerced to null just like
&nbsp;     * null token.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
<b class="nc">&nbsp;    protected boolean _hasTextualNull(String value) {</b>
&nbsp;        return &quot;null&quot;.equals(value);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected final boolean _isNegInf(String text) {</b>
&nbsp;        return &quot;-Infinity&quot;.equals(text) || &quot;-INF&quot;.equals(text);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected final boolean _isPosInf(String text) {</b>
&nbsp;        return &quot;Infinity&quot;.equals(text) || &quot;INF&quot;.equals(text);
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    protected final boolean _isNaN(String text) { return &quot;NaN&quot;.equals(text); }
&nbsp;
&nbsp;    /*
&nbsp;    /****************************************************
&nbsp;    /* Helper methods for sub-classes, coercions
&nbsp;    /****************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method called in case where an integral number is encountered, but
&nbsp;     * config settings suggest that a coercion may be needed to &quot;upgrade&quot;
&nbsp;     * {@link java.lang.Number} into &quot;bigger&quot; type like {@link java.lang.Long} or
&nbsp;     * {@link java.math.BigInteger}
&nbsp;     * 
&nbsp;     * @see DeserializationFeature#USE_BIG_INTEGER_FOR_INTS
&nbsp;     * @see DeserializationFeature#USE_LONG_FOR_INTS
&nbsp;     *
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    protected Object _coerceIntegral(JsonParser p, DeserializationContext ctxt) throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        int feats = ctxt.getDeserializationFeatures();</b>
<b class="nc">&nbsp;        if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {</b>
&nbsp;            return p.getBigIntegerValue();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {</b>
&nbsp;            return p.getLongValue();
<b class="nc">&nbsp;        }</b>
&nbsp;        return p.getBigIntegerValue(); // should be optimal, whatever it is
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /****************************************************
&nbsp;    /* Helper methods for sub-classes, resolving dependencies
&nbsp;    /****************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method used to locate deserializers for properties the
&nbsp;     * type this deserializer handles contains (usually for properties of
&nbsp;     * bean types)
&nbsp;     * 
&nbsp;     * @param type Type of property to deserialize
&nbsp;     * @param property Actual property object (field, method, constuctor parameter) used
&nbsp;     *     for passing deserialized values; provided so deserializer can be contextualized if necessary
&nbsp;     */
&nbsp;    protected JsonDeserializer&lt;Object&gt; findDeserializer(DeserializationContext ctxt,
&nbsp;            JavaType type, BeanProperty property)
&nbsp;        throws JsonMappingException
<b class="nc">&nbsp;    {</b>
&nbsp;        return ctxt.findContextualValueDeserializer(type, property);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method to check whether given text refers to what looks like a clean simple
&nbsp;     * integer number, consisting of optional sign followed by a sequence of digits.
&nbsp;     */
&nbsp;    protected final boolean _isIntNumber(String text)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        final int len = text.length();</b>
<b class="nc">&nbsp;        if (len &gt; 0) {</b>
&nbsp;            char c = text.charAt(0);
<b class="nc">&nbsp;            // skip leading sign (plus not allowed for strict JSON numbers but...)</b>
<b class="nc">&nbsp;            int i = (c == &#39;-&#39; || c == &#39;+&#39;) ? 1 : 0;</b>
<b class="nc">&nbsp;            for (; i &lt; len; ++i) {</b>
<b class="nc">&nbsp;                int ch = text.charAt(i);</b>
<b class="nc">&nbsp;                if (ch &gt; &#39;9&#39; || ch &lt; &#39;0&#39;) {</b>
&nbsp;                    return false;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            return true;
<b class="nc">&nbsp;        }</b>
&nbsp;        return false;
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper methods for sub-classes, deserializer construction
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Helper method that can be used to see if specified property has annotation
&nbsp;     * indicating that a converter is to be used for contained values (contents
&nbsp;     * of structured types; array/List/Map values)
&nbsp;     * 
&nbsp;     * @param existingDeserializer (optional) configured content
&nbsp;     *    serializer if one already exists.
&nbsp;     * 
&nbsp;     * @since 2.2
&nbsp;     */
&nbsp;    protected JsonDeserializer&lt;?&gt; findConvertingContentDeserializer(DeserializationContext ctxt,
&nbsp;            BeanProperty prop, JsonDeserializer&lt;?&gt; existingDeserializer)
&nbsp;        throws JsonMappingException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();</b>
<b class="nc">&nbsp;        if (intr != null &amp;&amp; prop != null) {</b>
<b class="nc">&nbsp;            AnnotatedMember member = prop.getMember();</b>
<b class="nc">&nbsp;            if (member != null) {</b>
<b class="nc">&nbsp;                Object convDef = intr.findDeserializationContentConverter(member);</b>
<b class="nc">&nbsp;                if (convDef != null) {</b>
<b class="nc">&nbsp;                    Converter&lt;Object,Object&gt; conv = ctxt.converterInstance(prop.getMember(), convDef);</b>
<b class="nc">&nbsp;                    JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());</b>
<b class="nc">&nbsp;                    if (existingDeserializer == null) {</b>
&nbsp;                        existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop);
<b class="nc">&nbsp;                    }</b>
&nbsp;                    return new StdDelegatingDeserializer&lt;Object&gt;(conv, delegateType, existingDeserializer);
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        return existingDeserializer;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method that may be used to find if this deserializer has specific
&nbsp;     * {@link JsonFormat} settings, either via property, or through type-specific
&nbsp;     * defaulting.
&nbsp;     *
&nbsp;     * @param typeForDefaults Type (erased) used for finding default format settings, if any
&nbsp;     *
&nbsp;     * @since 2.7
&nbsp;     */
&nbsp;    protected JsonFormat.Value findFormatOverrides(DeserializationContext ctxt,
&nbsp;            BeanProperty prop, Class&lt;?&gt; typeForDefaults)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        if (prop != null) {</b>
&nbsp;            return prop.findPropertyFormat(ctxt.getConfig(), typeForDefaults);
&nbsp;        }
<b class="nc">&nbsp;        // even without property or AnnotationIntrospector, may have type-specific defaults</b>
&nbsp;        return ctxt.getDefaultPropertyFormat(typeForDefaults);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that uses {@link #findFormatOverrides} to find possible
&nbsp;     * defaults and/of overrides, and then calls
&nbsp;     * &lt;code&gt;JsonFormat.Value.getFeature(feat)&lt;/code&gt;
&nbsp;     * to find whether that feature has been specifically marked as enabled or disabled.
&nbsp;     * 
&nbsp;     * @param typeForDefaults Type (erased) used for finding default format settings, if any
&nbsp;     *
&nbsp;     * @since 2.7
&nbsp;     */
&nbsp;    protected Boolean findFormatFeature(DeserializationContext ctxt,
&nbsp;            BeanProperty prop, Class&lt;?&gt; typeForDefaults, JsonFormat.Feature feat)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        JsonFormat.Value format = findFormatOverrides(ctxt, prop, typeForDefaults);</b>
<b class="nc">&nbsp;        if (format != null) {</b>
&nbsp;            return format.getFeature(feat);
<b class="nc">&nbsp;        }</b>
&nbsp;        return null;
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper methods for sub-classes, problem reporting
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method called to deal with a property that did not map to a known
&nbsp;     * Bean property. Method can deal with the problem as it sees fit (ignore,
&nbsp;     * throw exception); but if it does return, it has to skip the matching
&nbsp;     * Json content parser has.
&nbsp;     *
&nbsp;     * @param p Parser that points to value of the unknown property
&nbsp;     * @param ctxt Context for deserialization; allows access to the parser,
&nbsp;     *    error reporting functionality
&nbsp;     * @param instanceOrClass Instance that is being populated by this
&nbsp;     *   deserializer, or if not known, Class that would be instantiated.
&nbsp;     *   If null, will assume type is what {@link #getValueClass} returns.
&nbsp;     * @param propName Name of the property that can not be mapped
&nbsp;     */
&nbsp;    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt, Object instanceOrClass, String propName)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        if (instanceOrClass == null) {</b>
&nbsp;            instanceOrClass = handledType();
&nbsp;        }
<b class="nc">&nbsp;        // Maybe we have configured handler(s) to take care of it?</b>
<b class="nc">&nbsp;        if (ctxt.handleUnknownProperty(p, this, instanceOrClass, propName)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        /* But if we do get this far, need to skip whatever value we
&nbsp;         * are pointing to now (although handler is likely to have done that already)
<b class="nc">&nbsp;         */</b>
<b class="nc">&nbsp;        p.skipChildren();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void handleMissingEndArrayForSingle(JsonParser p, DeserializationContext ctxt)
&nbsp;        throws IOException
<b class="nc">&nbsp;    {</b>
&nbsp;        ctxt.reportWrongTokenException(p, JsonToken.END_ARRAY, 
<b class="nc">&nbsp;&quot;Attempted to unwrap single value array for single &#39;%s&#39; value but there was more than a single value in the array&quot;,</b>
&nbsp;handledType().getName());
&nbsp;        // 05-May-2016, tatu: Should recover somehow (maybe skip until END_ARRAY);
<b class="nc">&nbsp;        //     but for now just fall through</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void _failDoubleToIntCoercion(JsonParser p, DeserializationContext ctxt,
&nbsp;            String type) throws IOException
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        ctxt.reportMappingException(&quot;Can not coerce a floating-point value (&#39;%s&#39;) into %s; enable `DeserializationFeature.ACCEPT_FLOAT_AS_INT` to allow&quot;,</b>
<b class="nc">&nbsp;                        p.getValueAsString(), type);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-09 23:27</div>
</div>
</body>
</html>
